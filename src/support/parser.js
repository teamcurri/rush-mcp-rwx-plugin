"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode2(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar2(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias2;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap2;
    exports2.isNode = isNode2;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar2;
    exports2.isSeq = isSeq2;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit2(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === "function")
        return visitor(key, node, path);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
      return void 0;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit2;
    exports2.visitAsync = visitAsync;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit2.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit2.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit2 = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit2.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map3 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map3.items.push(value);
        return map3;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent2) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent2 ? comment.replace(/^(?! *$)/gm, indent2) : comment;
    }
    var lineComment = (str, indent2, comment) => str.endsWith("\n") ? indentComment(comment, indent2) : comment.includes("\n") ? "\n" + indentComment(comment, indent2) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent2, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent2.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent2.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent2.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent2.length);
          end = i + indent2.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent2}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent2}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent2) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent2) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent2;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent2, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent2}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent2.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent2}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent2}`);
      }
      const indentSize = indent2 ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent2}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent2, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent2}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent2}`);
      return `|${header}
${indent2}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent: indent2, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent2 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent2 === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent2}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t) => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t) => t.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent2 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent2}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    var node_process = require("process");
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map3, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map3, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map3, it);
      else
        mergeValue(ctx, map3, value);
    }
    function mergeValue(ctx, map3, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map3 instanceof Map) {
          if (!map3.has(key))
            map3.set(key, value2);
        } else if (map3 instanceof Set) {
          map3.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
          Object.defineProperty(map3, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map3;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log = require_log();
    var merge = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map3, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map3, value);
      else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map3, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map3 instanceof Map) {
          map3.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map3 instanceof Set) {
          map3.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map3)
            Object.defineProperty(map3, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map3[stringKey] = jsValue;
        }
      }
      return map3;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent2, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent2}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent2);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent: indent2, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent2}${line}` : "\n";
          return `${str}
${indent2}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent: indent2, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent2);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map3 = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map3.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map3.items.sort(schema.sortMapEntries);
        }
        return map3;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type2) {
        const map3 = Type2 ? new Type2() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map3, item);
        return map3;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map3 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map4, onError) {
        if (!identity.isMap(map4))
          onError("Expected a mapping for this tag");
        return map4;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map3;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map3 = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map3.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var node_buffer = require("buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value);
        }
        return map3;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map3, onError) {
        if (identity.isMap(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map3.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map3.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map3 = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map3.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection.isEmptyPath(path))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent2, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent2 && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map3 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map3.comment)
                map3.comment += "\n" + keyProps.comment;
              else
                map3.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map3.range = [bm.offset, offset, commentEnd ?? offset];
      return map3;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap2 = fc.start.source === "{";
      const fcName = isMap2 ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap2 && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap2 && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap2 && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap2) {
            const map3 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map3.items.push(pair);
          } else {
            const map3 = new YAMLMap.YAMLMap(ctx.schema);
            map3.flow = true;
            map3.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map3.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map3);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap2 ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent2, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent2.length > trimIndent)
            trimIndent = indent2.length;
        } else {
          if (indent2.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent2.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent2.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent2.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent2, content] = lines[i];
        offset += indent2.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent2.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent2 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent2.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent2.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent2.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent2 = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent2 && n)
            indent2 = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent: indent2, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent: indent2, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent: indent2, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent2, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
          return { type: "block-scalar", offset, indent: indent2, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent2, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent2, source, end };
        default:
          return { type: "scalar", offset, indent: indent2, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent2 = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent2 === "number")
        indent2 += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent2 === null,
        indent: indent2 !== null && indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent2 = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent2, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent: indent2, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent2 = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent: indent2, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit2(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports2.visit = visit2;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar2;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer2 = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent2 = 0;
          while (ch === " ")
            ch = this.buffer[++indent2 + offset];
          if (ch === "\r") {
            const next = this.buffer[indent2 + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent2 + 1;
          }
          return ch === "\n" || indent2 >= this.indentNext || !ch && !this.atEnd ? offset + indent2 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent2 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent2 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent2 !== -1 && indent2 < this.indentNext && line[0] !== "#" || indent2 === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent2 === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent2 = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent2 += 1;
              break;
            case "\n":
              nl = i2;
              indent2 = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent2 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent2;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent2 > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer2;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser2 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent2) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent2)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser2;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument2(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument2(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent2 = Math.round(options);
        options = indent2 < 1 ? void 0 : indent2 > 8 ? { indent: 8 } : { indent: indent2 };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument2;
    exports2.stringify = stringify;
  }
});

// node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit2 = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit2.visit;
    exports2.visitAsync = visit2.visitAsync;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "10.5.0";
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol3 = root.Symbol;
    module2.exports = Symbol3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise3 = getNative(root, "Promise");
    module2.exports = Promise3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set5 = getNative(root, "Set");
    module2.exports = Set5;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise3 = require_Promise();
    var Set5 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise3);
    var setCtorString = toSource(Set5);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    module2.exports = nodeUtil;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash2(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    module2.exports = Hash2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash2 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array3 = root.Uint8Array;
    module2.exports = Uint8Array3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var Uint8Array3 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
var require_identity2 = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity2();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js
var require_map2 = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map3(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map3;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity2();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module2.exports = baseHas;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module2.exports = has;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = (function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    })();
    module2.exports = defineProperty;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array3 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ (function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    })();
    module2.exports = baseCreate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap2 = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap2(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone;
  }
});

// node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js
var require_print = __commonJS({
  "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
    function PRINT_ERROR(msg) {
      if (console && console.error) {
        console.error("Error: ".concat(msg));
      }
    }
    exports2.PRINT_ERROR = PRINT_ERROR;
    function PRINT_WARNING(msg) {
      if (console && console.warn) {
        console.warn("Warning: ".concat(msg));
      }
    }
    exports2.PRINT_WARNING = PRINT_WARNING;
  }
});

// node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js
var require_timer = __commonJS({
  "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    function timer(func) {
      var start = (/* @__PURE__ */ new Date()).getTime();
      var val = func();
      var end = (/* @__PURE__ */ new Date()).getTime();
      var total = end - start;
      return { time: total, value: val };
    }
    exports2.timer = timer;
  }
});

// node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
var require_to_fast_properties = __commonJS({
  "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFastProperties = void 0;
    function toFastProperties(toBecomeFast) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = toBecomeFast;
      var fakeInstance = new FakeConstructor();
      function fakeAccess() {
        return typeof fakeInstance.bar;
      }
      fakeAccess();
      fakeAccess();
      if (1)
        return toBecomeFast;
      eval(toBecomeFast);
    }
    exports.toFastProperties = toFastProperties;
  }
});

// node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
    var print_1 = require_print();
    Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
      return print_1.PRINT_WARNING;
    } });
    Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
      return print_1.PRINT_ERROR;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var to_fast_properties_1 = require_to_fast_properties();
    Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
      return to_fast_properties_1.toFastProperties;
    } });
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js
var require_drop = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    module2.exports = drop;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module2.exports = baseIsRegExp;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    module2.exports = pickBy;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity2();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity2();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign;
  }
});

// node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js
var require_model = __commonJS({
  "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var pickBy_1 = __importDefault(require_pickBy());
    var assign_1 = __importDefault(require_assign());
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    var AbstractProduction = (
      /** @class */
      (function() {
        function AbstractProduction2(_definition) {
          this._definition = _definition;
        }
        Object.defineProperty(AbstractProduction2.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        AbstractProduction2.prototype.accept = function(visitor) {
          visitor.visit(this);
          (0, forEach_1.default)(this.definition, function(prod) {
            prod.accept(visitor);
          });
        };
        return AbstractProduction2;
      })()
    );
    exports2.AbstractProduction = AbstractProduction;
    var NonTerminal2 = (
      /** @class */
      (function(_super) {
        __extends(NonTerminal3, _super);
        function NonTerminal3(options) {
          var _this = _super.call(this, []) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(NonTerminal3.prototype, "definition", {
          get: function() {
            if (this.referencedRule !== void 0) {
              return this.referencedRule.definition;
            }
            return [];
          },
          set: function(definition) {
          },
          enumerable: false,
          configurable: true
        });
        NonTerminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return NonTerminal3;
      })(AbstractProduction)
    );
    exports2.NonTerminal = NonTerminal2;
    var Rule2 = (
      /** @class */
      (function(_super) {
        __extends(Rule3, _super);
        function Rule3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.orgText = "";
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Rule3;
      })(AbstractProduction)
    );
    exports2.Rule = Rule2;
    var Alternative2 = (
      /** @class */
      (function(_super) {
        __extends(Alternative3, _super);
        function Alternative3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.ignoreAmbiguities = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Alternative3;
      })(AbstractProduction)
    );
    exports2.Alternative = Alternative2;
    var Option2 = (
      /** @class */
      (function(_super) {
        __extends(Option3, _super);
        function Option3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Option3;
      })(AbstractProduction)
    );
    exports2.Option = Option2;
    var RepetitionMandatory2 = (
      /** @class */
      (function(_super) {
        __extends(RepetitionMandatory3, _super);
        function RepetitionMandatory3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatory3;
      })(AbstractProduction)
    );
    exports2.RepetitionMandatory = RepetitionMandatory2;
    var RepetitionMandatoryWithSeparator2 = (
      /** @class */
      (function(_super) {
        __extends(RepetitionMandatoryWithSeparator3, _super);
        function RepetitionMandatoryWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatoryWithSeparator3;
      })(AbstractProduction)
    );
    exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator2;
    var Repetition2 = (
      /** @class */
      (function(_super) {
        __extends(Repetition3, _super);
        function Repetition3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Repetition3;
      })(AbstractProduction)
    );
    exports2.Repetition = Repetition2;
    var RepetitionWithSeparator2 = (
      /** @class */
      (function(_super) {
        __extends(RepetitionWithSeparator3, _super);
        function RepetitionWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionWithSeparator3;
      })(AbstractProduction)
    );
    exports2.RepetitionWithSeparator = RepetitionWithSeparator2;
    var Alternation2 = (
      /** @class */
      (function(_super) {
        __extends(Alternation3, _super);
        function Alternation3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          _this.ignoreAmbiguities = false;
          _this.hasPredicates = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(Alternation3.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        return Alternation3;
      })(AbstractProduction)
    );
    exports2.Alternation = Alternation2;
    var Terminal2 = (
      /** @class */
      (function() {
        function Terminal3(options) {
          this.idx = 1;
          (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
        }
        Terminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return Terminal3;
      })()
    );
    exports2.Terminal = Terminal2;
    function serializeGrammar2(topRules) {
      return (0, map_1.default)(topRules, serializeProduction2);
    }
    exports2.serializeGrammar = serializeGrammar2;
    function serializeProduction2(node) {
      function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction2);
      }
      if (node instanceof NonTerminal2) {
        var serializedNonTerminal = {
          type: "NonTerminal",
          name: node.nonTerminalName,
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
      } else if (node instanceof Alternative2) {
        return {
          type: "Alternative",
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Option2) {
        return {
          type: "Option",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatory2) {
        return {
          type: "RepetitionMandatory",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatoryWithSeparator2) {
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionWithSeparator2) {
        return {
          type: "RepetitionWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Repetition2) {
        return {
          type: "Repetition",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Alternation2) {
        return {
          type: "Alternation",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Terminal2) {
        var serializedTerminal = {
          type: "Terminal",
          name: node.terminalType.name,
          label: tokenLabel2(node.terminalType),
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedTerminal.terminalLabel = node.label;
        }
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
          serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
      } else if (node instanceof Rule2) {
        return {
          type: "Rule",
          name: node.name,
          orgText: node.orgText,
          definition: convertDefinition(node.definition)
        };
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.serializeProduction = serializeProduction2;
  }
});

// node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js
var require_visitor = __commonJS({
  "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GAstVisitor = void 0;
    var model_1 = require_model();
    var GAstVisitor2 = (
      /** @class */
      (function() {
        function GAstVisitor3() {
        }
        GAstVisitor3.prototype.visit = function(node) {
          var nodeAny = node;
          switch (nodeAny.constructor) {
            case model_1.NonTerminal:
              return this.visitNonTerminal(nodeAny);
            case model_1.Alternative:
              return this.visitAlternative(nodeAny);
            case model_1.Option:
              return this.visitOption(nodeAny);
            case model_1.RepetitionMandatory:
              return this.visitRepetitionMandatory(nodeAny);
            case model_1.RepetitionMandatoryWithSeparator:
              return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case model_1.RepetitionWithSeparator:
              return this.visitRepetitionWithSeparator(nodeAny);
            case model_1.Repetition:
              return this.visitRepetition(nodeAny);
            case model_1.Alternation:
              return this.visitAlternation(nodeAny);
            case model_1.Terminal:
              return this.visitTerminal(nodeAny);
            case model_1.Rule:
              return this.visitRule(nodeAny);
            /* istanbul ignore next */
            default:
              throw Error("non exhaustive match");
          }
        };
        GAstVisitor3.prototype.visitNonTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitAlternative = function(node) {
        };
        GAstVisitor3.prototype.visitOption = function(node) {
        };
        GAstVisitor3.prototype.visitRepetition = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatory = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitAlternation = function(node) {
        };
        GAstVisitor3.prototype.visitTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitRule = function(node) {
        };
        return GAstVisitor3;
      })()
    );
    exports2.GAstVisitor = GAstVisitor2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module2.exports = baseSome;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js"(exports2, module2) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = some;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js
var require_arrayEvery = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js"(exports2, module2) {
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = arrayEvery;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js
var require_baseEvery = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection2) {
        result = !!predicate(value, index, collection2);
        return result;
      });
      return result;
    }
    module2.exports = baseEvery;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js
var require_every = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js"(exports2, module2) {
    var arrayEvery = require_arrayEvery();
    var baseEvery = require_baseEvery();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = every;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module2.exports = includes;
  }
});

// node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
    var some_1 = __importDefault(require_some());
    var every_1 = __importDefault(require_every());
    var includes_1 = __importDefault(require_includes());
    var model_1 = require_model();
    function isSequenceProd(prod) {
      return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
    }
    exports2.isSequenceProd = isSequenceProd;
    function isOptionalProd(prod, alreadyVisited) {
      if (alreadyVisited === void 0) {
        alreadyVisited = [];
      }
      var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
      if (isDirectlyOptional) {
        return true;
      }
      if (prod instanceof model_1.Alternation) {
        return (0, some_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
        return false;
      } else if (prod instanceof model_1.AbstractProduction) {
        if (prod instanceof model_1.NonTerminal) {
          alreadyVisited.push(prod);
        }
        return (0, every_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else {
        return false;
      }
    }
    exports2.isOptionalProd = isOptionalProd;
    function isBranchingProd(prod) {
      return prod instanceof model_1.Alternation;
    }
    exports2.isBranchingProd = isBranchingProd;
    function getProductionDslName(prod) {
      if (prod instanceof model_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof model_1.Option) {
        return "OPTION";
      } else if (prod instanceof model_1.Alternation) {
        return "OR";
      } else if (prod instanceof model_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof model_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof model_1.Repetition) {
        return "MANY";
      } else if (prod instanceof model_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProductionDslName = getProductionDslName;
  }
});

// node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js
var require_api2 = __commonJS({
  "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
    var model_1 = require_model();
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return model_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return model_1.Terminal;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return model_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return model_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return model_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return model_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return model_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return model_1.Alternative;
    } });
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return model_1.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return model_1.serializeProduction;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return visitor_1.GAstVisitor;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
      return helpers_1.getProductionDslName;
    } });
    Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
      return helpers_1.isOptionalProd;
    } });
    Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
      return helpers_1.isBranchingProd;
    } });
    Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
      return helpers_1.isSequenceProd;
    } });
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js
var require_rest = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestWalker = void 0;
    var drop_1 = __importDefault(require_drop());
    var forEach_1 = __importDefault(require_forEach());
    var gast_1 = require_api2();
    var RestWalker = (
      /** @class */
      (function() {
        function RestWalker2() {
        }
        RestWalker2.prototype.walk = function(prod, prevRest) {
          var _this = this;
          if (prevRest === void 0) {
            prevRest = [];
          }
          (0, forEach_1.default)(prod.definition, function(subProd, index) {
            var currRest = (0, drop_1.default)(prod.definition, index + 1);
            if (subProd instanceof gast_1.NonTerminal) {
              _this.walkProdRef(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Terminal) {
              _this.walkTerminal(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternative) {
              _this.walkFlat(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Option) {
              _this.walkOption(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatory) {
              _this.walkAtLeastOne(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
              _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
              _this.walkManySep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Repetition) {
              _this.walkMany(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternation) {
              _this.walkOr(subProd, currRest, prevRest);
            } else {
              throw Error("non exhaustive match");
            }
          });
        };
        RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        };
        RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(flatProd, fullOrRest);
        };
        RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(optionProd, fullOrRest);
        };
        RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          var fullAtLeastOneRest = [
            new gast_1.Option({ definition: atLeastOneProd.definition })
          ].concat(currRest, prevRest);
          this.walk(atLeastOneProd, fullAtLeastOneRest);
        };
        RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
        };
        RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          var fullManyRest = [
            new gast_1.Option({ definition: manyProd.definition })
          ].concat(currRest, prevRest);
          this.walk(manyProd, fullManyRest);
        };
        RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
          this.walk(manySepProd, fullManySepRest);
        };
        RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
          var _this = this;
          var fullOrRest = currRest.concat(prevRest);
          (0, forEach_1.default)(orProd.definition, function(alt) {
            var prodWrapper = new gast_1.Alternative({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
          });
        };
        return RestWalker2;
      })()
    );
    exports2.RestWalker = RestWalker;
    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
      var repSepRest = [
        new gast_1.Option({
          definition: [
            new gast_1.Terminal({ terminalType: repSepProd.separator })
          ].concat(repSepProd.definition)
        })
      ];
      var fullRepSepRest = repSepRest.concat(currRest, prevRest);
      return fullRepSepRest;
    }
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set5 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set5 && 1 / setToArray(new Set5([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set5(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js
var require_first = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var uniq_1 = __importDefault(require_uniq());
    var map_1 = __importDefault(require_map2());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    function first(prod) {
      if (prod instanceof gast_1.NonTerminal) {
        return first(prod.referencedRule);
      } else if (prod instanceof gast_1.Terminal) {
        return firstForTerminal(prod);
      } else if ((0, gast_2.isSequenceProd)(prod)) {
        return firstForSequence(prod);
      } else if ((0, gast_2.isBranchingProd)(prod)) {
        return firstForBranching(prod);
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.first = first;
    function firstForSequence(prod) {
      var firstSet = [];
      var seq = prod.definition;
      var nextSubProdIdx = 0;
      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      var currSubProd;
      var isLastInnerProdOptional = true;
      while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      }
      return (0, uniq_1.default)(firstSet);
    }
    exports2.firstForSequence = firstForSequence;
    function firstForBranching(prod) {
      var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
        return first(innerProd);
      });
      return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
    }
    exports2.firstForBranching = firstForBranching;
    function firstForTerminal(terminal) {
      return [terminal.terminalType];
    }
    exports2.firstForTerminal = firstForTerminal;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IN = void 0;
    exports2.IN = "_~IN~_";
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js
var require_follow = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = require_first();
    var forEach_1 = __importDefault(require_forEach());
    var assign_1 = __importDefault(require_assign());
    var constants_1 = require_constants();
    var gast_1 = require_api2();
    var ResyncFollowsWalker = (
      /** @class */
      (function(_super) {
        __extends(ResyncFollowsWalker2, _super);
        function ResyncFollowsWalker2(topProd) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.follows = {};
          return _this;
        }
        ResyncFollowsWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.follows;
        };
        ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
          var fullRest = currRest.concat(prevRest);
          var restProd = new gast_1.Alternative({ definition: fullRest });
          var t_in_topProd_follows = (0, first_1.first)(restProd);
          this.follows[followName] = t_in_topProd_follows;
        };
        return ResyncFollowsWalker2;
      })(rest_1.RestWalker)
    );
    exports2.ResyncFollowsWalker = ResyncFollowsWalker;
    function computeAllProdsFollows(topProductions) {
      var reSyncFollows = {};
      (0, forEach_1.default)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, assign_1.default)(reSyncFollows, currRefsFollow);
      });
      return reSyncFollows;
    }
    exports2.computeAllProdsFollows = computeAllProdsFollows;
    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
      return inner.name + occurenceInParent + constants_1.IN;
    }
    exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
    function buildInProdFollowPrefix(terminal) {
      var terminalName = terminal.terminalType.name;
      return terminalName + terminal.idx + constants_1.IN;
    }
    exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js
var require_regexp_to_ast = __commonJS({
  "node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.regexpToAst = factory();
      }
    })(
      typeof self !== "undefined" ? (
        // istanbul ignore next
        self
      ) : exports2,
      function() {
        function RegExpParser() {
        }
        RegExpParser.prototype.saveState = function() {
          return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
          };
        };
        RegExpParser.prototype.restoreState = function(newState) {
          this.idx = newState.idx;
          this.input = newState.input;
          this.groupIdx = newState.groupIdx;
        };
        RegExpParser.prototype.pattern = function(input) {
          this.idx = 0;
          this.input = input;
          this.groupIdx = 0;
          this.consumeChar("/");
          var value = this.disjunction();
          this.consumeChar("/");
          var flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
          };
          while (this.isRegExpFlag()) {
            switch (this.popChar()) {
              case "g":
                addFlag(flags, "global");
                break;
              case "i":
                addFlag(flags, "ignoreCase");
                break;
              case "m":
                addFlag(flags, "multiLine");
                break;
              case "u":
                addFlag(flags, "unicode");
                break;
              case "y":
                addFlag(flags, "sticky");
                break;
            }
          }
          if (this.idx !== this.input.length) {
            throw Error(
              "Redundant input: " + this.input.substring(this.idx)
            );
          }
          return {
            type: "Pattern",
            flags,
            value,
            loc: this.loc(0)
          };
        };
        RegExpParser.prototype.disjunction = function() {
          var alts = [];
          var begin = this.idx;
          alts.push(this.alternative());
          while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
          }
          return { type: "Disjunction", value: alts, loc: this.loc(begin) };
        };
        RegExpParser.prototype.alternative = function() {
          var terms = [];
          var begin = this.idx;
          while (this.isTerm()) {
            terms.push(this.term());
          }
          return { type: "Alternative", value: terms, loc: this.loc(begin) };
        };
        RegExpParser.prototype.term = function() {
          if (this.isAssertion()) {
            return this.assertion();
          } else {
            return this.atom();
          }
        };
        RegExpParser.prototype.assertion = function() {
          var begin = this.idx;
          switch (this.popChar()) {
            case "^":
              return {
                type: "StartAnchor",
                loc: this.loc(begin)
              };
            case "$":
              return { type: "EndAnchor", loc: this.loc(begin) };
            // '\b' or '\B'
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return {
                    type: "WordBoundary",
                    loc: this.loc(begin)
                  };
                case "B":
                  return {
                    type: "NonWordBoundary",
                    loc: this.loc(begin)
                  };
              }
              throw Error("Invalid Assertion Escape");
            // '(?=' or '(?!'
            case "(":
              this.consumeChar("?");
              var type;
              switch (this.popChar()) {
                case "=":
                  type = "Lookahead";
                  break;
                case "!":
                  type = "NegativeLookahead";
                  break;
              }
              ASSERT_EXISTS(type);
              var disjunction = this.disjunction();
              this.consumeChar(")");
              return {
                type,
                value: disjunction,
                loc: this.loc(begin)
              };
          }
          ASSERT_NEVER_REACH_HERE();
        };
        RegExpParser.prototype.quantifier = function(isBacktracking) {
          var range;
          var begin = this.idx;
          switch (this.popChar()) {
            case "*":
              range = {
                atLeast: 0,
                atMost: Infinity
              };
              break;
            case "+":
              range = {
                atLeast: 1,
                atMost: Infinity
              };
              break;
            case "?":
              range = {
                atLeast: 0,
                atMost: 1
              };
              break;
            case "{":
              var atLeast = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  range = {
                    atLeast,
                    atMost: atLeast
                  };
                  break;
                case ",":
                  var atMost;
                  if (this.isDigit()) {
                    atMost = this.integerIncludingZero();
                    range = {
                      atLeast,
                      atMost
                    };
                  } else {
                    range = {
                      atLeast,
                      atMost: Infinity
                    };
                  }
                  this.consumeChar("}");
                  break;
              }
              if (isBacktracking === true && range === void 0) {
                return void 0;
              }
              ASSERT_EXISTS(range);
              break;
          }
          if (isBacktracking === true && range === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range);
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
          } else {
            range.greedy = true;
          }
          range.type = "Quantifier";
          range.loc = this.loc(begin);
          return range;
        };
        RegExpParser.prototype.atom = function() {
          var atom;
          var begin = this.idx;
          switch (this.peekChar()) {
            case ".":
              atom = this.dotAll();
              break;
            case "\\":
              atom = this.atomEscape();
              break;
            case "[":
              atom = this.characterClass();
              break;
            case "(":
              atom = this.group();
              break;
          }
          if (atom === void 0 && this.isPatternCharacter()) {
            atom = this.patternCharacter();
          }
          ASSERT_EXISTS(atom);
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        };
        RegExpParser.prototype.dotAll = function() {
          this.consumeChar(".");
          return {
            type: "Set",
            complement: true,
            value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
          };
        };
        RegExpParser.prototype.atomEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.decimalEscapeAtom = function() {
          var value = this.positiveInteger();
          return { type: "GroupBackReference", value };
        };
        RegExpParser.prototype.characterClassEscape = function() {
          var set;
          var complement = false;
          switch (this.popChar()) {
            case "d":
              set = digitsCharCodes;
              break;
            case "D":
              set = digitsCharCodes;
              complement = true;
              break;
            case "s":
              set = whitespaceCodes;
              break;
            case "S":
              set = whitespaceCodes;
              complement = true;
              break;
            case "w":
              set = wordCharCodes;
              break;
            case "W":
              set = wordCharCodes;
              complement = true;
              break;
          }
          ASSERT_EXISTS(set);
          return { type: "Set", value: set, complement };
        };
        RegExpParser.prototype.controlEscapeAtom = function() {
          var escapeCode;
          switch (this.popChar()) {
            case "f":
              escapeCode = cc("\f");
              break;
            case "n":
              escapeCode = cc("\n");
              break;
            case "r":
              escapeCode = cc("\r");
              break;
            case "t":
              escapeCode = cc("	");
              break;
            case "v":
              escapeCode = cc("\v");
              break;
          }
          ASSERT_EXISTS(escapeCode);
          return { type: "Character", value: escapeCode };
        };
        RegExpParser.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var letter = this.popChar();
          if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
          }
          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: letterCode };
        };
        RegExpParser.prototype.nulCharacterAtom = function() {
          this.consumeChar("0");
          return { type: "Character", value: cc("\0") };
        };
        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
          this.consumeChar("x");
          return this.parseHexDigits(2);
        };
        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          this.consumeChar("u");
          return this.parseHexDigits(4);
        };
        RegExpParser.prototype.identityEscapeAtom = function() {
          var escapedChar = this.popChar();
          return { type: "Character", value: cc(escapedChar) };
        };
        RegExpParser.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case "]":
              throw Error("TBD");
            default:
              var nextChar = this.popChar();
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.characterClass = function() {
          var set = [];
          var complement = false;
          this.consumeChar("[");
          if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
          }
          while (this.isClassAtom()) {
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
              this.consumeChar("-");
              var to = this.classAtom();
              var isToSingleChar = to.type === "Character";
              if (isToSingleChar) {
                if (to.value < from.value) {
                  throw Error("Range out of order in character class");
                }
                set.push({ from: from.value, to: to.value });
              } else {
                insertToSet(from.value, set);
                set.push(cc("-"));
                insertToSet(to.value, set);
              }
            } else {
              insertToSet(from.value, set);
            }
          }
          this.consumeChar("]");
          return { type: "Set", complement, value: set };
        };
        RegExpParser.prototype.classAtom = function() {
          switch (this.peekChar()) {
            // istanbul ignore next
            case "]":
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        };
        RegExpParser.prototype.classEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            // Matches a backspace.
            // (Not to be confused with \b word boundary outside characterClass)
            case "b":
              this.consumeChar("b");
              return { type: "Character", value: cc("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.group = function() {
          var capturing = true;
          this.consumeChar("(");
          switch (this.peekChar(0)) {
            case "?":
              this.consumeChar("?");
              this.consumeChar(":");
              capturing = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var value = this.disjunction();
          this.consumeChar(")");
          var groupAst = {
            type: "Group",
            capturing,
            value
          };
          if (capturing) {
            groupAst.idx = this.groupIdx;
          }
          return groupAst;
        };
        RegExpParser.prototype.positiveInteger = function() {
          var number = this.popChar();
          if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.integerIncludingZero = function() {
          var number = this.popChar();
          if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.patternCharacter = function() {
          var nextChar = this.popChar();
          switch (nextChar) {
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "^":
            // istanbul ignore next
            case "$":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case ".":
            // istanbul ignore next
            case "*":
            // istanbul ignore next
            case "+":
            // istanbul ignore next
            case "?":
            // istanbul ignore next
            case "(":
            // istanbul ignore next
            case ")":
            // istanbul ignore next
            case "[":
            // istanbul ignore next
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        };
        RegExpParser.prototype.isDigit = function() {
          return decimalPattern.test(this.peekChar(0));
        };
        RegExpParser.prototype.isClassAtom = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        };
        RegExpParser.prototype.isAtom = function() {
          if (this.isPatternCharacter()) {
            return true;
          }
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            // atomEscape
            case "[":
            // characterClass
            // TODO: isAtom must be called before isAssertion - disambiguate
            case "(":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            // '\b' or '\B'
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            // '(?=' or '(?!'
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        };
        RegExpParser.prototype.isQuantifier = function() {
          var prevState = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch (e) {
            return false;
          } finally {
            this.restoreState(prevState);
          }
        };
        RegExpParser.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.parseHexDigits = function(howMany) {
          var hexString = "";
          for (var i2 = 0; i2 < howMany; i2++) {
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
              throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
          }
          var charCode = parseInt(hexString, 16);
          return { type: "Character", value: charCode };
        };
        RegExpParser.prototype.peekChar = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          return this.input[this.idx + howMuch];
        };
        RegExpParser.prototype.popChar = function() {
          var nextChar = this.peekChar(0);
          this.consumeChar();
          return nextChar;
        };
        RegExpParser.prototype.consumeChar = function(char) {
          if (char !== void 0 && this.input[this.idx] !== char) {
            throw Error(
              "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
            );
          }
          if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
          }
          this.idx++;
        };
        RegExpParser.prototype.loc = function(begin) {
          return { begin, end: this.idx };
        };
        var hexDigitPattern = /[0-9a-fA-F]/;
        var decimalPattern = /[0-9]/;
        var decimalPatternNoZero = /[1-9]/;
        function cc(char) {
          return char.charCodeAt(0);
        }
        function insertToSet(item, set) {
          if (item.length !== void 0) {
            item.forEach(function(subItem) {
              set.push(subItem);
            });
          } else {
            set.push(item);
          }
        }
        function addFlag(flagObj, flagKey) {
          if (flagObj[flagKey] === true) {
            throw "duplicate flag " + flagKey;
          }
          flagObj[flagKey] = true;
        }
        function ASSERT_EXISTS(obj) {
          if (obj === void 0) {
            throw Error("Internal Error - Should never get here!");
          }
        }
        function ASSERT_NEVER_REACH_HERE() {
          throw Error("Internal Error - Should never get here!");
        }
        var i;
        var digitsCharCodes = [];
        for (i = cc("0"); i <= cc("9"); i++) {
          digitsCharCodes.push(i);
        }
        var wordCharCodes = [cc("_")].concat(digitsCharCodes);
        for (i = cc("a"); i <= cc("z"); i++) {
          wordCharCodes.push(i);
        }
        for (i = cc("A"); i <= cc("Z"); i++) {
          wordCharCodes.push(i);
        }
        var whitespaceCodes = [
          cc(" "),
          cc("\f"),
          cc("\n"),
          cc("\r"),
          cc("	"),
          cc("\v"),
          cc("	"),
          cc("\xA0"),
          cc("\u1680"),
          cc("\u2000"),
          cc("\u2001"),
          cc("\u2002"),
          cc("\u2003"),
          cc("\u2004"),
          cc("\u2005"),
          cc("\u2006"),
          cc("\u2007"),
          cc("\u2008"),
          cc("\u2009"),
          cc("\u200A"),
          cc("\u2028"),
          cc("\u2029"),
          cc("\u202F"),
          cc("\u205F"),
          cc("\u3000"),
          cc("\uFEFF")
        ];
        function BaseRegExpVisitor() {
        }
        BaseRegExpVisitor.prototype.visitChildren = function(node) {
          for (var key in node) {
            var child = node[key];
            if (node.hasOwnProperty(key)) {
              if (child.type !== void 0) {
                this.visit(child);
              } else if (Array.isArray(child)) {
                child.forEach(function(subChild) {
                  this.visit(subChild);
                }, this);
              }
            }
          }
        };
        BaseRegExpVisitor.prototype.visit = function(node) {
          switch (node.type) {
            case "Pattern":
              this.visitPattern(node);
              break;
            case "Flags":
              this.visitFlags(node);
              break;
            case "Disjunction":
              this.visitDisjunction(node);
              break;
            case "Alternative":
              this.visitAlternative(node);
              break;
            case "StartAnchor":
              this.visitStartAnchor(node);
              break;
            case "EndAnchor":
              this.visitEndAnchor(node);
              break;
            case "WordBoundary":
              this.visitWordBoundary(node);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(node);
              break;
            case "Lookahead":
              this.visitLookahead(node);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              break;
            case "Character":
              this.visitCharacter(node);
              break;
            case "Set":
              this.visitSet(node);
              break;
            case "Group":
              this.visitGroup(node);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(node);
              break;
            case "Quantifier":
              this.visitQuantifier(node);
              break;
          }
          this.visitChildren(node);
        };
        BaseRegExpVisitor.prototype.visitPattern = function(node) {
        };
        BaseRegExpVisitor.prototype.visitFlags = function(node) {
        };
        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
        };
        BaseRegExpVisitor.prototype.visitAlternative = function(node) {
        };
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {
        };
        BaseRegExpVisitor.prototype.visitSet = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroup = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
        };
        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
        };
        return {
          RegExpParser,
          BaseRegExpVisitor,
          VERSION: "0.5.0"
        };
      }
    );
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js"(exports2, module2) {
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    module2.exports = head;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js
var require_first2 = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js"(exports2, module2) {
    module2.exports = require_head();
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js"(exports2, module2) {
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module2.exports = baseFilter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js
var require_reject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    module2.exports = reject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module2.exports = indexOf;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js"(exports2, module2) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = filter;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
var require_reg_exp_parser = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regExpAstCache = {};
    var regExpParser = new regexp_to_ast_1.RegExpParser();
    function getRegExpAst(regExp) {
      var regExpStr = regExp.toString();
      if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
      } else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
      }
    }
    exports2.getRegExpAst = getRegExpAst;
    function clearRegExpParserCache() {
      regExpAstCache = {};
    }
    exports2.clearRegExpParserCache = clearRegExpParserCache;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js
var require_reg_exp = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var isArray_1 = __importDefault(require_isArray());
    var every_1 = __importDefault(require_every());
    var forEach_1 = __importDefault(require_forEach());
    var find_1 = __importDefault(require_find());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var lexer_1 = require_lexer2();
    var complementErrorMessage = "Complement Sets are not supported for first char optimization";
    exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
      if (ensureOptimizations === void 0) {
        ensureOptimizations = false;
      }
      try {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
      } catch (e) {
        if (e.message === complementErrorMessage) {
          if (ensureOptimizations) {
            (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
          }
        } else {
          var msgSuffix = "";
          if (ensureOptimizations) {
            msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
          }
          (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
      }
      return [];
    }
    exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
    function firstCharOptimizedIndices(ast, result, ignoreCase) {
      switch (ast.type) {
        case "Disjunction":
          for (var i = 0; i < ast.value.length; i++) {
            firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
          }
          break;
        case "Alternative":
          var terms = ast.value;
          for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            switch (term.type) {
              case "EndAnchor":
              // A group back reference cannot affect potential starting char.
              // because if a back reference is the first production than automatically
              // the group being referenced has had to come BEFORE so its codes have already been added
              case "GroupBackReference":
              // assertions do not affect potential starting codes
              case "Lookahead":
              case "NegativeLookahead":
              case "StartAnchor":
              case "WordBoundary":
              case "NonWordBoundary":
                continue;
            }
            var atom = term;
            switch (atom.type) {
              case "Character":
                addOptimizedIdxToResult(atom.value, result, ignoreCase);
                break;
              case "Set":
                if (atom.complement === true) {
                  throw Error(complementErrorMessage);
                }
                (0, forEach_1.default)(atom.value, function(code) {
                  if (typeof code === "number") {
                    addOptimizedIdxToResult(code, result, ignoreCase);
                  } else {
                    var range = code;
                    if (ignoreCase === true) {
                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                    } else {
                      for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                      if (range.to >= lexer_1.minOptimizationVal) {
                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                        var maxUnOptVal = range.to;
                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                          result[currOptIdx] = currOptIdx;
                        }
                      }
                    }
                  }
                });
                break;
              case "Group":
                firstCharOptimizedIndices(atom.value, result, ignoreCase);
                break;
              /* istanbul ignore next */
              default:
                throw Error("Non Exhaustive Match");
            }
            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
            if (
              // A group may be optional due to empty contents /(?:)/
              // or if everything inside it is optional /((a)?)/
              atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
              atom.type !== "Group" && isOptionalQuantifier === false
            ) {
              break;
            }
          }
          break;
        /* istanbul ignore next */
        default:
          throw Error("non exhaustive match!");
      }
      return (0, values_1.default)(result);
    }
    exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
    function addOptimizedIdxToResult(code, result, ignoreCase) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
      result[optimizedCharIdx] = optimizedCharIdx;
      if (ignoreCase === true) {
        handleIgnoreCase(code, result);
      }
    }
    function handleIgnoreCase(code, result) {
      var char = String.fromCharCode(code);
      var upperChar = char.toUpperCase();
      if (upperChar !== char) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        }
      }
    }
    function findCode(setNode, targetCharCodes) {
      return (0, find_1.default)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") {
          return (0, includes_1.default)(targetCharCodes, codeOrRange);
        } else {
          var range_1 = codeOrRange;
          return (0, find_1.default)(targetCharCodes, function(targetCode) {
            return range_1.from <= targetCode && targetCode <= range_1.to;
          }) !== void 0;
        }
      });
    }
    function isWholeOptional(ast) {
      var quantifier = ast.quantifier;
      if (quantifier && quantifier.atLeast === 0) {
        return true;
      }
      if (!ast.value) {
        return false;
      }
      return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
    }
    var CharCodeFinder = (
      /** @class */
      (function(_super) {
        __extends(CharCodeFinder2, _super);
        function CharCodeFinder2(targetCharCodes) {
          var _this = _super.call(this) || this;
          _this.targetCharCodes = targetCharCodes;
          _this.found = false;
          return _this;
        }
        CharCodeFinder2.prototype.visitChildren = function(node) {
          if (this.found === true) {
            return;
          }
          switch (node.type) {
            case "Lookahead":
              this.visitLookahead(node);
              return;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              return;
          }
          _super.prototype.visitChildren.call(this, node);
        };
        CharCodeFinder2.prototype.visitCharacter = function(node) {
          if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
            this.found = true;
          }
        };
        CharCodeFinder2.prototype.visitSet = function(node) {
          if (node.complement) {
            if (findCode(node, this.targetCharCodes) === void 0) {
              this.found = true;
            }
          } else {
            if (findCode(node, this.targetCharCodes) !== void 0) {
              this.found = true;
            }
          }
        };
        return CharCodeFinder2;
      })(regexp_to_ast_1.BaseRegExpVisitor)
    );
    function canMatchCharCode(charCodes, pattern) {
      if (pattern instanceof RegExp) {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
      } else {
        return (0, find_1.default)(pattern, function(char) {
          return (0, includes_1.default)(charCodes, char.charCodeAt(0));
        }) !== void 0;
      }
    }
    exports2.canMatchCharCode = canMatchCharCode;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js
var require_lexer2 = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var lexer_public_1 = require_lexer_public();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var values_1 = __importDefault(require_values());
    var flatten_1 = __importDefault(require_flatten());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var indexOf_1 = __importDefault(require_indexOf());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var filter_1 = __importDefault(require_filter());
    var defaults_1 = __importDefault(require_defaults());
    var reduce_1 = __importDefault(require_reduce());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_1 = require_reg_exp();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var PATTERN = "PATTERN";
    exports2.DEFAULT_MODE = "defaultMode";
    exports2.MODES = "modes";
    exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    function disableSticky() {
      exports2.SUPPORT_STICKY = false;
    }
    exports2.disableSticky = disableSticky;
    function enableSticky() {
      exports2.SUPPORT_STICKY = true;
    }
    exports2.enableSticky = enableSticky;
    function analyzeTokenTypes(tokenTypes, options) {
      options = (0, defaults_1.default)(options, {
        useSticky: exports2.SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function(msg, action) {
          return action();
        }
      });
      var tracer = options.tracer;
      tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
      });
      var onlyRelevantTypes;
      tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
      });
      var hasCustom = false;
      var allTransformedPatterns;
      tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          var currPattern = currType[PATTERN];
          if ((0, isRegExp_1.default)(currPattern)) {
            var regExpSource = currPattern.source;
            if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
            regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
              return regExpSource;
            } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
            !(0, includes_1.default)([
              "d",
              "D",
              "s",
              "S",
              "t",
              "r",
              "n",
              "t",
              "0",
              "c",
              "b",
              "B",
              "f",
              "v",
              "w",
              "W"
            ], regExpSource[1])) {
              return regExpSource[1];
            } else {
              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            }
          } else if ((0, isFunction_1.default)(currPattern)) {
            hasCustom = true;
            return { exec: currPattern };
          } else if (typeof currPattern === "object") {
            hasCustom = true;
            return currPattern;
          } else if (typeof currPattern === "string") {
            if (currPattern.length === 1) {
              return currPattern;
            } else {
              var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
              var wrappedRegExp = new RegExp(escapedRegExpString);
              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
            }
          } else {
            throw Error("non exhaustive match");
          }
        });
      });
      var patternIdxToType;
      var patternIdxToGroup;
      var patternIdxToLongerAltIdxArr;
      var patternIdxToPushMode;
      var patternIdxToPopMode;
      tracer("misc mapping", function() {
        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var groupName = clazz.GROUP;
          if (groupName === lexer_public_1.Lexer.SKIPPED) {
            return void 0;
          } else if ((0, isString_1.default)(groupName)) {
            return groupName;
          } else if ((0, isUndefined_1.default)(groupName)) {
            return false;
          } else {
            throw Error("non exhaustive match");
          }
        });
        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var longerAltType = clazz.LONGER_ALT;
          if (longerAltType) {
            var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
              return (0, indexOf_1.default)(onlyRelevantTypes, type);
            }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
            return longerAltIdxArr;
          }
        });
        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return (0, has_1.default)(clazz, "POP_MODE");
        });
      });
      var patternIdxToCanLineTerminator;
      tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
          return false;
        });
        if (options.positionTracking !== "onlyOffset") {
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              return !!tokType.LINE_BREAKS;
            } else {
              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
          });
        }
      });
      var patternIdxToIsCustom;
      var patternIdxToShort;
      var emptyGroups;
      var patternIdxToConfig;
      tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
          var groupName = clazz.GROUP;
          if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
            acc[groupName] = [];
          }
          return acc;
        }, {});
        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
          return {
            pattern: allTransformedPatterns[idx],
            longerAlt: patternIdxToLongerAltIdxArr[idx],
            canLineTerminator: patternIdxToCanLineTerminator[idx],
            isCustom: patternIdxToIsCustom[idx],
            short: patternIdxToShort[idx],
            group: patternIdxToGroup[idx],
            push: patternIdxToPushMode[idx],
            pop: patternIdxToPopMode[idx],
            tokenTypeIdx: patternIdxToType[idx],
            tokenType: onlyRelevantTypes[idx]
          };
        });
      });
      var canBeOptimized = true;
      var charCodeToPatternIdxToConfig = [];
      if (!options.safeMode) {
        tracer("First Char Optimization", function() {
          charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
              var charCode = currTokType.PATTERN.charCodeAt(0);
              var optimizedIdx = charCodeToOptimizedIndex(charCode);
              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
              var lastOptimizedIdx_1;
              (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                  lastOptimizedIdx_1 = currOptimizedIdx;
                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                }
              });
            } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
              if (currTokType.PATTERN.unicode) {
                canBeOptimized = false;
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                }
              } else {
                var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                if ((0, isEmpty_1.default)(optimizedCodes)) {
                  canBeOptimized = false;
                }
                (0, forEach_1.default)(optimizedCodes, function(code) {
                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                });
              }
            } else {
              if (options.ensureOptimizations) {
                (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
              }
              canBeOptimized = false;
            }
            return result;
          }, []);
        });
      }
      return {
        emptyGroups,
        patternIdxToConfig,
        charCodeToPatternIdxToConfig,
        hasCustom,
        canBeOptimized
      };
    }
    exports2.analyzeTokenTypes = analyzeTokenTypes;
    function validatePatterns(tokenTypes, validModesNames) {
      var errors = [];
      var missingResult = findMissingPatterns(tokenTypes);
      errors = errors.concat(missingResult.errors);
      var invalidResult = findInvalidPatterns(missingResult.valid);
      var validTokenTypes = invalidResult.valid;
      errors = errors.concat(invalidResult.errors);
      errors = errors.concat(validateRegExpPattern(validTokenTypes));
      errors = errors.concat(findInvalidGroupType(validTokenTypes));
      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
      errors = errors.concat(findUnreachablePatterns(validTokenTypes));
      return errors;
    }
    exports2.validatePatterns = validatePatterns;
    function validateRegExpPattern(tokenTypes) {
      var errors = [];
      var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
        return (0, isRegExp_1.default)(currTokType[PATTERN]);
      });
      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
      return errors;
    }
    function findMissingPatterns(tokenTypes) {
      var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        return !(0, has_1.default)(currType, PATTERN);
      });
      var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
          type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid2 = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
      return { errors, valid: valid2 };
    }
    exports2.findMissingPatterns = findMissingPatterns;
    function findInvalidPatterns(tokenTypes) {
      var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
      });
      var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid2 = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
      return { errors, valid: valid2 };
    }
    exports2.findInvalidPatterns = findInvalidPatterns;
    var end_of_input = /[^\\][$]/;
    function findEndOfInputAnchor(tokenTypes) {
      var EndAnchorFinder = (
        /** @class */
        (function(_super) {
          __extends(EndAnchorFinder2, _super);
          function EndAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
            this.found = true;
          };
          return EndAnchorFinder2;
        })(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var endAnchorVisitor = new EndAnchorFinder();
          endAnchorVisitor.visit(regexpAst);
          return endAnchorVisitor.found;
        } catch (e) {
          return end_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEndOfInputAnchor = findEndOfInputAnchor;
    function findEmptyMatchRegExps(tokenTypes) {
      var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        return pattern.test("");
      });
      var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
          type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
    var start_of_input = /[^\\[][\^]|^\^/;
    function findStartOfInputAnchor(tokenTypes) {
      var StartAnchorFinder = (
        /** @class */
        (function(_super) {
          __extends(StartAnchorFinder2, _super);
          function StartAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
            this.found = true;
          };
          return StartAnchorFinder2;
        })(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var startAnchorVisitor = new StartAnchorFinder();
          startAnchorVisitor.visit(regexpAst);
          return startAnchorVisitor.found;
        } catch (e) {
          return start_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findStartOfInputAnchor = findStartOfInputAnchor;
    function findUnsupportedFlags(tokenTypes) {
      var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
      });
      var errors = (0, map_1.default)(invalidFlags, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
          type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findUnsupportedFlags = findUnsupportedFlags;
    function findDuplicatePatterns(tokenTypes) {
      var found = [];
      var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
        return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
          if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
            found.push(innerType);
            result.push(innerType);
            return result;
          }
          return result;
        }, []);
      });
      identicalPatterns = (0, compact_1.default)(identicalPatterns);
      var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
      });
      var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
          return currType.name;
        });
        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
        return {
          message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
          type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
          tokenTypes: setOfIdentical
        };
      });
      return errors;
    }
    exports2.findDuplicatePatterns = findDuplicatePatterns;
    function findInvalidGroupType(tokenTypes) {
      var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
        if (!(0, has_1.default)(clazz, "GROUP")) {
          return false;
        }
        var group = clazz.GROUP;
        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
      });
      var errors = (0, map_1.default)(invalidTypes, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findInvalidGroupType = findInvalidGroupType;
    function findModesThatDoNotExist(tokenTypes, validModes) {
      var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
      });
      var errors = (0, map_1.default)(invalidModes, function(tokType) {
        var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
        return {
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
          tokenTypes: [tokType]
        };
      });
      return errors;
    }
    exports2.findModesThatDoNotExist = findModesThatDoNotExist;
    function findUnreachablePatterns(tokenTypes) {
      var errors = [];
      var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === lexer_public_1.Lexer.NA) {
          return result;
        }
        if ((0, isString_1.default)(pattern)) {
          result.push({ str: pattern, idx, tokenType: tokType });
        } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
          result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
      }, []);
      (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
        (0, forEach_1.default)(canBeTested, function(_a) {
          var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
            var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
            errors.push({
              message: msg,
              type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
              tokenTypes: [tokType, tokenType]
            });
          }
        });
      });
      return errors;
    }
    exports2.findUnreachablePatterns = findUnreachablePatterns;
    function testTokenType(str, pattern) {
      if ((0, isRegExp_1.default)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
      } else if ((0, isFunction_1.default)(pattern)) {
        return pattern(str, 0, [], {});
      } else if ((0, has_1.default)(pattern, "exec")) {
        return pattern.exec(str, 0, [], {});
      } else if (typeof pattern === "string") {
        return pattern === str;
      } else {
        throw Error("non exhaustive match");
      }
    }
    function noMetaChar(regExp) {
      var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
      ];
      return (0, find_1.default)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
      }) === void 0;
    }
    function addStartOfInput(pattern) {
      var flags = pattern.ignoreCase ? "i" : "";
      return new RegExp("^(?:".concat(pattern.source, ")"), flags);
    }
    exports2.addStartOfInput = addStartOfInput;
    function addStickyFlag(pattern) {
      var flags = pattern.ignoreCase ? "iy" : "y";
      return new RegExp("".concat(pattern.source), flags);
    }
    exports2.addStickyFlag = addStickyFlag;
    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var errors = [];
      if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
      }
      if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
        (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
          (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
            if ((0, isUndefined_1.default)(currTokType)) {
              errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
              });
            } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
              var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
              (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                  errors.push({
                    message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                    type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                  });
                }
              });
            }
          });
        });
      }
      return errors;
    }
    exports2.performRuntimeChecks = performRuntimeChecks;
    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var warnings = [];
      var hasAnyLineBreak = false;
      var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
      var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
        return currType[PATTERN] === lexer_public_1.Lexer.NA;
      });
      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
      if (trackLines) {
        (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
          if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
              message,
              type: currIssue.issue,
              tokenType: tokType
            };
            warnings.push(warningDescriptor);
          } else {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              if (tokType.LINE_BREAKS === true) {
                hasAnyLineBreak = true;
              }
            } else {
              if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                hasAnyLineBreak = true;
              }
            }
          }
        });
      }
      if (trackLines && !hasAnyLineBreak) {
        warnings.push({
          message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
      }
      return warnings;
    }
    exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
    function cloneEmptyGroups(emptyGroups) {
      var clonedResult = {};
      var groupKeys = (0, keys_1.default)(emptyGroups);
      (0, forEach_1.default)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        if ((0, isArray_1.default)(currGroupValue)) {
          clonedResult[currKey] = [];
        } else {
          throw Error("non exhaustive match");
        }
      });
      return clonedResult;
    }
    exports2.cloneEmptyGroups = cloneEmptyGroups;
    function isCustomPattern(tokenType) {
      var pattern = tokenType.PATTERN;
      if ((0, isRegExp_1.default)(pattern)) {
        return false;
      } else if ((0, isFunction_1.default)(pattern)) {
        return true;
      } else if ((0, has_1.default)(pattern, "exec")) {
        return true;
      } else if ((0, isString_1.default)(pattern)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.isCustomPattern = isCustomPattern;
    function isShortPattern(pattern) {
      if ((0, isString_1.default)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
      } else {
        return false;
      }
    }
    exports2.isShortPattern = isShortPattern;
    exports2.LineTerminatorOptimizedTester = {
      // implements /\n|\r\n?/g.test
      test: function(text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
          var c = text.charCodeAt(i);
          if (c === 10) {
            this.lastIndex = i + 1;
            return true;
          } else if (c === 13) {
            if (text.charCodeAt(i + 1) === 10) {
              this.lastIndex = i + 2;
            } else {
              this.lastIndex = i + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
      if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
        return false;
      } else {
        if ((0, isRegExp_1.default)(tokType.PATTERN)) {
          try {
            (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
          } catch (e) {
            return {
              issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
              errMsg: e.message
            };
          }
          return false;
        } else if ((0, isString_1.default)(tokType.PATTERN)) {
          return false;
        } else if (isCustomPattern(tokType)) {
          return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        } else {
          throw Error("non exhaustive match");
        }
      }
    }
    function buildLineBreakIssueMessage(tokType, details) {
      if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
    function getCharCodes(charsOrCodes) {
      var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
        if ((0, isString_1.default)(numOrString)) {
          return numOrString.charCodeAt(0);
        } else {
          return numOrString;
        }
      });
      return charCodes;
    }
    function addToMapOfArrays(map3, key, value) {
      if (map3[key] === void 0) {
        map3[key] = [value];
      } else {
        map3[key].push(value);
      }
    }
    exports2.minOptimizationVal = 256;
    var charCodeToOptimizedIdxMap = [];
    function charCodeToOptimizedIndex(charCode) {
      return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
    }
    exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
    function initCharCodeToOptimizedIndexMap() {
      if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
          charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
        }
      }
    }
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js
var require_tokens = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    function tokenStructuredMatcher(tokInstance, tokConstructor) {
      var instanceType = tokInstance.tokenTypeIdx;
      if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
      } else {
        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
      }
    }
    exports2.tokenStructuredMatcher = tokenStructuredMatcher;
    function tokenStructuredMatcherNoCategories(token, tokType) {
      return token.tokenTypeIdx === tokType.tokenTypeIdx;
    }
    exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
    exports2.tokenShortNameIdx = 1;
    exports2.tokenIdxToClass = {};
    function augmentTokenTypes(tokenTypes) {
      var tokenTypesAndParents = expandCategories(tokenTypes);
      assignTokenDefaultProps(tokenTypesAndParents);
      assignCategoriesMapProp(tokenTypesAndParents);
      assignCategoriesTokensProp(tokenTypesAndParents);
      (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
      });
    }
    exports2.augmentTokenTypes = augmentTokenTypes;
    function expandCategories(tokenTypes) {
      var result = (0, clone_1.default)(tokenTypes);
      var categories = tokenTypes;
      var searching = true;
      while (searching) {
        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
          return currTokType.CATEGORIES;
        })));
        var newCategories = (0, difference_1.default)(categories, result);
        result = result.concat(newCategories);
        if ((0, isEmpty_1.default)(newCategories)) {
          searching = false;
        } else {
          categories = newCategories;
        }
      }
      return result;
    }
    exports2.expandCategories = expandCategories;
    function assignTokenDefaultProps(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
          exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
          currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
        }
        if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
          currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
          currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
          currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
          currTokType.categoryMatchesMap = {};
        }
      });
    }
    exports2.assignTokenDefaultProps = assignTokenDefaultProps;
    function assignCategoriesTokensProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        currTokType.categoryMatches = [];
        (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
          currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
        });
      });
    }
    exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
    function assignCategoriesMapProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
      });
    }
    exports2.assignCategoriesMapProp = assignCategoriesMapProp;
    function singleAssignCategoriesToksMap(path, nextNode) {
      (0, forEach_1.default)(path, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
      });
      (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path.concat(nextNode);
        if (!(0, includes_1.default)(newPath, nextCategory)) {
          singleAssignCategoriesToksMap(newPath, nextCategory);
        }
      });
    }
    exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
    function hasShortKeyProperty(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.hasShortKeyProperty = hasShortKeyProperty;
    function hasCategoriesProperty(tokType) {
      return (0, has_1.default)(tokType, "CATEGORIES");
    }
    exports2.hasCategoriesProperty = hasCategoriesProperty;
    function hasExtendingTokensTypesProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatches");
    }
    exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
    function hasExtendingTokensTypesMapProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatchesMap");
    }
    exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
    function isTokenType(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.isTokenType = isTokenType;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var require_lexer_errors_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLexerErrorProvider = void 0;
    exports2.defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
      },
      buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
        return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
      }
    };
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js
var require_lexer_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
    var lexer_1 = require_lexer2();
    var noop_1 = __importDefault(require_noop());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var last_1 = __importDefault(require_last());
    var reject_1 = __importDefault(require_reject());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var identity_1 = __importDefault(require_identity2());
    var assign_1 = __importDefault(require_assign());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var tokens_1 = require_tokens();
    var lexer_errors_public_1 = require_lexer_errors_public();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var LexerDefinitionErrorType2;
    (function(LexerDefinitionErrorType3) {
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType2 = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
    var DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    var Lexer2 = (
      /** @class */
      (function() {
        function Lexer3(lexerDefinition, config) {
          if (config === void 0) {
            config = DEFAULT_LEXER_CONFIG;
          }
          var _this = this;
          this.lexerDefinition = lexerDefinition;
          this.lexerDefinitionErrors = [];
          this.lexerDefinitionWarning = [];
          this.patternIdxToConfig = {};
          this.charCodeToPatternIdxToConfig = {};
          this.modes = [];
          this.emptyGroups = {};
          this.trackStartLines = true;
          this.trackEndLines = true;
          this.hasCustom = false;
          this.canModeBeOptimized = {};
          this.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (_this.traceInitPerf === true) {
              _this.traceInitIndent++;
              var indent2 = new Array(_this.traceInitIndent + 1).join("	");
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                console.log("".concat(indent2, "--> <").concat(phaseDesc, ">"));
              }
              var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                traceMethod("".concat(indent2, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              _this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
          }
          this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);
          var traceInitVal = this.config.traceInitPerf;
          if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
          } else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
          }
          this.traceInitIndent = -1;
          this.TRACE_INIT("Lexer Constructor", function() {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function() {
              if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
              } else {
                if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                  throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                }
              }
              if (config.safeMode && config.ensureOptimizations) {
                throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
              }
              _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
              _this.trackEndLines = /full/i.test(_this.config.positionTracking);
              if ((0, isArray_1.default)(lexerDefinition)) {
                actualDefinition = {
                  modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                  defaultMode: lexer_1.DEFAULT_MODE
                };
              } else {
                hasOnlySingleMode = false;
                actualDefinition = (0, clone_1.default)(lexerDefinition);
              }
            });
            if (_this.config.skipValidations === false) {
              _this.TRACE_INIT("performRuntimeChecks", function() {
                _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
              _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
            }
            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
            (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
              actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                return (0, isUndefined_1.default)(currTokType);
              });
            });
            var allModeNames = (0, keys_1.default)(actualDefinition.modes);
            (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
              _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                _this.modes.push(currModName);
                if (_this.config.skipValidations === false) {
                  _this.TRACE_INIT("validatePatterns", function() {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                  });
                }
                if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                  (0, tokens_1.augmentTokenTypes)(currModDef);
                  var currAnalyzeResult_1;
                  _this.TRACE_INIT("analyzeTokenTypes", function() {
                    currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                      lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                      positionTracking: config.positionTracking,
                      ensureOptimizations: config.ensureOptimizations,
                      safeMode: config.safeMode,
                      tracer: _this.TRACE_INIT
                    });
                  });
                  _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                  _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                  _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                  _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                  _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                }
              });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
              var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
              (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function() {
              if (lexer_1.SUPPORT_STICKY) {
                _this.chopInput = identity_1.default;
                _this.match = _this.matchWithTest;
              } else {
                _this.updateLastIndex = noop_1.default;
                _this.match = _this.matchWithExec;
              }
              if (hasOnlySingleMode) {
                _this.handleModes = noop_1.default;
              }
              if (_this.trackStartLines === false) {
                _this.computeNewColumn = identity_1.default;
              }
              if (_this.trackEndLines === false) {
                _this.updateTokenEndLineColumnLocation = noop_1.default;
              }
              if (/full/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createFullToken;
              } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createStartOnlyToken;
              } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createOffsetOnlyToken;
              } else {
                throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
              }
              if (_this.hasCustom) {
                _this.addToken = _this.addTokenUsingPush;
                _this.handlePayload = _this.handlePayloadWithCustom;
              } else {
                _this.addToken = _this.addTokenUsingMemberAccess;
                _this.handlePayload = _this.handlePayloadNoCustom;
              }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function() {
              var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                if (canBeOptimized === false) {
                  cannotBeOptimized.push(modeName);
                }
                return cannotBeOptimized;
              }, []);
              if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
              }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function() {
              (0, reg_exp_parser_1.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function() {
              (0, utils_1.toFastProperties)(_this);
            });
          });
        }
        Lexer3.prototype.tokenize = function(text, initialMode) {
          if (initialMode === void 0) {
            initialMode = this.defaultMode;
          }
          if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
              return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          return this.tokenizeInternal(text, initialMode);
        };
        Lexer3.prototype.tokenizeInternal = function(text, initialMode) {
          var _this = this;
          var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
          var orgText = text;
          var orgLength = orgText.length;
          var offset = 0;
          var matchedTokensIndex = 0;
          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
          var matchedTokens = new Array(guessedNumberOfTokens);
          var errors = [];
          var line = this.trackStartLines ? 1 : void 0;
          var column = this.trackStartLines ? 1 : void 0;
          var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
          var trackLines = this.trackStartLines;
          var lineTerminatorPattern = this.config.lineTerminatorsPattern;
          var currModePatternsLength = 0;
          var patternIdxToConfig = [];
          var currCharCodeToPatternIdxToConfig = [];
          var modeStack = [];
          var emptyArray = [];
          Object.freeze(emptyArray);
          var getPossiblePatterns;
          function getPossiblePatternsSlow() {
            return patternIdxToConfig;
          }
          function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === void 0) {
              return emptyArray;
            } else {
              return possiblePatterns;
            }
          }
          var pop_mode = function(popToken) {
            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
            // So no error should occur.
            popToken.tokenType.PUSH_MODE === void 0) {
              var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
              errors.push({
                offset: popToken.startOffset,
                line: popToken.startLine,
                column: popToken.startColumn,
                length: popToken.image.length,
                message: msg_1
              });
            } else {
              modeStack.pop();
              var newMode = (0, last_1.default)(modeStack);
              patternIdxToConfig = _this.patternIdxToConfig[newMode];
              currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
          };
          function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
          push_mode.call(this, initialMode);
          var currConfig;
          var recoveryEnabled = this.config.recoveryEnabled;
          while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
              currConfig = chosenPatternIdxToConfig[i];
              var currPattern = currConfig.pattern;
              payload = null;
              var singleCharCode = currConfig.short;
              if (singleCharCode !== false) {
                if (nextCharCode === singleCharCode) {
                  matchedImage = currPattern;
                }
              } else if (currConfig.isCustom === true) {
                match = currPattern.exec(orgText, offset, matchedTokens, groups);
                if (match !== null) {
                  matchedImage = match[0];
                  if (match.payload !== void 0) {
                    payload = match.payload;
                  }
                } else {
                  matchedImage = null;
                }
              } else {
                this.updateLastIndex(currPattern, offset);
                matchedImage = this.match(currPattern, text, offset);
              }
              if (matchedImage !== null) {
                longerAlt = currConfig.longerAlt;
                if (longerAlt !== void 0) {
                  var longerAltLength = longerAlt.length;
                  for (k = 0; k < longerAltLength; k++) {
                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                    var longerAltPattern = longerAltConfig.pattern;
                    altPayload = null;
                    if (longerAltConfig.isCustom === true) {
                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                      if (match !== null) {
                        matchAltImage = match[0];
                        if (match.payload !== void 0) {
                          altPayload = match.payload;
                        }
                      } else {
                        matchAltImage = null;
                      }
                    } else {
                      this.updateLastIndex(longerAltPattern, offset);
                      matchAltImage = this.match(longerAltPattern, text, offset);
                    }
                    if (matchAltImage && matchAltImage.length > matchedImage.length) {
                      matchedImage = matchAltImage;
                      payload = altPayload;
                      currConfig = longerAltConfig;
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (matchedImage !== null) {
              imageLength = matchedImage.length;
              group = currConfig.group;
              if (group !== void 0) {
                tokType = currConfig.tokenTypeIdx;
                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                this.handlePayload(newToken, payload);
                if (group === false) {
                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                } else {
                  groups[group].push(newToken);
                }
              }
              text = this.chopInput(text, imageLength);
              offset = offset + imageLength;
              column = this.computeNewColumn(column, imageLength);
              if (trackLines === true && currConfig.canLineTerminator === true) {
                var numOfLTsInMatch = 0;
                var foundTerminator = void 0;
                var lastLTEndOffset = void 0;
                lineTerminatorPattern.lastIndex = 0;
                do {
                  foundTerminator = lineTerminatorPattern.test(matchedImage);
                  if (foundTerminator === true) {
                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                    numOfLTsInMatch++;
                  }
                } while (foundTerminator === true);
                if (numOfLTsInMatch !== 0) {
                  line = line + numOfLTsInMatch;
                  column = imageLength - lastLTEndOffset;
                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                }
              }
              this.handleModes(currConfig, pop_mode, push_mode, newToken);
            } else {
              var errorStartOffset = offset;
              var errorLine = line;
              var errorColumn = column;
              var foundResyncPoint = recoveryEnabled === false;
              while (foundResyncPoint === false && offset < orgLength) {
                text = this.chopInput(text, 1);
                offset++;
                for (j = 0; j < currModePatternsLength; j++) {
                  var currConfig_1 = patternIdxToConfig[j];
                  var currPattern = currConfig_1.pattern;
                  var singleCharCode = currConfig_1.short;
                  if (singleCharCode !== false) {
                    if (orgText.charCodeAt(offset) === singleCharCode) {
                      foundResyncPoint = true;
                    }
                  } else if (currConfig_1.isCustom === true) {
                    foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                  } else {
                    this.updateLastIndex(currPattern, offset);
                    foundResyncPoint = currPattern.exec(text) !== null;
                  }
                  if (foundResyncPoint === true) {
                    break;
                  }
                }
              }
              errLength = offset - errorStartOffset;
              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
              errors.push({
                offset: errorStartOffset,
                line: errorLine,
                column: errorColumn,
                length: errLength,
                message: msg
              });
              if (recoveryEnabled === false) {
                break;
              }
            }
          }
          if (!this.hasCustom) {
            matchedTokens.length = matchedTokensIndex;
          }
          return {
            tokens: matchedTokens,
            groups,
            errors
          };
        };
        Lexer3.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
          if (config.pop === true) {
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== void 0) {
              push_mode.call(this, pushMode);
            }
          } else if (config.push !== void 0) {
            push_mode.call(this, config.push);
          }
        };
        Lexer3.prototype.chopInput = function(text, length) {
          return text.substring(length);
        };
        Lexer3.prototype.updateLastIndex = function(regExp, newLastIndex) {
          regExp.lastIndex = newLastIndex;
        };
        Lexer3.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
          var lastCharIsLT, fixForEndingInLT;
          if (group !== void 0) {
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
              newToken.endLine = line + fixForEndingInLT;
              newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
          }
        };
        Lexer3.prototype.computeNewColumn = function(oldColumn, imageLength) {
          return oldColumn + imageLength;
        };
        Lexer3.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
          return {
            image,
            startOffset,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
          return {
            image,
            startOffset,
            startLine,
            startColumn,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
          return {
            image,
            startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine,
            endLine: startLine,
            startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
          tokenVector.push(tokenToAdd);
          return index;
        };
        Lexer3.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
          tokenVector[index] = tokenToAdd;
          index++;
          return index;
        };
        Lexer3.prototype.handlePayloadNoCustom = function(token, payload) {
        };
        Lexer3.prototype.handlePayloadWithCustom = function(token, payload) {
          if (payload !== null) {
            token.payload = payload;
          }
        };
        Lexer3.prototype.matchWithTest = function(pattern, text, offset) {
          var found = pattern.test(text);
          if (found === true) {
            return text.substring(offset, pattern.lastIndex);
          }
          return null;
        };
        Lexer3.prototype.matchWithExec = function(pattern, text) {
          var regExpArray = pattern.exec(text);
          return regExpArray !== null ? regExpArray[0] : null;
        };
        Lexer3.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
        Lexer3.NA = /NOT_APPLICABLE/;
        return Lexer3;
      })()
    );
    exports2.Lexer = Lexer2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js
var require_tokens_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
    var isString_1 = __importDefault(require_isString());
    var has_1 = __importDefault(require_has());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    exports2.tokenLabel = tokenLabel2;
    function tokenName2(tokType) {
      return tokType.name;
    }
    exports2.tokenName = tokenName2;
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    exports2.hasTokenLabel = hasTokenLabel;
    var PARENT = "parent";
    var CATEGORIES = "categories";
    var LABEL = "label";
    var GROUP = "group";
    var PUSH_MODE = "push_mode";
    var POP_MODE = "pop_mode";
    var LONGER_ALT = "longer_alt";
    var LINE_BREAKS = "line_breaks";
    var START_CHARS_HINT = "start_chars_hint";
    function createToken2(config) {
      return createTokenInternal(config);
    }
    exports2.createToken = createToken2;
    function createTokenInternal(config) {
      var pattern = config.pattern;
      var tokenType = {};
      tokenType.name = config.name;
      if (!(0, isUndefined_1.default)(pattern)) {
        tokenType.PATTERN = pattern;
      }
      if ((0, has_1.default)(config, PARENT)) {
        throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      if ((0, has_1.default)(config, CATEGORIES)) {
        tokenType.CATEGORIES = config[CATEGORIES];
      }
      (0, tokens_1.augmentTokenTypes)([tokenType]);
      if ((0, has_1.default)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
      }
      if ((0, has_1.default)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
      }
      if ((0, has_1.default)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
      }
      if ((0, has_1.default)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
      }
      if ((0, has_1.default)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
      }
      if ((0, has_1.default)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
      }
      if ((0, has_1.default)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
      }
      return tokenType;
    }
    exports2.EOF = createToken2({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
    function createTokenInstance2(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
      return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
      };
    }
    exports2.createTokenInstance = createTokenInstance2;
    function tokenMatcher2(token, tokType) {
      return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
    }
    exports2.tokenMatcher = tokenMatcher2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js
var require_errors_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
    var tokens_public_1 = require_tokens_public();
    var first_1 = __importDefault(require_first2());
    var map_1 = __importDefault(require_map2());
    var reduce_1 = __importDefault(require_reduce());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    exports2.defaultParserErrorProvider = {
      buildMismatchTokenMessage: function(_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
        var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
        return msg;
      },
      buildNotAllInputParsedMessage: function(_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage: function(_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
            return result.concat(currAltPaths);
          }, []);
          var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(", "), "]");
          });
          var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
            return "  ".concat(idx + 1, ". ").concat(itemMsg);
          });
          var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage: function(_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(","), "]");
          });
          var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(exports2.defaultParserErrorProvider);
    exports2.defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    exports2.defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
          if (prod instanceof gast_1.Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof gast_1.NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, first_1.default)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
          return (0, tokens_public_1.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        return errMsg;
      },
      buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
          return (0, tokens_public_1.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
        return currMessage;
      },
      buildEmptyRepetitionError: function(options) {
        var dslName = (0, gast_2.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildTokenNameError: function(options) {
        return "deprecated";
      },
      buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
      },
      buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
        return errMsg;
      },
      buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
          return currRule.name;
        });
        var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
        var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildInvalidRuleNameError: function(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof gast_1.Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
        return errMsg;
      }
    };
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js
var require_resolver = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
    var parser_1 = require_parser2();
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var gast_1 = require_api2();
    function resolveGrammar(topLevels, errMsgProvider) {
      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
      refResolver.resolveRefs();
      return refResolver.errors;
    }
    exports2.resolveGrammar = resolveGrammar;
    var GastRefResolverVisitor = (
      /** @class */
      (function(_super) {
        __extends(GastRefResolverVisitor2, _super);
        function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
          var _this = _super.call(this) || this;
          _this.nameToTopRule = nameToTopRule;
          _this.errMsgProvider = errMsgProvider;
          _this.errors = [];
          return _this;
        }
        GastRefResolverVisitor2.prototype.resolveRefs = function() {
          var _this = this;
          (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
          });
        };
        GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
          var ref = this.nameToTopRule[node.nonTerminalName];
          if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
              message: msg,
              type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: node.nonTerminalName
            });
          } else {
            node.referencedRule = ref;
          }
        };
        return GastRefResolverVisitor2;
      })(gast_1.GAstVisitor)
    );
    exports2.GastRefResolverVisitor = GastRefResolverVisitor;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js"(exports2, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module2.exports = groupBy;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var map3 = require_map2();
    function flatMap(collection, iteratee) {
      return baseFlatten(map3(collection, iteratee), 1);
    }
    module2.exports = flatMap;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js
var require_dropRight = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module2.exports = dropRight;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var drop_1 = __importDefault(require_drop());
    var last_1 = __importDefault(require_last());
    var forEach_1 = __importDefault(require_forEach());
    var clone_1 = __importDefault(require_clone());
    var first_2 = require_first();
    var gast_1 = require_api2();
    var AbstractNextPossibleTokensWalker = (
      /** @class */
      (function(_super) {
        __extends(AbstractNextPossibleTokensWalker2, _super);
        function AbstractNextPossibleTokensWalker2(topProd, path) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.path = path;
          _this.possibleTokTypes = [];
          _this.nextProductionName = "";
          _this.nextProductionOccurrence = 0;
          _this.found = false;
          _this.isAtEndOfPath = false;
          return _this;
        }
        AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
          this.found = false;
          if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
          }
          this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
          this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
          this.ruleStack.pop();
          this.occurrenceStack.pop();
          this.updateExpectedNext();
          this.walk(this.topProd);
          return this.possibleTokTypes;
        };
        AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
          if (prevRest === void 0) {
            prevRest = [];
          }
          if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
          if ((0, isEmpty_1.default)(this.ruleStack)) {
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
          } else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
          }
        };
        return AbstractNextPossibleTokensWalker2;
      })(rest_1.RestWalker)
    );
    exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
    var NextAfterTokenWalker = (
      /** @class */
      (function(_super) {
        __extends(NextAfterTokenWalker2, _super);
        function NextAfterTokenWalker2(topProd, path) {
          var _this = _super.call(this, topProd, path) || this;
          _this.path = path;
          _this.nextTerminalName = "";
          _this.nextTerminalOccurrence = 0;
          _this.nextTerminalName = _this.path.lastTok.name;
          _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
          return _this;
        }
        NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            this.possibleTokTypes = (0, first_2.first)(restProd);
            this.found = true;
          }
        };
        return NextAfterTokenWalker2;
      })(AbstractNextPossibleTokensWalker)
    );
    exports2.NextAfterTokenWalker = NextAfterTokenWalker;
    var AbstractNextTerminalAfterProductionWalker = (
      /** @class */
      (function(_super) {
        __extends(AbstractNextTerminalAfterProductionWalker2, _super);
        function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
          var _this = _super.call(this) || this;
          _this.topRule = topRule;
          _this.occurrence = occurrence;
          _this.result = {
            token: void 0,
            occurrence: void 0,
            isEndOfRule: void 0
          };
          return _this;
        }
        AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
          this.walk(this.topRule);
          return this.result;
        };
        return AbstractNextTerminalAfterProductionWalker2;
      })(rest_1.RestWalker)
    );
    exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
    var NextTerminalAfterManyWalker = (
      /** @class */
      (function(_super) {
        __extends(NextTerminalAfterManyWalker2, _super);
        function NextTerminalAfterManyWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === void 0;
            if (firstAfterMany instanceof gast_1.Terminal) {
              this.result.token = firstAfterMany.terminalType;
              this.result.occurrence = firstAfterMany.idx;
            }
          } else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManyWalker2;
      })(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
    var NextTerminalAfterManySepWalker = (
      /** @class */
      (function(_super) {
        __extends(NextTerminalAfterManySepWalker2, _super);
        function NextTerminalAfterManySepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === void 0;
            if (firstAfterManySep instanceof gast_1.Terminal) {
              this.result.token = firstAfterManySep.terminalType;
              this.result.occurrence = firstAfterManySep.idx;
            }
          } else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManySepWalker2;
      })(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
    var NextTerminalAfterAtLeastOneWalker = (
      /** @class */
      (function(_super) {
        __extends(NextTerminalAfterAtLeastOneWalker2, _super);
        function NextTerminalAfterAtLeastOneWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
            if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
              this.result.token = firstAfterAtLeastOne.terminalType;
              this.result.occurrence = firstAfterAtLeastOne.idx;
            }
          } else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneWalker2;
      })(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
    var NextTerminalAfterAtLeastOneSepWalker = (
      /** @class */
      (function(_super) {
        __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
        function NextTerminalAfterAtLeastOneSepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
          if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
          } else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneSepWalker2;
      })(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
    function possiblePathsFrom(targetDef, maxLength, currPath) {
      if (currPath === void 0) {
        currPath = [];
      }
      currPath = (0, clone_1.default)(currPath);
      var result = [];
      var i = 0;
      function remainingPathWith(nextDef) {
        return nextDef.concat((0, drop_1.default)(targetDef, i + 1));
      }
      function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
      }
      while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        if (prod instanceof gast_1.Alternative) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.NonTerminal) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.Option) {
          result = getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var newDef = [
            new gast_1.Alternative({ definition: prod.definition }),
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ];
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Repetition) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Alternation) {
          (0, forEach_1.default)(prod.definition, function(currAlt) {
            if ((0, isEmpty_1.default)(currAlt.definition) === false) {
              result = getAlternativesForProd(currAlt.definition);
            }
          });
          return result;
        } else if (prod instanceof gast_1.Terminal) {
          currPath.push(prod.terminalType);
        } else {
          throw Error("non exhaustive match");
        }
        i++;
      }
      result.push({
        partialPath: currPath,
        suffixDef: (0, drop_1.default)(targetDef, i)
      });
      return result;
    }
    exports2.possiblePathsFrom = possiblePathsFrom;
    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
      var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
      var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
      var foundCompletePath = false;
      var tokenVectorLength = tokenVector.length;
      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
      var result = [];
      var possiblePaths = [];
      possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
      });
      while (!(0, isEmpty_1.default)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        if (currPath === EXIT_ALTERNATIVE) {
          if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
            possiblePaths.pop();
          }
          continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        if ((0, isEmpty_1.default)(currDef)) {
          continue;
        }
        var prod = currDef[0];
        if (prod === EXIT_NON_TERMINAL) {
          var nextPath = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: (0, dropRight_1.default)(currRuleStack),
            occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Terminal) {
          if (currIdx < tokenVectorLength - 1) {
            var nextIdx = currIdx + 1;
            var actualToken = tokenVector[nextIdx];
            if (tokMatcher(actualToken, prod.terminalType)) {
              var nextPath = {
                idx: nextIdx,
                def: (0, drop_1.default)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(nextPath);
            }
          } else if (currIdx === tokenVectorLength - 1) {
            result.push({
              nextTokenType: prod.terminalType,
              nextTokenOccurrence: prod.idx,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
            foundCompletePath = true;
          } else {
            throw Error("non exhaustive match");
          }
        } else if (prod instanceof gast_1.NonTerminal) {
          var newRuleStack = (0, clone_1.default)(currRuleStack);
          newRuleStack.push(prod.nonTerminalName);
          var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
          newOccurrenceStack.push(prod.idx);
          var nextPath = {
            idx: currIdx,
            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
            ruleStack: newRuleStack,
            occurrenceStack: newOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Option) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nextPathWith = {
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var secondIteration = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var secondIteration = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var nthRepetition = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Repetition) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nthRepetition = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Alternation) {
          for (var i = prod.definition.length - 1; i >= 0; i--) {
            var currAlt = prod.definition[i];
            var currAltPath = {
              idx: currIdx,
              def: currAlt.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
          }
        } else if (prod instanceof gast_1.Alternative) {
          possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
        } else if (prod instanceof gast_1.Rule) {
          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        } else {
          throw Error("non exhaustive match");
        }
      }
      return result;
    }
    exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
      var newRuleStack = (0, clone_1.default)(currRuleStack);
      newRuleStack.push(topRule.name);
      var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
      newCurrOccurrenceStack.push(1);
      return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
      };
    }
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
var require_lookahead = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var reduce_1 = __importDefault(require_reduce());
    var interpreter_1 = require_interpreter();
    var rest_1 = require_rest();
    var tokens_1 = require_tokens();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var PROD_TYPE;
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
    function getProdType(prod) {
      if (prod instanceof gast_1.Option || prod === "Option") {
        return PROD_TYPE.OPTION;
      } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
        return PROD_TYPE.REPETITION;
      } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
        return PROD_TYPE.REPETITION_MANDATORY;
      } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
        return PROD_TYPE.ALTERNATION;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProdType = getProdType;
    function getLookaheadPaths2(options) {
      var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
      var type = getProdType(prodType);
      if (type === PROD_TYPE.ALTERNATION) {
        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
      } else {
        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
      }
    }
    exports2.getLookaheadPaths = getLookaheadPaths2;
    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
      var numOfAlts = alts.length;
      var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
        return (0, every_1.default)(currAlt, function(currPath) {
          return currPath.length === 1;
        });
      });
      if (hasPredicates) {
        return function(orAlts) {
          var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
            return currAlt2.GATE;
          });
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t];
            if (currPredicate !== void 0 && currPredicate.call(this) === false) {
              continue;
            }
            nextPath: for (var j = 0; j < currNumOfPaths; j++) {
              var currPath = currAlt[j];
              var currPathLength = currPath.length;
              for (var i = 0; i < currPathLength; i++) {
                var nextToken = this.LA(i + 1);
                if (tokenMatcher2(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return t;
            }
          }
          return void 0;
        };
      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
          return (0, flatten_1.default)(currAlt);
        });
        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
          (0, forEach_1.default)(currAlt, function(currTokType) {
            if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
              result[currTokType.tokenTypeIdx] = idx;
            }
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              if (!(0, has_1.default)(result, currExtendingType)) {
                result[currExtendingType] = idx;
              }
            });
          });
          return result;
        }, {});
        return function() {
          var nextToken = this.LA(1);
          return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
      } else {
        return function() {
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            nextPath: for (var j = 0; j < currNumOfPaths; j++) {
              var currPath = currAlt[j];
              var currPathLength = currPath.length;
              for (var i = 0; i < currPathLength; i++) {
                var nextToken = this.LA(i + 1);
                if (tokenMatcher2(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return t;
            }
          }
          return void 0;
        };
      }
    }
    exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
      var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
        return currPath.length === 1;
      });
      var numOfPaths = alt.length;
      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, flatten_1.default)(alt);
        if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
          var expectedTokenType = singleTokensTypes[0];
          var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
          };
        } else {
          var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
            result[currTokType.tokenTypeIdx] = true;
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              result[currExtendingType] = true;
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
          };
        }
      } else {
        return function() {
          nextPath: for (var j = 0; j < numOfPaths; j++) {
            var currPath = alt[j];
            var currPathLength = currPath.length;
            for (var i = 0; i < currPathLength; i++) {
              var nextToken = this.LA(i + 1);
              if (tokenMatcher2(nextToken, currPath[i]) === false) {
                continue nextPath;
              }
            }
            return true;
          }
          return false;
        };
      }
    }
    exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
    var RestDefinitionFinderWalker = (
      /** @class */
      (function(_super) {
        __extends(RestDefinitionFinderWalker2, _super);
        function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          return _this;
        }
        RestDefinitionFinderWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.restDef;
        };
        RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
          }
          return false;
        };
        RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
          }
        };
        return RestDefinitionFinderWalker2;
      })(rest_1.RestWalker)
    );
    var InsideDefinitionFinderVisitor = (
      /** @class */
      (function(_super) {
        __extends(InsideDefinitionFinderVisitor2, _super);
        function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
          var _this = _super.call(this) || this;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          _this.targetRef = targetRef;
          _this.result = [];
          return _this;
        }
        InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
            this.result = node.definition;
          }
        };
        InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
          this.checkIsTarget(node, PROD_TYPE.OPTION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
        };
        return InsideDefinitionFinderVisitor2;
      })(gast_2.GAstVisitor)
    );
    function initializeArrayOfArrays(size) {
      var result = new Array(size);
      for (var i = 0; i < size; i++) {
        result[i] = [];
      }
      return result;
    }
    function pathToHashKeys(path) {
      var keys = [""];
      for (var i = 0; i < path.length; i++) {
        var tokType = path[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
          var currShorterKey = keys[j];
          longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
          for (var t = 0; t < tokType.categoryMatches.length; t++) {
            var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
            longerKeys.push(currShorterKey + categoriesKeySuffix);
          }
        }
        keys = longerKeys;
      }
      return keys;
    }
    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        if (currAltIdx === idx) {
          continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
          var searchKey = searchPathKeys[searchIdx];
          if (otherAltKnownPathsKeys[searchKey] === true) {
            return false;
          }
        }
      }
      return true;
    }
    function lookAheadSequenceFromAlternatives(altsDefs, k) {
      var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
      });
      var finalResult = initializeArrayOfArrays(partialAlts.length);
      var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, forEach_1.default)(currAltPaths, function(item) {
          var keys = pathToHashKeys(item.partialPath);
          (0, forEach_1.default)(keys, function(currKey) {
            dict[currKey] = true;
          });
        });
        return dict;
      });
      var newData = partialAlts;
      for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx2) {
          var currAltPathsAndSuffixes = currDataset[altIdx2];
          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
            var prefixKeys = pathToHashKeys(currPathPrefix);
            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
            if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
              var currAltResult = finalResult[altIdx2];
              if (containsPath(currAltResult, currPathPrefix) === false) {
                currAltResult.push(currPathPrefix);
                for (var j = 0; j < prefixKeys.length; j++) {
                  var currKey = prefixKeys[j];
                  altsHashes[altIdx2][currKey] = true;
                }
              }
            } else {
              var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
              newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
              (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                var prefixKeys2 = pathToHashKeys(item.partialPath);
                (0, forEach_1.default)(prefixKeys2, function(key) {
                  altsHashes[altIdx2][key] = true;
                });
              });
            }
          }
        };
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
          _loop_1(altIdx);
        }
      }
      return finalResult;
    }
    exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
      ruleGrammar.accept(visitor);
      return lookAheadSequenceFromAlternatives(visitor.result, k);
    }
    exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
      ruleGrammar.accept(insideDefVisitor);
      var insideDef = insideDefVisitor.result;
      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
      var afterDef = afterDefWalker.startWalking();
      var insideFlat = new gast_1.Alternative({ definition: insideDef });
      var afterFlat = new gast_1.Alternative({ definition: afterDef });
      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
    }
    exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
    function containsPath(alternative, searchPath) {
      compareOtherPath: for (var i = 0; i < alternative.length; i++) {
        var otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
          continue;
        }
        for (var j = 0; j < otherPath.length; j++) {
          var searchTok = searchPath[j];
          var otherTok = otherPath[j];
          var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
          if (matchingTokens === false) {
            continue compareOtherPath;
          }
        }
        return true;
      }
      return false;
    }
    exports2.containsPath = containsPath;
    function isStrictPrefixOfPath(prefix, other) {
      return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
      });
    }
    exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
    function areTokenCategoriesNotUsed(lookAheadPaths) {
      return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
        return (0, every_1.default)(singleAltPaths, function(singlePath) {
          return (0, every_1.default)(singlePath, function(token) {
            return (0, isEmpty_1.default)(token.categoryMatches);
          });
        });
      });
    }
    exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js
var require_checks = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var drop_1 = __importDefault(require_drop());
    var flatten_1 = __importDefault(require_flatten());
    var filter_1 = __importDefault(require_filter());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var groupBy_1 = __importDefault(require_groupBy());
    var reduce_1 = __importDefault(require_reduce());
    var pickBy_1 = __importDefault(require_pickBy());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var flatMap_1 = __importDefault(require_flatMap());
    var clone_1 = __importDefault(require_clone());
    var parser_1 = require_parser2();
    var gast_1 = require_api2();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var gast_2 = require_api2();
    var gast_3 = require_api2();
    var dropRight_1 = __importDefault(require_dropRight());
    var compact_1 = __importDefault(require_compact());
    var tokens_1 = require_tokens();
    function validateLookahead(options) {
      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
        rules: options.rules,
        tokenTypes: options.tokenTypes,
        grammarName: options.grammarName
      });
      return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
        return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
      });
    }
    exports2.validateLookahead = validateLookahead;
    function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
      var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
      });
      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
      var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
      });
      var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
      });
      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
    }
    exports2.validateGrammar = validateGrammar;
    function validateDuplicateProductions(topLevelRule, errMsgProvider) {
      var collectorVisitor = new OccurrenceValidationCollector();
      topLevelRule.accept(collectorVisitor);
      var allRuleProductions = collectorVisitor.allProductions;
      var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
      var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
        return currGroup.length > 1;
      });
      var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
        var firstProd = (0, first_1.default)(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, gast_1.getProductionDslName)(firstProd);
        var defError = {
          message: msg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
          ruleName: topLevelRule.name,
          dslName,
          occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
          defError.parameter = param;
        }
        return defError;
      });
      return errors;
    }
    function identifyProductionForDuplicates(prod) {
      return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
    }
    exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_2.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_2.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }
    var OccurrenceValidationCollector = (
      /** @class */
      (function(_super) {
        __extends(OccurrenceValidationCollector2, _super);
        function OccurrenceValidationCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
          this.allProductions.push(subrule);
        };
        OccurrenceValidationCollector2.prototype.visitOption = function(option) {
          this.allProductions.push(option);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
          this.allProductions.push(or);
        };
        OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
          this.allProductions.push(terminal);
        };
        return OccurrenceValidationCollector2;
      })(gast_3.GAstVisitor)
    );
    exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
      var errors = [];
      var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) {
          return result + 1;
        }
        return result;
      }, 0);
      if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
          topLevelRule: rule,
          grammarName: className
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: rule.name
        });
      }
      return errors;
    }
    exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
      var errors = [];
      var errMsg;
      if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
          ruleName
        });
      }
      return errors;
    }
    exports2.validateRuleIsOverridden = validateRuleIsOverridden;
    function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
      if (path === void 0) {
        path = [];
      }
      var errors = [];
      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
      if ((0, isEmpty_1.default)(nextNonTerminals)) {
        return [];
      } else {
        var ruleName = topRule.name;
        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
          errors.push({
            message: errMsgProvider.buildLeftRecursionError({
              topLevelRule: topRule,
              leftRecursionPath: path
            }),
            type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
            ruleName
          });
        }
        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
          var newPath = (0, clone_1.default)(path);
          newPath.push(currRefRule);
          return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
      }
    }
    exports2.validateNoLeftRecursion = validateNoLeftRecursion;
    function getFirstNoneTerminal(definition) {
      var result = [];
      if ((0, isEmpty_1.default)(definition)) {
        return result;
      }
      var firstProd = (0, first_1.default)(definition);
      if (firstProd instanceof gast_2.NonTerminal) {
        result.push(firstProd.referencedRule);
      } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
      } else if (firstProd instanceof gast_2.Alternation) {
        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
          return getFirstNoneTerminal(currSubDef.definition);
        }));
      } else if (firstProd instanceof gast_2.Terminal) {
      } else {
        throw Error("non exhaustive match");
      }
      var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
      var hasMore = definition.length > 1;
      if (isFirstOptional && hasMore) {
        var rest = (0, drop_1.default)(definition);
        return result.concat(getFirstNoneTerminal(rest));
      } else {
        return result;
      }
    }
    exports2.getFirstNoneTerminal = getFirstNoneTerminal;
    var OrCollector = (
      /** @class */
      (function(_super) {
        __extends(OrCollector2, _super);
        function OrCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.alternations = [];
          return _this;
        }
        OrCollector2.prototype.visitAlternation = function(node) {
          this.alternations.push(node);
        };
        return OrCollector2;
      })(gast_3.GAstVisitor)
    );
    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var exceptLast = (0, dropRight_1.default)(currOr.definition);
        return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
          var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
          if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
            return [
              {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              }
            ];
          } else {
            return [];
          }
        });
      });
      return errors;
    }
    exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
    function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      ors = (0, reject_1.default)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
      });
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
      });
      return errors;
    }
    exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
    var RepetitionCollector = (
      /** @class */
      (function(_super) {
        __extends(RepetitionCollector2, _super);
        function RepetitionCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        RepetitionCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        return RepetitionCollector2;
      })(gast_3.GAstVisitor)
    );
    exports2.RepetitionCollector = RepetitionCollector;
    function validateTooManyAlts(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        if (currOr.definition.length > 255) {
          return [
            {
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            }
          ];
        } else {
          return [];
        }
      });
      return errors;
    }
    exports2.validateTooManyAlts = validateTooManyAlts;
    function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
      var errors = [];
      (0, forEach_1.default)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, forEach_1.default)(allRuleProductions, function(currProd) {
          var prodType = (0, lookahead_1.getProdType)(currProd);
          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
          var currOccurrence = currProd.idx;
          var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
          var pathsInsideProduction = paths[0];
          if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
            var errMsg = errMsgProvider.buildEmptyRepetitionError({
              topLevelRule: currTopRule,
              repetition: currProd
            });
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: currTopRule.name
            });
          }
        });
      });
      return errors;
    }
    exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var foundAmbiguousPaths = [];
      var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
          return result;
        }
        (0, forEach_1.default)(currAlt, function(currPath) {
          var altsCurrPathAppearsIn = [currAltIdx];
          (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
            if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
              altsCurrPathAppearsIn.push(currOtherAltIdx);
            }
          });
          if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
            foundAmbiguousPaths.push(currPath);
            result.push({
              alts: altsCurrPathAppearsIn,
              path: currPath
            });
          }
        });
        return result;
      }, []);
      var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
          return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
          topLevelRule: rule,
          alternation,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbDescriptor.path
        });
        return {
          message: currMessage,
          type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
          ruleName: rule.name,
          occurrence: alternation.idx,
          alternatives: currAmbDescriptor.alts
        };
      });
      return currErrors;
    }
    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
          return { idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
      }, []);
      var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        if (alternativeGast.ignoreAmbiguities === true) {
          return [];
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
          return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
            // will be be detected using a different validation.
            (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
          );
        });
        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
          var occurrence = alternation.idx === 0 ? "" : alternation.idx;
          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbPathAndIdx.path
          });
          return {
            message,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
            ruleName: rule.name,
            occurrence,
            alternatives: ambgIndices
          };
        });
        return currPathPrefixErrors;
      }));
      return errors;
    }
    exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
      var errors = [];
      var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
        return currToken.name;
      });
      (0, forEach_1.default)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, includes_1.default)(tokenNames, currRuleName)) {
          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: currRuleName
          });
        }
      });
      return errors;
    }
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
var require_gast_resolver_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateGrammar = exports2.resolveGrammar = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var defaults_1 = __importDefault(require_defaults());
    var resolver_1 = require_resolver();
    var checks_1 = require_checks();
    var errors_public_1 = require_errors_public();
    function resolveGrammar(options) {
      var actualOptions = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
      });
      var topRulesTable = {};
      (0, forEach_1.default)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
      });
      return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
    }
    exports2.resolveGrammar = resolveGrammar;
    function validateGrammar(options) {
      options = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
      });
      return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
    }
    exports2.validateGrammar = validateGrammar;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js
var require_exceptions_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
    var includes_1 = __importDefault(require_includes());
    var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    var EARLY_EXIT_EXCEPTION = "EarlyExitException";
    var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    var RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    function isRecognitionException2(error) {
      return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
    }
    exports2.isRecognitionException = isRecognitionException2;
    var RecognitionException = (
      /** @class */
      (function(_super) {
        __extends(RecognitionException2, _super);
        function RecognitionException2(message, token) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.token = token;
          _this.resyncedTokens = [];
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
          }
          return _this;
        }
        return RecognitionException2;
      })(Error)
    );
    var MismatchedTokenException2 = (
      /** @class */
      (function(_super) {
        __extends(MismatchedTokenException3, _super);
        function MismatchedTokenException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = MISMATCHED_TOKEN_EXCEPTION;
          return _this;
        }
        return MismatchedTokenException3;
      })(RecognitionException)
    );
    exports2.MismatchedTokenException = MismatchedTokenException2;
    var NoViableAltException2 = (
      /** @class */
      (function(_super) {
        __extends(NoViableAltException3, _super);
        function NoViableAltException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = NO_VIABLE_ALT_EXCEPTION;
          return _this;
        }
        return NoViableAltException3;
      })(RecognitionException)
    );
    exports2.NoViableAltException = NoViableAltException2;
    var NotAllInputParsedException2 = (
      /** @class */
      (function(_super) {
        __extends(NotAllInputParsedException3, _super);
        function NotAllInputParsedException3(message, token) {
          var _this = _super.call(this, message, token) || this;
          _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
          return _this;
        }
        return NotAllInputParsedException3;
      })(RecognitionException)
    );
    exports2.NotAllInputParsedException = NotAllInputParsedException2;
    var EarlyExitException2 = (
      /** @class */
      (function(_super) {
        __extends(EarlyExitException3, _super);
        function EarlyExitException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = EARLY_EXIT_EXCEPTION;
          return _this;
        }
        return EarlyExitException3;
      })(RecognitionException)
    );
    exports2.EarlyExitException = EarlyExitException2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
var require_recoverable = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
    var tokens_public_1 = require_tokens_public();
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var flatten_1 = __importDefault(require_flatten());
    var map_1 = __importDefault(require_map2());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    var exceptions_public_1 = require_exceptions_public();
    var constants_1 = require_constants();
    var parser_1 = require_parser2();
    exports2.EOF_FOLLOW_KEY = {};
    exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    var InRuleRecoveryException = (
      /** @class */
      (function(_super) {
        __extends(InRuleRecoveryException2, _super);
        function InRuleRecoveryException2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
          return _this;
        }
        return InRuleRecoveryException2;
      })(Error)
    );
    exports2.InRuleRecoveryException = InRuleRecoveryException;
    var Recoverable = (
      /** @class */
      (function() {
        function Recoverable2() {
        }
        Recoverable2.prototype.initRecoverable = function(config) {
          this.firstAfterRepMap = {};
          this.resyncFollows = {};
          this.recoveryEnabled = (0, has_1.default)(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
          if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
          }
        };
        Recoverable2.prototype.getTokenToInsert = function(tokType) {
          var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
          tokToInsert.isInsertedInRecovery = true;
          return tokToInsert;
        };
        Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
          var _this = this;
          var reSyncTokType = this.findReSyncTokenType();
          var savedLexerState = this.exportLexerState();
          var resyncedTokens = [];
          var passedResyncPoint = false;
          var nextTokenWithoutResync = this.LA(1);
          var currToken = this.LA(1);
          var generateErrorMessage = function() {
            var previousToken = _this.LA(0);
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
              expected: expectedTokType,
              actual: nextTokenWithoutResync,
              previous: previousToken,
              ruleName: _this.getCurrRuleFullName()
            });
            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
            _this.SAVE_ERROR(error);
          };
          while (!passedResyncPoint) {
            if (this.tokenMatcher(currToken, expectedTokType)) {
              generateErrorMessage();
              return;
            } else if (lookAheadFunc.call(this)) {
              generateErrorMessage();
              grammarRule.apply(this, grammarRuleArgs);
              return;
            } else if (this.tokenMatcher(currToken, reSyncTokType)) {
              passedResyncPoint = true;
            } else {
              currToken = this.SKIP_TOKEN();
              this.addToResyncTokens(currToken, resyncedTokens);
            }
          }
          this.importLexerState(savedLexerState);
        };
        Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
          if (notStuck === false) {
            return false;
          }
          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
          }
          if (this.isBackTracking()) {
            return false;
          }
          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
          }
          return true;
        };
        Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
          var follows = this.getNextPossibleTokenTypes(grammarPath);
          return follows;
        };
        Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
          }
          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
          }
          throw new InRuleRecoveryException("sad sad panda");
        };
        Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
        };
        Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
          var _this = this;
          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
          }
          if ((0, isEmpty_1.default)(follows)) {
            return false;
          }
          var mismatchedTok = this.LA(1);
          var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
          }) !== void 0;
          return isMisMatchedTokInFollows;
        };
        Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
            return false;
          }
          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
          return isNextTokenWhatIsExpected;
        };
        Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
          var followKey = this.getCurrFollowKey();
          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
          return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
        };
        Recoverable2.prototype.findReSyncTokenType = function() {
          var allPossibleReSyncTokTypes = this.flattenFollowSet();
          var nextToken = this.LA(1);
          var k = 2;
          while (true) {
            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
              var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
              return canMatch;
            });
            if (foundMatch !== void 0) {
              return foundMatch;
            }
            nextToken = this.LA(k);
            k++;
          }
        };
        Recoverable2.prototype.getCurrFollowKey = function() {
          if (this.RULE_STACK.length === 1) {
            return exports2.EOF_FOLLOW_KEY;
          }
          var currRuleShortName = this.getLastExplicitRuleShortName();
          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
          var prevRuleShortName = this.getPreviousExplicitRuleShortName();
          return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
          };
        };
        Recoverable2.prototype.buildFullFollowKeyStack = function() {
          var _this = this;
          var explicitRuleStack = this.RULE_STACK;
          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
          return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
            if (idx === 0) {
              return exports2.EOF_FOLLOW_KEY;
            }
            return {
              ruleName: _this.shortRuleNameToFullName(ruleName),
              idxInCallingRule: explicitOccurrenceStack[idx],
              inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
          });
        };
        Recoverable2.prototype.flattenFollowSet = function() {
          var _this = this;
          var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
          });
          return (0, flatten_1.default)(followStack);
        };
        Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
          if (followKey === exports2.EOF_FOLLOW_KEY) {
            return [tokens_public_1.EOF];
          }
          var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
          return this.resyncFollows[followName];
        };
        Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
          if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
            resyncTokens.push(token);
          }
          return resyncTokens;
        };
        Recoverable2.prototype.reSyncTo = function(tokType) {
          var resyncedTokens = [];
          var nextTok = this.LA(1);
          while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
          }
          return (0, dropRight_1.default)(resyncedTokens);
        };
        Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        };
        Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
          var pathRuleStack = this.getHumanReadableRuleStack();
          var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
          var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
          };
          return grammarPath;
        };
        Recoverable2.prototype.getHumanReadableRuleStack = function() {
          var _this = this;
          return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
            return _this.shortRuleNameToFullName(currShortName);
          });
        };
        return Recoverable2;
      })()
    );
    exports2.Recoverable = Recoverable;
    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
      var firstAfterRepInfo = this.firstAfterRepMap[key];
      if (firstAfterRepInfo === void 0) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
      }
      var expectTokAfterLastMatch = firstAfterRepInfo.token;
      var nextTokIdx = firstAfterRepInfo.occurrence;
      var isEndOfRule = firstAfterRepInfo.isEndOfRule;
      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
        expectTokAfterLastMatch = tokens_public_1.EOF;
        nextTokIdx = 1;
      }
      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
        return;
      }
      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
      }
    }
    exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js
var require_keys2 = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
    exports2.BITS_FOR_METHOD_TYPE = 4;
    exports2.BITS_FOR_OCCURRENCE_IDX = 8;
    exports2.BITS_FOR_RULE_IDX = 12;
    exports2.BITS_FOR_ALT_IDX = 8;
    exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
    function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
      return occurrence | dslMethodIdx | ruleIdx;
    }
    exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
    var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
var require_llk_lookahead = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLkLookaheadStrategy = void 0;
    var flatMap_1 = __importDefault(require_flatMap());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var errors_public_1 = require_errors_public();
    var parser_1 = require_parser2();
    var checks_1 = require_checks();
    var lookahead_1 = require_lookahead();
    var LLkLookaheadStrategy2 = (
      /** @class */
      (function() {
        function LLkLookaheadStrategy3(options) {
          var _a;
          this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
        }
        LLkLookaheadStrategy3.prototype.validate = function(options) {
          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
          if ((0, isEmpty_1.default)(leftRecursionErrors)) {
            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
            return allErrors;
          }
          return leftRecursionErrors;
        };
        LLkLookaheadStrategy3.prototype.validateNoLeftRecursion = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateEmptyOrAlternatives = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
          return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForAlternation = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForOptional = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
        };
        return LLkLookaheadStrategy3;
      })()
    );
    exports2.LLkLookaheadStrategy = LLkLookaheadStrategy2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
var require_looksahead = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectMethods = exports2.LooksAhead = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var parser_1 = require_parser2();
    var keys_1 = require_keys2();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var llk_lookahead_1 = require_llk_lookahead();
    var LooksAhead = (
      /** @class */
      (function() {
        function LooksAhead2() {
        }
        LooksAhead2.prototype.initLooksAhead = function(config) {
          this.dynamicTokensEnabled = (0, has_1.default)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
          this.maxLookahead = (0, has_1.default)(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          this.lookaheadStrategy = (0, has_1.default)(config, "lookaheadStrategy") ? config.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
          this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
        };
        LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
          var _this = this;
          (0, forEach_1.default)(rules, function(currRule) {
            _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
              var _a = collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
              (0, forEach_1.default)(alternation, function(currProd) {
                var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                  var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                    prodOccurrence: currProd.idx,
                    rule: currRule,
                    maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                    hasPredicates: currProd.hasPredicates,
                    dynamicTokensEnabled: _this.dynamicTokensEnabled
                  });
                  var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                  _this.setLaFuncCache(key, laFunc);
                });
              });
              (0, forEach_1.default)(repetition, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(option, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
            });
          });
        };
        LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
          var _this = this;
          this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
            var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
              prodOccurrence,
              rule,
              maxLookahead: prodMaxLookahead || _this.maxLookahead,
              dynamicTokensEnabled: _this.dynamicTokensEnabled,
              prodType
            });
            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
          });
        };
        LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
          var currRuleShortName = this.getLastExplicitRuleShortName();
          return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
        };
        LooksAhead2.prototype.getLaFuncFromCache = function(key) {
          return this.lookAheadFuncsCache.get(key);
        };
        LooksAhead2.prototype.setLaFuncCache = function(key, value) {
          this.lookAheadFuncsCache.set(key, value);
        };
        return LooksAhead2;
      })()
    );
    exports2.LooksAhead = LooksAhead;
    var DslMethodsCollectorVisitor = (
      /** @class */
      (function(_super) {
        __extends(DslMethodsCollectorVisitor2, _super);
        function DslMethodsCollectorVisitor2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
          return _this;
        }
        DslMethodsCollectorVisitor2.prototype.reset = function() {
          this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
        };
        DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
          this.dslMethods.option.push(option);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.dslMethods.repetitionWithSeparator.push(manySep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.dslMethods.repetitionMandatory.push(atLeastOne);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
          this.dslMethods.repetition.push(many);
        };
        DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
          this.dslMethods.alternation.push(or);
        };
        return DslMethodsCollectorVisitor2;
      })(gast_1.GAstVisitor)
    );
    var collectorVisitor = new DslMethodsCollectorVisitor();
    function collectMethods(rule) {
      collectorVisitor.reset();
      rule.accept(collectorVisitor);
      var dslMethods = collectorVisitor.dslMethods;
      collectorVisitor.reset();
      return dslMethods;
    }
    exports2.collectMethods = collectMethods;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js
var require_cst2 = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      }
    }
    exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
    function setNodeLocationFull(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      }
    }
    exports2.setNodeLocationFull = setNodeLocationFull;
    function addTerminalToCst(node, token, tokenTypeName) {
      if (node.children[tokenTypeName] === void 0) {
        node.children[tokenTypeName] = [token];
      } else {
        node.children[tokenTypeName].push(token);
      }
    }
    exports2.addTerminalToCst = addTerminalToCst;
    function addNoneTerminalToCst(node, ruleName, ruleResult) {
      if (node.children[ruleName] === void 0) {
        node.children[ruleName] = [ruleResult];
      } else {
        node.children[ruleName].push(ruleResult);
      }
    }
    exports2.addNoneTerminalToCst = addNoneTerminalToCst;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js
var require_lang_extensions = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineNameProp = void 0;
    var NAME = "name";
    function defineNameProp(obj, nameValue) {
      Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue
      });
    }
    exports2.defineNameProp = defineNameProp;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
var require_cst_visitor = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var filter_1 = __importDefault(require_filter());
    var keys_1 = __importDefault(require_keys());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lang_extensions_1 = require_lang_extensions();
    function defaultVisit(ctx, param) {
      var childrenNames = (0, keys_1.default)(ctx);
      var childrenNamesLength = childrenNames.length;
      for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
          var currChild = currChildArray[j];
          if (currChild.tokenTypeIdx === void 0) {
            this[currChild.name](currChild.children, param);
          }
        }
      }
    }
    exports2.defaultVisit = defaultVisit;
    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
      var semanticProto = {
        visit: function(cstNode, param) {
          if ((0, isArray_1.default)(cstNode)) {
            cstNode = cstNode[0];
          }
          if ((0, isUndefined_1.default)(cstNode)) {
            return void 0;
          }
          return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
          var semanticDefinitionErrors = validateVisitor(this, ruleNames);
          if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
            var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
              return currDefError.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
          }
        }
      };
      derivedConstructor.prototype = semanticProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      derivedConstructor._RULE_NAMES = ruleNames;
      return derivedConstructor;
    }
    exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
      var withDefaultsProto = Object.create(baseConstructor.prototype);
      (0, forEach_1.default)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
      });
      derivedConstructor.prototype = withDefaultsProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      return derivedConstructor;
    }
    exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
    var CstVisitorDefinitionError;
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
    function validateVisitor(visitorInstance, ruleNames) {
      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
      return missingErrors;
    }
    exports2.validateVisitor = validateVisitor;
    function validateMissingCstMethods(visitorInstance, ruleNames) {
      var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
      });
      var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
        return {
          msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
          type: CstVisitorDefinitionError.MISSING_METHOD,
          methodName: currRuleName
        };
      });
      return (0, compact_1.default)(errors);
    }
    exports2.validateMissingCstMethods = validateMissingCstMethods;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var require_tree_builder = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeBuilder = void 0;
    var cst_1 = require_cst2();
    var noop_1 = __importDefault(require_noop());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var cst_visitor_1 = require_cst_visitor();
    var parser_1 = require_parser2();
    var TreeBuilder = (
      /** @class */
      (function() {
        function TreeBuilder2() {
        }
        TreeBuilder2.prototype.initTreeBuilder = function(config) {
          this.CST_STACK = [];
          this.outputCst = config.outputCst;
          this.nodeLocationTracking = (0, has_1.default)(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
          if (!this.outputCst) {
            this.cstInvocationStateUpdate = noop_1.default;
            this.cstFinallyStateUpdate = noop_1.default;
            this.cstPostTerminal = noop_1.default;
            this.cstPostNonTerminal = noop_1.default;
            this.cstPostRule = noop_1.default;
          } else {
            if (/full/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleFull;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
              }
            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleOnlyOffset;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
              }
            } else if (/none/i.test(this.nodeLocationTracking)) {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = noop_1.default;
            } else {
              throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config.nodeLocationTracking, '"'));
            }
          }
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
          cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
          var nextToken = this.LA(1);
          cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
          var cstNode = {
            name: fullRuleName,
            children: /* @__PURE__ */ Object.create(null)
          };
          this.setInitialNodeLocation(cstNode);
          this.CST_STACK.push(cstNode);
        };
        TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
          this.CST_STACK.pop();
        };
        TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
          } else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
          } else {
            loc.startOffset = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
          this.setNodeLocationFromToken(rootCst.location, consumedToken);
        };
        TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
          }
          return this.baseCstVisitorConstructor;
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        };
        TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 1];
        };
        TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 2];
        };
        TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
          var occurrenceStack = this.RULE_OCCURRENCE_STACK;
          return occurrenceStack[occurrenceStack.length - 1];
        };
        return TreeBuilder2;
      })()
    );
    exports2.TreeBuilder = TreeBuilder;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var require_lexer_adapter = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerAdapter = void 0;
    var parser_1 = require_parser2();
    var LexerAdapter = (
      /** @class */
      (function() {
        function LexerAdapter2() {
        }
        LexerAdapter2.prototype.initLexerAdapter = function() {
          this.tokVector = [];
          this.tokVectorLength = 0;
          this.currIdx = -1;
        };
        Object.defineProperty(LexerAdapter2.prototype, "input", {
          get: function() {
            return this.tokVector;
          },
          set: function(newInput) {
            if (this.selfAnalysisDone !== true) {
              throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
          },
          enumerable: false,
          configurable: true
        });
        LexerAdapter2.prototype.SKIP_TOKEN = function() {
          if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
          } else {
            return parser_1.END_OF_FILE;
          }
        };
        LexerAdapter2.prototype.LA = function(howMuch) {
          var soughtIdx = this.currIdx + howMuch;
          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return parser_1.END_OF_FILE;
          } else {
            return this.tokVector[soughtIdx];
          }
        };
        LexerAdapter2.prototype.consumeToken = function() {
          this.currIdx++;
        };
        LexerAdapter2.prototype.exportLexerState = function() {
          return this.currIdx;
        };
        LexerAdapter2.prototype.importLexerState = function(newState) {
          this.currIdx = newState;
        };
        LexerAdapter2.prototype.resetLexerState = function() {
          this.currIdx = -1;
        };
        LexerAdapter2.prototype.moveToTerminatedState = function() {
          this.currIdx = this.tokVector.length - 1;
        };
        LexerAdapter2.prototype.getLexerPosition = function() {
          return this.exportLexerState();
        };
        return LexerAdapter2;
      })()
    );
    exports2.LexerAdapter = LexerAdapter;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var require_recognizer_api = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerApi = void 0;
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var exceptions_public_1 = require_exceptions_public();
    var parser_1 = require_parser2();
    var errors_public_1 = require_errors_public();
    var checks_1 = require_checks();
    var gast_1 = require_api2();
    var RecognizerApi = (
      /** @class */
      (function() {
        function RecognizerApi2() {
        }
        RecognizerApi2.prototype.ACTION = function(impl) {
          return impl.call(this);
        };
        RecognizerApi2.prototype.consume = function(idx, tokType, options) {
          return this.consumeInternal(tokType, idx, options);
        };
        RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
          return this.subruleInternal(ruleToCall, idx, options);
        };
        RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, idx);
        };
        RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
          return this.orInternal(altsOrOpts, idx);
        };
        RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
          return this.manyInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
          return this.atLeastOneInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.CONSUME = function(tokType, options) {
          return this.consumeInternal(tokType, 0, options);
        };
        RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
          return this.consumeInternal(tokType, 1, options);
        };
        RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
          return this.consumeInternal(tokType, 2, options);
        };
        RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
          return this.consumeInternal(tokType, 3, options);
        };
        RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
          return this.consumeInternal(tokType, 4, options);
        };
        RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
          return this.consumeInternal(tokType, 5, options);
        };
        RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
          return this.consumeInternal(tokType, 6, options);
        };
        RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
          return this.consumeInternal(tokType, 7, options);
        };
        RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
          return this.consumeInternal(tokType, 8, options);
        };
        RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
          return this.consumeInternal(tokType, 9, options);
        };
        RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 0, options);
        };
        RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 1, options);
        };
        RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 2, options);
        };
        RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 3, options);
        };
        RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 4, options);
        };
        RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 5, options);
        };
        RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 6, options);
        };
        RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 7, options);
        };
        RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 8, options);
        };
        RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 9, options);
        };
        RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 0);
        };
        RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 1);
        };
        RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 2);
        };
        RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 3);
        };
        RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 4);
        };
        RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 5);
        };
        RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 6);
        };
        RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 7);
        };
        RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 8);
        };
        RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 9);
        };
        RecognizerApi2.prototype.OR = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 0);
        };
        RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 1);
        };
        RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 2);
        };
        RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 3);
        };
        RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 4);
        };
        RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 5);
        };
        RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 6);
        };
        RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 7);
        };
        RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 8);
        };
        RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 9);
        };
        RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
          this.manyInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
          this.manyInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
          this.manyInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
          this.manyInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
          this.manyInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
          this.manyInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
          this.manyInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
          this.manyInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
          this.manyInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
          this.manyInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY_SEP = function(options) {
          this.manySepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.MANY_SEP1 = function(options) {
          this.manySepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.MANY_SEP2 = function(options) {
          this.manySepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.MANY_SEP3 = function(options) {
          this.manySepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.MANY_SEP4 = function(options) {
          this.manySepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.MANY_SEP5 = function(options) {
          this.manySepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.MANY_SEP6 = function(options) {
          this.manySepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.MANY_SEP7 = function(options) {
          this.manySepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.MANY_SEP8 = function(options) {
          this.manySepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.MANY_SEP9 = function(options) {
          this.manySepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
          this.atLeastOneInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
          return this.atLeastOneInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
          this.atLeastOneInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
          this.atLeastOneInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
          this.atLeastOneInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
          this.atLeastOneInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
          this.atLeastOneInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
          this.atLeastOneInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
          this.atLeastOneInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
          this.atLeastOneInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
          this.atLeastOneSepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
          this.atLeastOneSepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
          this.atLeastOneSepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
          this.atLeastOneSepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
          this.atLeastOneSepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
          this.atLeastOneSepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
          this.atLeastOneSepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
          this.atLeastOneSepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
          this.atLeastOneSepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
          this.atLeastOneSepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.RULE = function(name, implementation, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          if ((0, includes_1.default)(this.definedRulesNames, name)) {
            var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
              topLevelRule: name,
              grammarName: this.className
            });
            var error = {
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
              ruleName: name
            };
            this.definitionErrors.push(error);
          }
          this.definedRulesNames.push(name);
          var ruleImplementation = this.defineRule(name, implementation, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(ruleErrors);
          var ruleImplementation = this.defineRule(name, impl, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
          return function() {
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
              grammarRule.apply(this, args);
              return true;
            } catch (e) {
              if ((0, exceptions_public_1.isRecognitionException)(e)) {
                return false;
              } else {
                throw e;
              }
            } finally {
              this.reloadRecogState(orgState);
              this.isBackTrackingStack.pop();
            }
          };
        };
        RecognizerApi2.prototype.getGAstProductions = function() {
          return this.gastProductionsCache;
        };
        RecognizerApi2.prototype.getSerializedGastProductions = function() {
          return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
        };
        return RecognizerApi2;
      })()
    );
    exports2.RecognizerApi = RecognizerApi;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var require_recognizer_engine = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerEngine = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var uniq_1 = __importDefault(require_uniq());
    var isObject_1 = __importDefault(require_isObject());
    var has_1 = __importDefault(require_has());
    var values_1 = __importDefault(require_values());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var keys_1 = require_keys2();
    var exceptions_public_1 = require_exceptions_public();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var parser_1 = require_parser2();
    var recoverable_1 = require_recoverable();
    var tokens_public_1 = require_tokens_public();
    var tokens_1 = require_tokens();
    var RecognizerEngine = (
      /** @class */
      (function() {
        function RecognizerEngine2() {
        }
        RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
          this.className = this.constructor.name;
          this.shortRuleNameToFull = {};
          this.fullRuleNameToShort = {};
          this.ruleShortNameIdx = 256;
          this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
          this.subruleIdx = 0;
          this.definedRulesNames = [];
          this.tokensMap = {};
          this.isBackTrackingStack = [];
          this.RULE_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
          this.gastProductionsCache = {};
          if ((0, has_1.default)(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            if ((0, isEmpty_1.default)(tokenVocabulary)) {
              throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
              throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
            }
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, isObject_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, clone_1.default)(tokenVocabulary);
          } else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
          }
          this.tokensMap["EOF"] = tokens_public_1.EOF;
          var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
          var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
          });
          this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
          (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
        };
        RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
          if (this.selfAnalysisDone) {
            throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
          }
          var resyncEnabled = (0, has_1.default)(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
          var recoveryValueFunc = (0, has_1.default)(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
          var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
          this.ruleShortNameIdx++;
          this.shortRuleNameToFull[shortName] = ruleName;
          this.fullRuleNameToShort[ruleName] = shortName;
          var invokeRuleWithTry;
          if (this.outputCst === true) {
            invokeRuleWithTry = function invokeRuleWithTry2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                impl.apply(this, args);
                var cst = this.CST_STACK[this.CST_STACK.length - 1];
                this.cstPostRule(cst);
                return cst;
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          } else {
            invokeRuleWithTry = function invokeRuleWithTryCst() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                return impl.apply(this, args);
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          }
          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
          return wrappedGrammarRule;
        };
        RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
          var isFirstInvokedRule = this.RULE_STACK.length === 1;
          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
          if ((0, exceptions_public_1.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
              var reSyncTokType = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  return partialCstResult;
                } else {
                  return recoveryValueFunc(e);
                }
              } else {
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  recogError.partialCstResult = partialCstResult;
                }
                throw recogError;
              }
            } else if (isFirstInvokedRule) {
              this.moveToTerminatedState();
              return recoveryValueFunc(e);
            } else {
              throw recogError;
            }
          } else {
            throw e;
          }
        };
        RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
          var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
          return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        };
        RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_1 = actionORMethodDef.GATE;
            if (predicate_1 !== void 0) {
              var orgLookaheadFunction_1 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            return action.call(this);
          }
          return void 0;
        };
        RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_2 = actionORMethodDef.GATE;
            if (predicate_2 !== void 0) {
              var orgLookaheadFunction_2 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
          }
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
          if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
          }
        };
        RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookaheadFunction = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_3 = actionORMethodDef.GATE;
            if (predicate_3 !== void 0) {
              var orgLookaheadFunction_3 = lookaheadFunction;
              lookaheadFunction = function() {
                return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          var notStuck = true;
          while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
          this.attemptInRepetitionRecovery(
            this.manyInternal,
            [prodOccurrence, actionORMethodDef],
            lookaheadFunction,
            keys_1.MANY_IDX,
            prodOccurrence,
            interpreter_1.NextTerminalAfterManyWalker,
            // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
            // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
            // An infinite loop cannot occur as:
            // - Either the lookahead is guaranteed to consume something (Single Token Separator)
            // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
            notStuck
          );
        };
        RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLaFunc = this.getLaFuncFromCache(key);
          if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
          }
        };
        RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
          while (separatorLookAheadFunc()) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
          ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
        };
        RecognizerEngine2.prototype.doSingleRepetition = function(action) {
          var beforeIteration = this.getLexerPosition();
          action.call(this);
          var afterIteration = this.getLexerPosition();
          return afterIteration > beforeIteration;
        };
        RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
          var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
          var laFunc = this.getLaFuncFromCache(laKey);
          var altIdxToTake = laFunc.call(this, alts);
          if (altIdxToTake !== void 0) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
          }
          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        };
        RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
          this.RULE_STACK.pop();
          this.RULE_OCCURRENCE_STACK.pop();
          this.cstFinallyStateUpdate();
          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
              firstRedundant: firstRedundantTok,
              ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
          }
        };
        RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
          var ruleResult;
          try {
            var args = options !== void 0 ? options.ARGS : void 0;
            this.subruleIdx = idx;
            ruleResult = ruleToCall.apply(this, args);
            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
            return ruleResult;
          } catch (e) {
            throw this.subruleInternalError(e, options, ruleToCall.ruleName);
          }
        };
        RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
          if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
            delete e.partialCstResult;
          }
          throw e;
        };
        RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
          var consumedToken;
          try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
              this.consumeToken();
              consumedToken = nextToken;
            } else {
              this.consumeInternalError(tokType, nextToken, options);
            }
          } catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
          }
          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
          return consumedToken;
        };
        RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
          var msg;
          var previousToken = this.LA(0);
          if (options !== void 0 && options.ERR_MSG) {
            msg = options.ERR_MSG;
          } else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
              expected: tokType,
              actual: nextToken,
              previous: previousToken,
              ruleName: this.getCurrRuleFullName()
            });
          }
          throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
        };
        RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
          if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
          eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
              return this.tryInRuleRecovery(tokType, follows);
            } catch (eFromInRuleRecovery) {
              if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                throw eFromConsumption;
              } else {
                throw eFromInRuleRecovery;
              }
            }
          } else {
            throw eFromConsumption;
          }
        };
        RecognizerEngine2.prototype.saveRecogState = function() {
          var savedErrors = this.errors;
          var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
          return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK
          };
        };
        RecognizerEngine2.prototype.reloadRecogState = function(newState) {
          this.errors = newState.errors;
          this.importLexerState(newState.lexerState);
          this.RULE_STACK = newState.RULE_STACK;
        };
        RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
          this.RULE_STACK.push(shortName);
          this.cstInvocationStateUpdate(fullName);
        };
        RecognizerEngine2.prototype.isBackTracking = function() {
          return this.isBackTrackingStack.length !== 0;
        };
        RecognizerEngine2.prototype.getCurrRuleFullName = function() {
          var shortName = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.isAtEndOfInput = function() {
          return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
        };
        RecognizerEngine2.prototype.reset = function() {
          this.resetLexerState();
          this.subruleIdx = 0;
          this.isBackTrackingStack = [];
          this.errors = [];
          this.RULE_STACK = [];
          this.CST_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
        };
        return RecognizerEngine2;
      })()
    );
    exports2.RecognizerEngine = RecognizerEngine;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var require_error_handler = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorHandler = void 0;
    var exceptions_public_1 = require_exceptions_public();
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var lookahead_1 = require_lookahead();
    var parser_1 = require_parser2();
    var ErrorHandler = (
      /** @class */
      (function() {
        function ErrorHandler2() {
        }
        ErrorHandler2.prototype.initErrorHandler = function(config) {
          this._errors = [];
          this.errorMessageProvider = (0, has_1.default)(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
        };
        ErrorHandler2.prototype.SAVE_ERROR = function(error) {
          if ((0, exceptions_public_1.isRecognitionException)(error)) {
            error.context = {
              ruleStack: this.getHumanReadableRuleStack(),
              ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
          } else {
            throw Error("Trying to save an Error which is not a RecognitionException");
          }
        };
        Object.defineProperty(ErrorHandler2.prototype, "errors", {
          get: function() {
            return (0, clone_1.default)(this._errors);
          },
          set: function(newErrors) {
            this._errors = newErrors;
          },
          enumerable: false,
          configurable: true
        });
        ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
          var insideProdPaths = lookAheadPathsPerAlternative[0];
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName
          });
          throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
        };
        ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var previousToken = this.LA(0);
          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
          });
          throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
        };
        return ErrorHandler2;
      })()
    );
    exports2.ErrorHandler = ErrorHandler;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var require_context_assist = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentAssist = void 0;
    var interpreter_1 = require_interpreter();
    var first_1 = __importDefault(require_first2());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var ContentAssist = (
      /** @class */
      (function() {
        function ContentAssist2() {
        }
        ContentAssist2.prototype.initContentAssist = function() {
        };
        ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
          var startRuleGast = this.gastProductionsCache[startRuleName];
          if ((0, isUndefined_1.default)(startRuleGast)) {
            throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
          }
          return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
        };
        ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
          var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
          var gastProductions = this.getGAstProductions();
          var topProduction = gastProductions[topRuleName];
          var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
          return nextPossibleTokenTypes;
        };
        return ContentAssist2;
      })()
    );
    exports2.ContentAssist = ContentAssist;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
var require_gast_recorder = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRecorder = void 0;
    var last_1 = __importDefault(require_last());
    var isArray_1 = __importDefault(require_isArray());
    var some_1 = __importDefault(require_some());
    var forEach_1 = __importDefault(require_forEach());
    var isFunction_1 = __importDefault(require_isFunction());
    var has_1 = __importDefault(require_has());
    var gast_1 = require_api2();
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    var tokens_public_1 = require_tokens_public();
    var parser_1 = require_parser2();
    var keys_1 = require_keys2();
    var RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    var HANDLE_SEPARATOR = true;
    var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
    var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([RFT]);
    var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
      // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    var RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    var GastRecorder = (
      /** @class */
      (function() {
        function GastRecorder2() {
        }
        GastRecorder2.prototype.initGastRecorder = function(config) {
          this.recordingProdStack = [];
          this.RECORDING_PHASE = false;
        };
        GastRecorder2.prototype.enableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = true;
          this.TRACE_INIT("Enable Recording", function() {
            var _loop_1 = function(i2) {
              var idx = i2 > 0 ? i2 : "";
              _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                return this.consumeInternalRecord(arg1, i2, arg2);
              };
              _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                return this.subruleInternalRecord(arg1, i2, arg2);
              };
              _this["OPTION".concat(idx)] = function(arg1) {
                return this.optionInternalRecord(arg1, i2);
              };
              _this["OR".concat(idx)] = function(arg1) {
                return this.orInternalRecord(arg1, i2);
              };
              _this["MANY".concat(idx)] = function(arg1) {
                this.manyInternalRecord(i2, arg1);
              };
              _this["MANY_SEP".concat(idx)] = function(arg1) {
                this.manySepFirstInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                this.atLeastOneInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                this.atLeastOneSepFirstInternalRecord(i2, arg1);
              };
            };
            for (var i = 0; i < 10; i++) {
              _loop_1(i);
            }
            _this["consume"] = function(idx, arg1, arg2) {
              return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function(idx, arg1, arg2) {
              return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function(idx, arg1) {
              return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function(idx, arg1) {
              return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function(idx, arg1) {
              this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function(idx, arg1) {
              this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
          });
        };
        GastRecorder2.prototype.disableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = false;
          this.TRACE_INIT("Deleting Recording methods", function() {
            var that = _this;
            for (var i = 0; i < 10; i++) {
              var idx = i > 0 ? i : "";
              delete that["CONSUME".concat(idx)];
              delete that["SUBRULE".concat(idx)];
              delete that["OPTION".concat(idx)];
              delete that["OR".concat(idx)];
              delete that["MANY".concat(idx)];
              delete that["MANY_SEP".concat(idx)];
              delete that["AT_LEAST_ONE".concat(idx)];
              delete that["AT_LEAST_ONE_SEP".concat(idx)];
            }
            delete that["consume"];
            delete that["subrule"];
            delete that["option"];
            delete that["or"];
            delete that["many"];
            delete that["atLeastOne"];
            delete that.ACTION;
            delete that.BACKTRACK;
            delete that.LA;
          });
        };
        GastRecorder2.prototype.ACTION_RECORD = function(impl) {
        };
        GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
          return function() {
            return true;
          };
        };
        GastRecorder2.prototype.LA_RECORD = function(howMuch) {
          return parser_1.END_OF_FILE;
        };
        GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
          try {
            var newTopLevelRule = new gast_1.Rule({ definition: [], name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
          } catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
              try {
                originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
              } catch (mutabilityError) {
                throw originalError;
              }
            }
            throw originalError;
          }
        };
        GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
          return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
          return recordOrProd.call(this, altsOrOpts, occurrence);
        };
        GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var ruleName = ruleToCall.ruleName;
          var newNoneTerminal = new gast_1.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: void 0
          });
          prevProd.definition.push(newNoneTerminal);
          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
        };
        GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var newNoneTerminal = new gast_1.Terminal({
            idx: occurrence,
            terminalType: tokType,
            label: options === null || options === void 0 ? void 0 : options.LABEL
          });
          prevProd.definition.push(newNoneTerminal);
          return RECORDING_PHASE_TOKEN;
        };
        return GastRecorder2;
      })()
    );
    exports2.GastRecorder = GastRecorder;
    function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
      if (handleSep === void 0) {
        handleSep = false;
      }
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
      var newProd = new prodConstructor({ definition: [], idx: occurrence });
      if (handleSep) {
        newProd.separator = mainProdArg.SEP;
      }
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      this.recordingProdStack.push(newProd);
      grammarAction.call(this);
      prevProd.definition.push(newProd);
      this.recordingProdStack.pop();
      return RECORDING_NULL_OBJECT;
    }
    function recordOrProd(mainProdArg, occurrence) {
      var _this = this;
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
      var newOrProd = new gast_1.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
      });
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
        return (0, isFunction_1.default)(currAlt.GATE);
      });
      newOrProd.hasPredicates = hasPredicates;
      prevProd.definition.push(newOrProd);
      (0, forEach_1.default)(alts, function(currAlt) {
        var currAltFlat = new gast_1.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        } else if ((0, has_1.default)(currAlt, "GATE")) {
          currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
      });
      return RECORDING_NULL_OBJECT;
    }
    function getIdxSuffix(idx) {
      return idx === 0 ? "" : "".concat(idx);
    }
    function assertMethodIdxIsValid(idx) {
      if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
          // The stack trace will contain all the needed details
          "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
        );
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
    }
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var require_perf_tracer = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceTracer = void 0;
    var has_1 = __importDefault(require_has());
    var utils_1 = require_api();
    var parser_1 = require_parser2();
    var PerformanceTracer = (
      /** @class */
      (function() {
        function PerformanceTracer2() {
        }
        PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
          if ((0, has_1.default)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
          } else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
          }
          this.traceInitIndent = -1;
        };
        PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent2 = new Array(this.traceInitIndent + 1).join("	");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              console.log("".concat(indent2, "--> <").concat(phaseDesc, ">"));
            }
            var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              traceMethod("".concat(indent2, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
            }
            this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        return PerformanceTracer2;
      })()
    );
    exports2.PerformanceTracer = PerformanceTracer;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
var require_apply_mixins = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyMixins = void 0;
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
          if (propName === "constructor") {
            return;
          }
          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
          } else {
            derivedCtor.prototype[propName] = baseCtor.prototype[propName];
          }
        });
      });
    }
    exports2.applyMixins = applyMixins;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js
var require_parser2 = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var follow_1 = require_follow();
    var tokens_public_1 = require_tokens_public();
    var errors_public_1 = require_errors_public();
    var gast_resolver_public_1 = require_gast_resolver_public();
    var recoverable_1 = require_recoverable();
    var looksahead_1 = require_looksahead();
    var tree_builder_1 = require_tree_builder();
    var lexer_adapter_1 = require_lexer_adapter();
    var recognizer_api_1 = require_recognizer_api();
    var recognizer_engine_1 = require_recognizer_engine();
    var error_handler_1 = require_error_handler();
    var context_assist_1 = require_context_assist();
    var gast_recorder_1 = require_gast_recorder();
    var perf_tracer_1 = require_perf_tracer();
    var apply_mixins_1 = require_apply_mixins();
    var checks_1 = require_checks();
    exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(exports2.END_OF_FILE);
    exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: errors_public_1.defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    exports2.DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: function() {
        return void 0;
      },
      resyncEnabled: true
    });
    var ParserDefinitionErrorType2;
    (function(ParserDefinitionErrorType3) {
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
    })(ParserDefinitionErrorType2 = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
    function EMPTY_ALT2(value) {
      if (value === void 0) {
        value = void 0;
      }
      return function() {
        return value;
      };
    }
    exports2.EMPTY_ALT = EMPTY_ALT2;
    var Parser2 = (
      /** @class */
      (function() {
        function Parser3(tokenVocabulary, config) {
          this.definitionErrors = [];
          this.selfAnalysisDone = false;
          var that = this;
          that.initErrorHandler(config);
          that.initLexerAdapter();
          that.initLooksAhead(config);
          that.initRecognizerEngine(tokenVocabulary, config);
          that.initRecoverable(config);
          that.initTreeBuilder(config);
          that.initContentAssist();
          that.initGastRecorder(config);
          that.initPerformanceTracer(config);
          if ((0, has_1.default)(config, "ignoredIssues")) {
            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
          }
          this.skipValidations = (0, has_1.default)(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
        }
        Parser3.performSelfAnalysis = function(parserInstance) {
          throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
        };
        Parser3.prototype.performSelfAnalysis = function() {
          var _this = this;
          this.TRACE_INIT("performSelfAnalysis", function() {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function() {
              (0, utils_1.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function() {
              try {
                _this.enableRecording();
                (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                  var wrappedRule = _this[currRuleName];
                  var originalGrammarAction = wrappedRule["originalGrammarAction"];
                  var recordedRuleGast;
                  _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                    recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                  });
                  _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                });
              } finally {
                _this.disableRecording();
              }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function() {
              resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                rules: (0, values_1.default)(_this.gastProductionsCache)
              });
              _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
            });
            _this.TRACE_INIT("Grammar Validations", function() {
              if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                  grammarName: className
                });
                var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                  lookaheadStrategy: _this.lookaheadStrategy,
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  grammarName: className
                });
                _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
              }
            });
            if ((0, isEmpty_1.default)(_this.definitionErrors)) {
              if (_this.recoveryEnabled) {
                _this.TRACE_INIT("computeAllProdsFollows", function() {
                  var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                  _this.resyncFollows = allFollows;
                });
              }
              _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                var _a, _b;
                (_b = (_a = _this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
              });
            }
            if (!Parser3.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
              defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                return defError.message;
              });
              throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
            }
          });
        };
        Parser3.DEFER_DEFINITION_ERRORS_HANDLING = false;
        return Parser3;
      })()
    );
    exports2.Parser = Parser2;
    (0, apply_mixins_1.applyMixins)(Parser2, [
      recoverable_1.Recoverable,
      looksahead_1.LooksAhead,
      tree_builder_1.TreeBuilder,
      lexer_adapter_1.LexerAdapter,
      recognizer_engine_1.RecognizerEngine,
      recognizer_api_1.RecognizerApi,
      error_handler_1.ErrorHandler,
      context_assist_1.ContentAssist,
      gast_recorder_1.GastRecorder,
      perf_tracer_1.PerformanceTracer
    ]);
    var CstParser2 = (
      /** @class */
      (function(_super) {
        __extends(CstParser3, _super);
        function CstParser3(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = true;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return CstParser3;
      })(Parser2)
    );
    exports2.CstParser = CstParser2;
    var EmbeddedActionsParser2 = (
      /** @class */
      (function(_super) {
        __extends(EmbeddedActionsParser3, _super);
        function EmbeddedActionsParser3(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = false;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return EmbeddedActionsParser3;
      })(Parser2)
    );
    exports2.EmbeddedActionsParser = EmbeddedActionsParser2;
  }
});

// node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var require_model2 = __commonJS({
  "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildModel = void 0;
    var gast_1 = require_api2();
    var map_1 = __importDefault(require_map2());
    var flatten_1 = __importDefault(require_flatten());
    var values_1 = __importDefault(require_values());
    var some_1 = __importDefault(require_some());
    var groupBy_1 = __importDefault(require_groupBy());
    var assign_1 = __importDefault(require_assign());
    function buildModel(productions) {
      var generator = new CstNodeDefinitionGenerator();
      var allRules = (0, values_1.default)(productions);
      return (0, map_1.default)(allRules, function(rule) {
        return generator.visitRule(rule);
      });
    }
    exports2.buildModel = buildModel;
    var CstNodeDefinitionGenerator = (
      /** @class */
      (function(_super) {
        __extends(CstNodeDefinitionGenerator2, _super);
        function CstNodeDefinitionGenerator2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
          var rawElements = this.visitEach(node.definition);
          var grouped = (0, groupBy_1.default)(rawElements, function(el) {
            return el.propertyName;
          });
          var properties = (0, map_1.default)(grouped, function(group, propertyName) {
            var allNullable = !(0, some_1.default)(group, function(el) {
              return !el.canBeNull;
            });
            var propertyType = group[0].type;
            if (group.length > 1) {
              propertyType = (0, map_1.default)(group, function(g) {
                return g.type;
              });
            }
            return {
              name: propertyName,
              type: propertyType,
              optional: allNullable
            };
          });
          return {
            name: node.name,
            properties
          };
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
          return this.visitEach(node.definition);
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
          return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
          }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.terminalType.name,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.nonTerminalName,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
          return (0, map_1.default)(this.visitEach(definition), function(definition2) {
            return (0, assign_1.default)({}, definition2, override);
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
          var _this = this;
          return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
            return _this.visit(definition2);
          }));
        };
        return CstNodeDefinitionGenerator2;
      })(gast_1.GAstVisitor)
    );
    function getType(production) {
      if (production instanceof gast_1.NonTerminal) {
        return {
          kind: "rule",
          name: production.referencedRule.name
        };
      }
      return { kind: "token" };
    }
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module2.exports = castSlice;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var require_generate = __commonJS({
  "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genDts = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map2());
    var reduce_1 = __importDefault(require_reduce());
    var uniq_1 = __importDefault(require_uniq());
    var upperFirst_1 = __importDefault(require_upperFirst());
    function genDts(model, options) {
      var contentParts = [];
      contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
      contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
        return genCstNodeTypes(node);
      })));
      if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
      }
      return contentParts.join("\n\n") + "\n";
    }
    exports2.genDts = genDts;
    function genCstNodeTypes(node) {
      var nodeCstInterface = genNodeInterface(node);
      var nodeChildrenInterface = genNodeChildrenType(node);
      return [nodeCstInterface, nodeChildrenInterface];
    }
    function genNodeInterface(node) {
      var nodeInterfaceName = getNodeInterfaceName(node.name);
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
    }
    function genNodeChildrenType(node) {
      var typeName = getNodeChildrenTypeName(node.name);
      return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
        return genChildProperty(property);
      }).join("\n  "), "\n};");
    }
    function genChildProperty(prop) {
      var typeName = buildTypeString(prop.type);
      return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
    }
    function genVisitor(name, nodes) {
      return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
        return genVisitorFunction(node);
      }).join("\n  "), "\n}");
    }
    function genVisitorFunction(node) {
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
    }
    function buildTypeString(type) {
      if ((0, isArray_1.default)(type)) {
        var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t) {
          return getTypeString(t);
        }));
        var typeString = (0, reduce_1.default)(typeNames, function(sum, t) {
          return sum + " | " + t;
        });
        return "(" + typeString + ")";
      } else {
        return getTypeString(type);
      }
    }
    function getTypeString(type) {
      if (type.kind === "token") {
        return "IToken";
      }
      return getNodeInterfaceName(type.name);
    }
    function getNodeInterfaceName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstNode";
    }
    function getNodeChildrenTypeName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstChildren";
    }
  }
});

// node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var require_api3 = __commonJS({
  "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCstDts = void 0;
    var model_1 = require_model2();
    var generate_1 = require_generate();
    var defaultOptions = {
      includeVisitorInterface: true,
      visitorInterfaceName: "ICstNodeVisitor"
    };
    function generateCstDts2(productions, options) {
      var effectiveOptions = __assign(__assign({}, defaultOptions), options);
      var model = (0, model_1.buildModel)(productions);
      return (0, generate_1.genDts)(model, effectiveOptions);
    }
    exports2.generateCstDts = generateCstDts2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js
var require_render_public = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxDiagramsCode = void 0;
    var version_1 = require_version();
    function createSyntaxDiagramsCode2(grammar, _a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
      var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
      var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
      var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'></script>\n<script src='").concat(resourceBase, "src/main.js'></script>\n");
      var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
      var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n</script>\n");
      var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n';
      return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
    }
    exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode2;
  }
});

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js
var require_api4 = __commonJS({
  "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var parser_1 = require_parser2();
    Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
      return parser_1.CstParser;
    } });
    Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
      return parser_1.EmbeddedActionsParser;
    } });
    Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
      return parser_1.ParserDefinitionErrorType;
    } });
    Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
      return parser_1.EMPTY_ALT;
    } });
    var lexer_public_1 = require_lexer_public();
    Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
      return lexer_public_1.Lexer;
    } });
    Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
      return lexer_public_1.LexerDefinitionErrorType;
    } });
    var tokens_public_1 = require_tokens_public();
    Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
      return tokens_public_1.createToken;
    } });
    Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
      return tokens_public_1.createTokenInstance;
    } });
    Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
      return tokens_public_1.EOF;
    } });
    Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
      return tokens_public_1.tokenLabel;
    } });
    Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
      return tokens_public_1.tokenMatcher;
    } });
    Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
      return tokens_public_1.tokenName;
    } });
    var lookahead_1 = require_lookahead();
    Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
      return lookahead_1.getLookaheadPaths;
    } });
    var llk_lookahead_1 = require_llk_lookahead();
    Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
      return llk_lookahead_1.LLkLookaheadStrategy;
    } });
    var errors_public_1 = require_errors_public();
    Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
      return errors_public_1.defaultParserErrorProvider;
    } });
    var exceptions_public_1 = require_exceptions_public();
    Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
      return exceptions_public_1.EarlyExitException;
    } });
    Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
      return exceptions_public_1.isRecognitionException;
    } });
    Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
      return exceptions_public_1.MismatchedTokenException;
    } });
    Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
      return exceptions_public_1.NotAllInputParsedException;
    } });
    Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
      return exceptions_public_1.NoViableAltException;
    } });
    var lexer_errors_public_1 = require_lexer_errors_public();
    Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
      return lexer_errors_public_1.defaultLexerErrorProvider;
    } });
    var gast_1 = require_api2();
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return gast_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return gast_1.Alternative;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return gast_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return gast_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return gast_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return gast_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return gast_1.Terminal;
    } });
    var gast_2 = require_api2();
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return gast_2.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return gast_2.serializeProduction;
    } });
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return gast_2.GAstVisitor;
    } });
    var cst_dts_gen_1 = require_api3();
    Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
      return cst_dts_gen_1.generateCstDts;
    } });
    function clearCache2() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
    }
    exports2.clearCache = clearCache2;
    var render_public_1 = require_render_public();
    Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
      return render_public_1.createSyntaxDiagramsCode;
    } });
    var Parser2 = (
      /** @class */
      /* @__PURE__ */ (function() {
        function Parser3() {
          throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
        }
        return Parser3;
      })()
    );
    exports2.Parser = Parser2;
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class _InvalidFormatError extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, _InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format2(options = {}) {
        this.options = options;
      }
      Format2.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format2(opts);
      }
      createFormatWrap.Format = Format2;
      return createFormatWrap;
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = (function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    })();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map4, str) {
      var exploded = str.split("");
      exploded = exploded.map(map4);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map3 in colors.maps) {
      (function(map4) {
        colors[map4] = function(str) {
          return sequencer(colors.maps[map4], str);
        };
      })(map3);
    }
    var map3;
    defineProps(colors, init());
  }
});

// node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class _Colorizer {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        _Colorizer.allColors = Object.assign({}, _Colorizer.allColors || {}, nextColors);
        return _Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return _Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(_Colorizer.allColors[lookup])) {
          return colors[_Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = _Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[_Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/errors.js
var require_errors2 = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format2((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack) info.stack = einfo.stack;
        if (cause) info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error)) return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack) einfo.stack = err.stack;
      if (cause) einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class _Padder {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = _Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = _Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = _Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format2(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail2 = getStrictOption(options);
      if (fail2) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format2((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format2((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var ms = require_ms();
    module2.exports = format2((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format2 = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format2((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/.pnpm/fecha@4.2.3/node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/.pnpm/fecha@4.2.3/node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, (function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format2 = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse(dateStr, format3, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format3 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format3 = globalMasks[format3] || format3;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format3.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format: format2,
        parse,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign;
      exports3.default = fecha;
      exports3.format = format2;
      exports3.parse = parse;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    }));
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format2 = require_format();
    module2.exports = format2((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format2((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/.pnpm/logform@2.7.0/node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/.pnpm/logform@2.7.0/node_modules/logform/index.js"(exports2) {
    "use strict";
    var format2 = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format2, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors2();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format2 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format2("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format2("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.18.3",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.8",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.7.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.9.0"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.24.0",
        "@babel/preset-env": "^7.24.0",
        "@dabh/eslint-config-populist": "^4.4.0",
        "@types/node": "^20.11.24",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.57.0",
        hock: "^1.4.1",
        mocha: "^10.3.0",
        nyc: "^17.1.0",
        rimraf: "5.0.1",
        split2: "^4.1.0",
        "std-mocks": "^2.0.0",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "rimraf test/fixtures/logs/* && mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor2) {
      if (!(instance instanceof Constructor2)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor2, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor2.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor2, staticProps);
      Object.defineProperty(Constructor2, "prototype", { writable: false });
      return Constructor2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    })();
  }
});

// node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/modern.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log) this.log = options.log;
      if (options.logv) this.logv = options.logv;
      if (options.close) this.close = options.close;
      this.once("pipe", (logger3) => {
        this.levels = logger3.levels;
        this.parent = logger3;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState) throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i])) continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.forceConsole = options.forceConsole || false;
        this._consoleLog = console.log.bind(console);
        this._consoleWarn = console.warn.bind(console);
        this._consoleError = console.error.bind(console);
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleError(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleWarn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout && !this.forceConsole) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleLog(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray) return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/isArrayLike.js
var require_isArrayLike2 = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function") throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity) arity = asyncFn.length;
      if (!arity) throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err) return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done) return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done) return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled) return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2)) return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform();
    require_inherits()(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger3 = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter)) return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger3 = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace)) return true;
      }
      if (!async.length) return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn)) return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger3.apply(logger3, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force)) return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/.pnpm/@so-ric+colorspace@1.1.6/node_modules/@so-ric/colorspace/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/.pnpm/@so-ric+colorspace@1.1.6/node_modules/@so-ric/colorspace/dist/index.cjs.js"(exports2, module2) {
    "use strict";
    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (const name in cssKeywords) {
      if (Object.hasOwn(cssKeywords, name)) {
        reverseNames[cssKeywords[name]] = name;
      }
    }
    var cs = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      const prefix = string.slice(0, 3).toLowerCase();
      let value;
      let model;
      switch (prefix) {
        case "hsl": {
          value = cs.get.hsl(string);
          model = "hsl";
          break;
        }
        case "hwb": {
          value = cs.get.hwb(string);
          model = "hwb";
          break;
        }
        default: {
          value = cs.get.rgb(string);
          model = "rgb";
          break;
        }
      }
      if (!value) {
        return null;
      }
      return { model, value };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      const abbr = /^#([a-f\d]{3,4})$/i;
      const hex2 = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
      const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
      const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
      const keyword = /^(\w+)$/;
      let rgb = [0, 0, 0, 1];
      let match;
      let i;
      let hexAlpha;
      if (match = string.match(hex2)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          const i2 = i * 2;
          rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = Number.parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Number.parseInt(match[i + 1], 10);
        }
        if (match[4]) {
          rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!Object.hasOwn(cssKeywords, match[1])) {
          return null;
        }
        rgb = cssKeywords[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      const match = string.match(hsl);
      if (match) {
        const alpha = Number.parseFloat(match[4]);
        const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
        const s = clamp(Number.parseFloat(match[2]), 0, 100);
        const l = clamp(Number.parseFloat(match[3]), 0, 100);
        const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      const match = string.match(hwb);
      if (match) {
        const alpha = Number.parseFloat(match[4]);
        const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
        const w = clamp(Number.parseFloat(match[2]), 0, 100);
        const b = clamp(Number.parseFloat(match[3]), 0, 100);
        const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function(...rgba) {
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function(...rgba) {
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function(...rgba) {
      const r = Math.round(rgba[0] / 255 * 100);
      const g = Math.round(rgba[1] / 255 * 100);
      const b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function(...hsla) {
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function(...hwba) {
      let a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(...rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(number_, min, max) {
      return Math.min(Math.max(min, number_), max);
    }
    function hexDouble(number_) {
      const string_ = Math.round(number_).toString(16).toUpperCase();
      return string_.length < 2 ? "0" + string_ : string_;
    }
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
      lch: { channels: 3, labels: "lch" },
      oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var LAB_FT = (6 / 29) ** 3;
    function srgbNonlinearTransform(c) {
      const cc = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;
      return Math.min(Math.max(0, cc), 1);
    }
    function srgbNonlinearTransformInv(c) {
      return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;
    }
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      switch (max) {
        case min: {
          h = 0;
          break;
        }
        case r: {
          h = (g - b) / delta;
          break;
        }
        case g: {
          h = 2 + (b - r) / delta;
          break;
        }
        case b: {
          h = 4 + (r - g) / delta;
          break;
        }
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert$1.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        switch (v) {
          case r: {
            h = bdif - gdif;
            break;
          }
          case g: {
            h = 1 / 3 + rdif - bdif;
            break;
          }
          case b: {
            h = 2 / 3 + gdif - rdif;
            break;
          }
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert$1.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert$1.rgb.oklab = function(rgb) {
      const r = srgbNonlinearTransformInv(rgb[0] / 255);
      const g = srgbNonlinearTransformInv(rgb[1] / 255);
      const b = srgbNonlinearTransformInv(rgb[2] / 255);
      const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
      const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
      const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);
      const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
      const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
      const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
      return [l * 100, aa * 100, bb * 100];
    };
    convert$1.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Number.POSITIVE_INFINITY;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb) {
      const r = srgbNonlinearTransformInv(rgb[0] / 255);
      const g = srgbNonlinearTransformInv(rgb[1] / 255);
      const b = srgbNonlinearTransformInv(rgb[2] / 255);
      const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
      const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
      const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
      return [x * 100, y * 100, z * 100];
    };
    convert$1.rgb.lab = function(rgb) {
      const xyz = convert$1.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t3;
      let value;
      if (s === 0) {
        value = l * 255;
        return [value, value, value];
      }
      const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          value = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          value = t2;
        } else if (3 * t3 < 2) {
          value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          value = t1;
        }
        rgb[i] = value * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0: {
          return [v, t, p];
        }
        case 1: {
          return [q, v, p];
        }
        case 2: {
          return [p, v, t];
        }
        case 3: {
          return [p, q, v];
        }
        case 4: {
          return [t, p, v];
        }
        case 5: {
          return [v, p, q];
        }
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0: {
          r = v;
          g = n;
          b = wh;
          break;
        }
        case 1: {
          r = n;
          g = v;
          b = wh;
          break;
        }
        case 2: {
          r = wh;
          g = v;
          b = n;
          break;
        }
        case 3: {
          r = wh;
          g = n;
          b = v;
          break;
        }
        case 4: {
          r = n;
          g = wh;
          b = v;
          break;
        }
        case 5: {
          r = v;
          g = wh;
          b = n;
          break;
        }
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
      g = x * -0.969266 + y * 1.8760108 + z * 0.041556;
      b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
      r = srgbNonlinearTransform(r);
      g = srgbNonlinearTransform(g);
      b = srgbNonlinearTransform(b);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.xyz.oklab = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);
      const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);
      const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);
      const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
      const a = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
      const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
      return [l * 100, a * 100, b * 100];
    };
    convert$1.oklab.oklch = function(oklab) {
      return convert$1.lab.lch(oklab);
    };
    convert$1.oklab.xyz = function(oklab) {
      const ll = oklab[0] / 100;
      const a = oklab[1] / 100;
      const b = oklab[2] / 100;
      const l = (0.999999998 * ll + 0.396337792 * a + 0.215803758 * b) ** 3;
      const m = (1.000000008 * ll - 0.105561342 * a - 0.063854175 * b) ** 3;
      const s = (1.000000055 * ll - 0.089484182 * a - 1.291485538 * b) ** 3;
      const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s;
      const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s;
      const z = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s;
      return [x * 100, y * 100, z * 100];
    };
    convert$1.oklab.rgb = function(oklab) {
      const ll = oklab[0] / 100;
      const aa = oklab[1] / 100;
      const bb = oklab[2] / 100;
      const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
      const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
      const s = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
      const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s);
      const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s);
      const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.oklch.oklab = function(oklch) {
      return convert$1.lch.lab(oklch);
    };
    convert$1.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert$1.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert$1.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      args = args[0];
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (Math.trunc(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert$1.ansi256.rgb = function(args) {
      args = args[0];
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".slice(string.length) + string;
    };
    convert$1.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = [...colorString].map((char) => char + char).join("");
      }
      const integer = Number.parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert$1.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let hue;
      const grayscale = chroma < 1 ? min / (1 - chroma) : 0;
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0: {
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        }
        case 1: {
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        }
        case 2: {
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        }
        case 3: {
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        }
        case 4: {
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        }
        default: {
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
        }
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const value = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (value << 16) + (value << 8) + value;
      const string = integer.toString(16).toUpperCase();
      return "000000".slice(string.length) + string;
    };
    convert$1.rgb.gray = function(rgb) {
      const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [value / 255 * 100];
    };
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(convert$1);
      for (let { length } = models2, i = 0; i < length; i++) {
        graph[models2[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length > 0) {
        const current = queue.pop();
        const adjacents = Object.keys(convert$1[current]);
        for (let { length } = adjacents, i = 0; i < length; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = convert$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(convert$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    function route(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let { length } = models2, i = 0; i < length; i++) {
        const toModel = models2[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    }
    var convert = {};
    var models = Object.keys(convert$1);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let { length } = result, i = 0; i < length; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    for (const fromModel of models) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: convert$1[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: convert$1[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      for (const toModel of routeModels) {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      }
    }
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = cs.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(object[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          const limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in cs.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return cs.to[self2.model](...arguments_);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return cs.to.rgb.percent(...arguments_);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return cs.to.hex(...this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return cs.to.hex(...rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color.prototype[model] = function(...arguments_) {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments_.length > 0) {
          return new Color(arguments_, model);
        }
        return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...arguments_) {
        let color = arguments_[0];
        if (typeof color === "number") {
          color = zeroArray(arguments_, channels);
        }
        return new Color(color, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] ||= [])[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array, length) {
      for (let i = 0; i < length; i++) {
        if (typeof array[i] !== "number") {
          array[i] = 0;
        }
      }
      return array;
    }
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var textHex = function hex2(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash)) ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
    var hex = /* @__PURE__ */ getDefaultExportFromCjs(textHex);
    function colorspace(namespace, delimiter) {
      const split = namespace.split(delimiter || ":");
      let base = hex(split[0]);
      if (!split.length) return base;
      for (let i = 0, l = split.length - 1; i < l; i++) {
        base = Color(base).mix(Color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    }
    module2.exports = colorspace;
  }
});

// node_modules/.pnpm/kuler@2.0.0/node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/.pnpm/kuler@2.0.0/node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color) return new Kuler(text).style(color);
      if (!(this instanceof Kuler)) return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_index_cjs();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/.pnpm/enabled@2.0.0/node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/.pnpm/enabled@2.0.0/node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable) return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/@dabh+diagnostics@2.0.8/node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname) this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy) this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback) callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename) return;
        if (this._opening) return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (!this._stream.emit("rotate")) {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
          tasks.push(
            function(cb) {
              const num = this._created > 0 && !this.tailable ? this._created : "";
              this._compressFile(
                path.join(this.dirname, `${basename2}${num}${ext}`),
                path.join(this.dirname, `${basename2}${num}${ext}.gz`),
                cb
              );
            }.bind(this)
          );
        }
        tasks.push(
          function(cb) {
            if (!this.tailable) {
              this._created += 1;
              this._checkMaxFilesIncrementing(ext, basename2, cb);
            } else {
              this._checkMaxFilesTailable(ext, basename2, cb);
            }
          }.bind(this)
        );
        asyncSeries(tasks, callback);
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? `${basename2}${isRotation}${ext}` : `${basename2}${ext}`;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename2, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename2}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename2, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename2}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename2}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename2}${ext}${isZipped}`),
            path.join(this.dirname, `${basename2}1${ext}${isZipped}`),
            callback
          );
        });
      }
      /**
       * Compresses src to dest with gzip and unlinks src
       * @param {string} src - path to source file.
       * @param {string} dest - path to zipped destination file.
       * @param {Function} callback - callback called after file has been compressed.
       * @returns {undefined}
       * @private
       */
      _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, (err) => {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(src);
          var out = fs.createWriteStream(dest);
          out.on("finish", () => {
            fs.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var { configure } = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        const jsonStringify = configure({
          ...this.maximumDepth && { maximumDepth: this.maximumDepth }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/stream.js
var require_stream2 = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream2();
      }
    });
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true) return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/async@3.2.6/node_modules/async/forEach.js
var require_forEach2 = __commonJS({
  "node_modules/.pnpm/async@3.2.6/node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/fn.name@1.1.0/node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/.pnpm/fn.name@1.1.0/node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name) return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/.pnpm/one-time@1.0.0/node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/.pnpm/one-time@1.0.0/node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called) return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/.pnpm/stack-trace@0.0.10/node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/.pnpm/stack-trace@0.0.10/node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach2();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger3) {
        if (!logger3) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger3;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/rejection-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class RejectionStream extends Writable {
      /**
       * Constructor function for the RejectionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.rejection` set to true.
       * @param {!TransportStream} transport - Stream to filter to rejections
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `rejection` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach2();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var RejectionStream = require_rejection_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger3) {
        if (!logger3) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger3;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          rejection: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger3) {
        const Logger2 = require_logger();
        if (typeof logger3 !== "object" || Array.isArray(logger3) || !(logger3 instanceof Logger2)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger3;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform: Transform2 } = require_readable();
    var asyncForEach = require_forEach2();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger2 = class extends Transform2 {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger3 = this;
        return Object.create(logger3, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger3.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format: format2,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format2 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Helper method to get the highest logging level associated with a logger
       *
       * @returns { number | null } - The highest configured logging level, null
       * for invalid configuration
       */
      getHighestLogLevel() {
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue;
        }
        return this.transports.reduce((max, transport) => {
          const levelValue = getLevelValue(this.levels, transport.level);
          return levelValue !== null && levelValue > max ? levelValue : max;
        }, configuredLevelValue);
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message) info.message = `${info.message} ${meta.message}`;
            if (meta.stack) info.stack = meta.stack;
            if (meta.cause) info.cause = meta.cause;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished) return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport) return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger2.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger2;
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger2 = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger2 {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger3 = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger3;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger3;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger3).isLevelEnabled(level);
        };
      });
      return logger3;
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger2 = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger3 = createLogger2(options);
          logger3.on("close", () => this._delete(id));
          this.loggers.set(id, logger3);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger3 = this.loggers.get(id);
        logger3.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/.pnpm/winston@3.18.3/node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.Logger = require_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    Object.defineProperty(exports2, "rejections", {
      get() {
        return defaultLogger.rejections;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// node_modules/.pnpm/damerau-levenshtein@1.0.8/node_modules/damerau-levenshtein/index.js
var require_damerau_levenshtein = __commonJS({
  "node_modules/.pnpm/damerau-levenshtein@1.0.8/node_modules/damerau-levenshtein/index.js"(exports2, module2) {
    module2.exports = function(__this, that, limit) {
      var thisLength = __this.length, thatLength = that.length, matrix = [];
      limit = (limit || (thatLength > thisLength ? thatLength : thisLength)) + 1;
      for (var i = 0; i < limit; i++) {
        matrix[i] = [i];
        matrix[i].length = limit;
      }
      for (i = 0; i < limit; i++) {
        matrix[0][i] = i;
      }
      if (Math.abs(thisLength - thatLength) > (limit || 100)) {
        return prepare(limit || 100);
      }
      if (thisLength === 0) {
        return prepare(thatLength);
      }
      if (thatLength === 0) {
        return prepare(thisLength);
      }
      var j, this_i, that_j, cost, min, t;
      for (i = 1; i <= thisLength; ++i) {
        this_i = __this[i - 1];
        for (j = 1; j <= thatLength; ++j) {
          if (i === j && matrix[i][j] > 4) return prepare(thisLength);
          that_j = that[j - 1];
          cost = this_i === that_j ? 0 : 1;
          min = matrix[i - 1][j] + 1;
          if ((t = matrix[i][j - 1] + 1) < min) min = t;
          if ((t = matrix[i - 1][j - 1] + cost) < min) min = t;
          matrix[i][j] = i > 1 && j > 1 && this_i === that[j - 2] && __this[i - 2] === that_j && (t = matrix[i - 2][j - 2] + cost) < min ? t : min;
        }
      }
      return prepare(matrix[thisLength][thatLength]);
      function prepare(steps) {
        var length = Math.max(thisLength, thatLength);
        var relative = length === 0 ? 0 : steps / length;
        var similarity = 1 - relative;
        return {
          steps,
          relative,
          similarity
        };
      }
    };
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronField.js
var require_CronField = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronField.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronField = void 0;
    var CronField = class _CronField {
      #hasLastChar = false;
      #hasQuestionMarkChar = false;
      #wildcard = false;
      #values = [];
      options = { rawValue: "" };
      /**
       * Returns the minimum value allowed for this field.
       */
      /* istanbul ignore next */
      static get min() {
        throw new Error("min must be overridden");
      }
      /**
       * Returns the maximum value allowed for this field.
       */
      /* istanbul ignore next */
      static get max() {
        throw new Error("max must be overridden");
      }
      /**
       * Returns the allowed characters for this field.
       */
      /* istanbul ignore next */
      static get chars() {
        return Object.freeze([]);
      }
      /**
       * Returns the regular expression used to validate this field.
       */
      static get validChars() {
        return /^[?,*\dH/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
      }
      /**
       * Returns the constraints for this field.
       */
      static get constraints() {
        return { min: this.min, max: this.max, chars: this.chars, validChars: this.validChars };
      }
      /**
       * CronField constructor. Initializes the field with the provided values.
       * @param {number[] | string[]} values - Values for this field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       * @throws {TypeError} if the constructor is called directly
       * @throws {Error} if validation fails
       */
      constructor(values, options = { rawValue: "" }) {
        if (!Array.isArray(values)) {
          throw new Error(`${this.constructor.name} Validation error, values is not an array`);
        }
        if (!(values.length > 0)) {
          throw new Error(`${this.constructor.name} Validation error, values contains no values`);
        }
        this.options = {
          ...options,
          rawValue: options.rawValue ?? ""
        };
        this.#values = values.sort(_CronField.sorter);
        this.#wildcard = this.options.wildcard !== void 0 ? this.options.wildcard : this.#isWildcardValue();
        this.#hasLastChar = this.options.rawValue.includes("L") || values.includes("L");
        this.#hasQuestionMarkChar = this.options.rawValue.includes("?") || values.includes("?");
      }
      /**
       * Returns the minimum value allowed for this field.
       * @returns {number}
       */
      get min() {
        return this.constructor.min;
      }
      /**
       * Returns the maximum value allowed for this field.
       * @returns {number}
       */
      get max() {
        return this.constructor.max;
      }
      /**
       * Returns an array of allowed special characters for this field.
       * @returns {string[]}
       */
      get chars() {
        return this.constructor.chars;
      }
      /**
       * Indicates whether this field has a "last" character.
       * @returns {boolean}
       */
      get hasLastChar() {
        return this.#hasLastChar;
      }
      /**
       * Indicates whether this field has a "question mark" character.
       * @returns {boolean}
       */
      get hasQuestionMarkChar() {
        return this.#hasQuestionMarkChar;
      }
      /**
       * Indicates whether this field is a wildcard.
       * @returns {boolean}
       */
      get isWildcard() {
        return this.#wildcard;
      }
      /**
       * Returns an array of allowed values for this field.
       * @returns {CronFieldType}
       */
      get values() {
        return this.#values;
      }
      /**
       * Helper function to sort values in ascending order.
       * @param {number | string} a - First value to compare
       * @param {number | string} b - Second value to compare
       * @returns {number} - A negative, zero, or positive value, depending on the sort order
       */
      static sorter(a, b) {
        const aIsNumber = typeof a === "number";
        const bIsNumber = typeof b === "number";
        if (aIsNumber && bIsNumber)
          return a - b;
        if (!aIsNumber && !bIsNumber)
          return a.localeCompare(b);
        return aIsNumber ? (
          /* istanbul ignore next - A will always be a number until L-2 is supported */
          -1
        ) : 1;
      }
      /**
       * Serializes the field to an object.
       * @returns {SerializedCronField}
       */
      serialize() {
        return {
          wildcard: this.#wildcard,
          values: this.#values
        };
      }
      /**
       * Validates the field values against the allowed range and special characters.
       * @throws {Error} if validation fails
       */
      validate() {
        let badValue;
        const charsString = this.chars.length > 0 ? ` or chars ${this.chars.join("")}` : "";
        const charTest = (value) => (char) => new RegExp(`^\\d{0,2}${char}$`).test(value);
        const rangeTest = (value) => {
          badValue = value;
          return typeof value === "number" ? value >= this.min && value <= this.max : this.chars.some(charTest(value));
        };
        const isValidRange = this.#values.every(rangeTest);
        if (!isValidRange) {
          throw new Error(`${this.constructor.name} Validation error, got value ${badValue} expected range ${this.min}-${this.max}${charsString}`);
        }
        const duplicate = this.#values.find((value, index) => this.#values.indexOf(value) !== index);
        if (duplicate) {
          throw new Error(`${this.constructor.name} Validation error, duplicate values found: ${duplicate}`);
        }
      }
      /**
       * Determines if the field is a wildcard based on the values.
       * When options.rawValue is not empty, it checks if the raw value is a wildcard, otherwise it checks if all values in the range are included.
       * @returns {boolean}
       */
      #isWildcardValue() {
        if (this.options.rawValue.length > 0) {
          return ["*", "?"].includes(this.options.rawValue);
        }
        return Array.from({ length: this.max - this.min + 1 }, (_, i) => i + this.min).every((value) => this.#values.includes(value));
      }
    };
    exports2.CronField = CronField;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronDayOfMonth.js
var require_CronDayOfMonth = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronDayOfMonth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronDayOfMonth = void 0;
    var CronField_1 = require_CronField();
    var MIN_DAY = 1;
    var MAX_DAY = 31;
    var DAY_CHARS = Object.freeze(["L"]);
    var CronDayOfMonth = class extends CronField_1.CronField {
      static get min() {
        return MIN_DAY;
      }
      static get max() {
        return MAX_DAY;
      }
      static get chars() {
        return DAY_CHARS;
      }
      static get validChars() {
        return /^[?,*\dLH/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
      }
      /**
       * CronDayOfMonth constructor. Initializes the "day of the month" field with the provided values.
       * @param {DayOfMonthRange[]} values - Values for the "day of the month" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       * @throws {Error} if validation fails
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "day of the month" field.
       * @returns {DayOfMonthRange[]}
       */
      get values() {
        return super.values;
      }
    };
    exports2.CronDayOfMonth = CronDayOfMonth;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronDayOfWeek.js
var require_CronDayOfWeek = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronDayOfWeek.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronDayOfWeek = void 0;
    var CronField_1 = require_CronField();
    var MIN_DAY = 0;
    var MAX_DAY = 7;
    var DAY_CHARS = Object.freeze(["L"]);
    var CronDayOfWeek = class extends CronField_1.CronField {
      static get min() {
        return MIN_DAY;
      }
      static get max() {
        return MAX_DAY;
      }
      static get chars() {
        return DAY_CHARS;
      }
      static get validChars() {
        return /^[?,*\dLH#/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
      }
      /**
       * CronDayOfTheWeek constructor. Initializes the "day of the week" field with the provided values.
       * @param {DayOfWeekRange[]} values - Values for the "day of the week" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "day of the week" field.
       * @returns {DayOfWeekRange[]}
       */
      get values() {
        return super.values;
      }
      /**
       * Returns the nth day of the week if specified in the cron expression.
       * This is used for the '#' character in the cron expression.
       * @returns {number} The nth day of the week (1-5) or 0 if not specified.
       */
      get nthDay() {
        return this.options.nthDayOfWeek ?? 0;
      }
    };
    exports2.CronDayOfWeek = CronDayOfWeek;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronHour.js
var require_CronHour = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronHour.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronHour = void 0;
    var CronField_1 = require_CronField();
    var MIN_HOUR = 0;
    var MAX_HOUR = 23;
    var HOUR_CHARS = Object.freeze([]);
    var CronHour = class extends CronField_1.CronField {
      static get min() {
        return MIN_HOUR;
      }
      static get max() {
        return MAX_HOUR;
      }
      static get chars() {
        return HOUR_CHARS;
      }
      /**
       * CronHour constructor. Initializes the "hour" field with the provided values.
       * @param {HourRange[]} values - Values for the "hour" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "hour" field.
       * @returns {HourRange[]}
       */
      get values() {
        return super.values;
      }
    };
    exports2.CronHour = CronHour;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronMinute.js
var require_CronMinute = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronMinute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronMinute = void 0;
    var CronField_1 = require_CronField();
    var MIN_MINUTE = 0;
    var MAX_MINUTE = 59;
    var MINUTE_CHARS = Object.freeze([]);
    var CronMinute = class extends CronField_1.CronField {
      static get min() {
        return MIN_MINUTE;
      }
      static get max() {
        return MAX_MINUTE;
      }
      static get chars() {
        return MINUTE_CHARS;
      }
      /**
       * CronSecond constructor. Initializes the "second" field with the provided values.
       * @param {SixtyRange[]} values - Values for the "second" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "second" field.
       * @returns {SixtyRange[]}
       */
      get values() {
        return super.values;
      }
    };
    exports2.CronMinute = CronMinute;
  }
});

// node_modules/.pnpm/luxon@3.7.2/node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS({
  "node_modules/.pnpm/luxon@3.7.2/node_modules/luxon/build/node/luxon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The IANA name of this zone.
       * Defaults to `name` if not overwritten by a subclass.
       * @abstract
       * @type {string}
       */
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format2) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class _SystemZone extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new _SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, {
        format: format2,
        locale
      }) {
        return parseZoneInfo(ts, format2, locale);
      }
      /** @override **/
      formatOffset(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = /* @__PURE__ */ new Map();
    function makeDTF(zoneName) {
      let dtf = dtfCache.get(zoneName);
      if (dtf === void 0) {
        dtf = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zoneName,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
        dtfCache.set(zoneName, dtf);
      }
      return dtf;
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const {
          type,
          value
        } = formatted[i];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = /* @__PURE__ */ new Map();
    var IANAZone = class _IANAZone extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        let zone = ianaZoneCache.get(name);
        if (zone === void 0) {
          ianaZoneCache.set(name, zone = new _IANAZone(name));
        }
        return zone;
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache.clear();
        dtfCache.clear();
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
       * @return {boolean}
       */
      static isValidSpecifier(s2) {
        return this.isValidZone(s2);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = _IANAZone.isValidZone(name);
      }
      /**
       * The type of zone. `iana` for all instances of `IANAZone`.
       * @override
       * @type {string}
       */
      get type() {
        return "iana";
      }
      /**
       * The name of this zone (i.e. the IANA zone name).
       * @override
       * @type {string}
       */
      get name() {
        return this.zoneName;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year:
       * Always returns false for all IANA zones.
       * @override
       * @type {boolean}
       */
      get isUniversal() {
        return false;
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @override
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, {
        format: format2,
        locale
      }) {
        return parseZoneInfo(ts, format2, locale, this.name);
      }
      /**
       * Returns the offset's value as a string
       * @override
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format2) {
        return formatOffset(this.offset(ts), format2);
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @override
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        if (!this.valid) return NaN;
        const date = new Date(ts);
        if (isNaN(date)) return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /**
       * Return whether this Zone is equal to another zone
       * @override
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /**
       * Return whether this Zone is valid.
       * @override
       * @type {boolean}
       */
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = /* @__PURE__ */ new Map();
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache.get(key);
      if (dtf === void 0) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache.set(key, dtf);
      }
      return dtf;
    }
    var intlNumCache = /* @__PURE__ */ new Map();
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache.get(key);
      if (inf === void 0) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache.set(key, inf);
      }
      return inf;
    }
    var intlRelCache = /* @__PURE__ */ new Map();
    function getCachedRTF(locString, opts = {}) {
      const {
        base,
        ...cacheKeyOpts
      } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache.get(key);
      if (inf === void 0) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache.set(key, inf);
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    var intlResolvedOptionsCache = /* @__PURE__ */ new Map();
    function getCachedIntResolvedOptions(locString) {
      let opts = intlResolvedOptionsCache.get(locString);
      if (opts === void 0) {
        opts = new Intl.DateTimeFormat(locString).resolvedOptions();
        intlResolvedOptionsCache.set(locString, opts);
      }
      return opts;
    }
    var weekInfoCache = /* @__PURE__ */ new Map();
    function getCachedWeekInfo(locString) {
      let data = weekInfoCache.get(locString);
      if (!data) {
        const locale = new Intl.Locale(locString);
        data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
        if (!("minimalDays" in data)) {
          data = {
            ...fallbackWeekSettings,
            ...data
          };
        }
        weekInfoCache.set(locString, data);
      }
      return data;
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const {
          numberingSystem,
          calendar
        } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime.utc(2009, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || getCachedIntResolvedOptions(loc.locale).numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const {
          padTo,
          floor,
          ...otherOpts
        } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = {
            useGrouping: false,
            ...opts
          };
          if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
              minutes: dt.offset
            });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z = dt.zone.name;
        } else {
          z = "UTC";
          this.dt = dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
        const intlOpts = {
          ...this.opts
        };
        intlOpts.timeZone = intlOpts.timeZone || z;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({
            value
          }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = {
          style: "long",
          ...opts
        };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var fallbackWeekSettings = {
      firstDay: 1,
      minimalDays: 4,
      weekend: [6, 7]
    };
    var Locale = class _Locale {
      static fromOpts(opts) {
        return _Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
        return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache.clear();
        intlNumCache.clear();
        intlRelCache.clear();
        intlResolvedOptionsCache.clear();
        weekInfoCache.clear();
      }
      static fromObject({
        locale,
        numberingSystem,
        outputCalendar,
        weekSettings
      } = {}) {
        return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
      }
      constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.weekSettings = weekSettings;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return _Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({
          ...alts,
          defaultToEN: true
        });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({
          ...alts,
          defaultToEN: false
        });
      }
      months(length, format2 = false) {
        return listStuff(this, length, months, () => {
          const monthSpecialCase = this.intl === "ja" || this.intl.startsWith("ja-");
          format2 &= !monthSpecialCase;
          const intl = format2 ? {
            month: length,
            day: "numeric"
          } : {
            month: length
          }, formatStr = format2 ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            const mapper = !monthSpecialCase ? (dt) => this.extract(dt, intl, "month") : (dt) => this.dtFormatter(dt, intl).format();
            this.monthsCache[formatStr][length] = mapMonths(mapper);
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format2 = false) {
        return listStuff(this, length, weekdays, () => {
          const intl = format2 ? {
            weekday: length,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length
          }, formatStr = format2 ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff(this, void 0, () => meridiems, () => {
          if (!this.meridiemCache) {
            const intl = {
              hour: "numeric",
              hourCycle: "h12"
            };
            this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
          }
          return this.meridiemCache;
        });
      }
      eras(length) {
        return listStuff(this, length, eras, () => {
          const intl = {
            era: length
          };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
      }
      getWeekSettings() {
        if (this.weekSettings) {
          return this.weekSettings;
        } else if (!hasLocaleWeekInfo()) {
          return fallbackWeekSettings;
        } else {
          return getCachedWeekInfo(this.locale);
        }
      }
      getStartOfWeek() {
        return this.getWeekSettings().firstDay;
      }
      getMinDaysInFirstWeek() {
        return this.getWeekSettings().minimalDays;
      }
      getWeekendDays() {
        return this.getWeekSettings().weekend;
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
      toString() {
        return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class _FixedOffsetZone extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new _FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s2) {
        if (s2) {
          const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new _FixedOffsetZone(signedOffset(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /**
       * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
       * @override
       * @type {string}
       */
      get type() {
        return "fixed";
      }
      /**
       * The name of this zone.
       * All fixed zones' names always start with "UTC" (plus optional offset)
       * @override
       * @type {string}
       */
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      /**
       * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
       *
       * @override
       * @type {string}
       */
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /**
       * Returns the offset's common name at the specified timestamp.
       *
       * For fixed offset zones this equals to the zone name.
       * @override
       */
      offsetName() {
        return this.name;
      }
      /**
       * Returns the offset's value as a string
       * @override
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format2) {
        return formatOffset(this.fixed, format2);
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year:
       * Always returns true for all fixed offset zones.
       * @override
       * @type {boolean}
       */
      get isUniversal() {
        return true;
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       *
       * For fixed offset zones, this is constant and does not depend on a timestamp.
       * @override
       * @return {number}
       */
      offset() {
        return this.fixed;
      }
      /**
       * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
       * @override
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /**
       * Return whether this Zone is valid:
       * All fixed offset zones are valid.
       * @override
       * @type {boolean}
       */
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default") return defaultZone2;
        else if (lowered === "local" || lowered === "system") return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
        else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    var digitRegexCache = /* @__PURE__ */ new Map();
    function resetDigitRegexCache() {
      digitRegexCache.clear();
    }
    function digitRegex({
      numberingSystem
    }, append = "") {
      const ns = numberingSystem || "latn";
      let appendCache = digitRegexCache.get(ns);
      if (appendCache === void 0) {
        appendCache = /* @__PURE__ */ new Map();
        digitRegexCache.set(ns, appendCache);
      }
      let regex = appendCache.get(append);
      if (regex === void 0) {
        regex = new RegExp(`${numberingSystems[ns]}${append}`);
        appendCache.set(append, regex);
      }
      return regex;
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var defaultWeekSettings = null;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n2) {
        now = n2;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * @typedef {Object} WeekSettings
       * @property {number} firstDay
       * @property {number} minimalDays
       * @property {number[]} weekend
       */
      /**
       * @return {WeekSettings|null}
       */
      static get defaultWeekSettings() {
        return defaultWeekSettings;
      }
      /**
       * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
       * how many days are required in the first week of a year.
       * Does not affect existing instances.
       *
       * @param {WeekSettings|null} weekSettings
       */
      static set defaultWeekSettings(weekSettings) {
        defaultWeekSettings = validateWeekSettings(weekSettings);
      }
      /**
       * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
       * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
        DateTime.resetCache();
        resetDigitRegexCache();
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
    }
    function dayOfWeek(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day
      };
    }
    function isoWeekdayToLocal(isoWeekday, startOfWeek) {
      return (isoWeekday - startOfWeek + 7) % 7 + 1;
    }
    function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
      const {
        year,
        month,
        day
      } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
      let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
      } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return {
        weekYear,
        weekNumber,
        weekday,
        ...timeObject(gregObj)
      };
    }
    function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
      const {
        weekYear,
        weekNumber,
        weekday
      } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const {
        month,
        day
      } = uncomputeOrdinal(year, ordinal);
      return {
        year,
        month,
        day,
        ...timeObject(weekData)
      };
    }
    function gregorianToOrdinal(gregData) {
      const {
        year,
        month,
        day
      } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return {
        year,
        ordinal,
        ...timeObject(gregData)
      };
    }
    function ordinalToGregorian(ordinalData) {
      const {
        year,
        ordinal
      } = ordinalData;
      const {
        month,
        day
      } = uncomputeOrdinal(year, ordinal);
      return {
        year,
        month,
        day,
        ...timeObject(ordinalData)
      };
    }
    function usesLocalWeekValues(obj, loc) {
      const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
      if (hasLocaleWeekData) {
        const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
        if (hasIsoWeekData) {
          throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
        }
        if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
        if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
        if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
        delete obj.localWeekday;
        delete obj.localWeekNumber;
        delete obj.localWeekYear;
        return {
          minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
          startOfWeek: loc.getStartOfWeek()
        };
      } else {
        return {
          minDaysInFirstWeek: 4,
          startOfWeek: 1
        };
      }
    }
    function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.weekNumber);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else return false;
    }
    function hasInvalidTimeData(obj) {
      const {
        hour,
        minute,
        second,
        millisecond
      } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else return false;
    }
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function hasLocaleWeekInfo() {
      try {
        return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function validateWeekSettings(settings) {
      if (settings == null) {
        return null;
      } else if (typeof settings !== "object") {
        throw new InvalidArgumentError("Week settings must be an object");
      } else {
        if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
          throw new InvalidArgumentError("Invalid week settings");
        }
        return {
          firstDay: settings.firstDay,
          minimalDays: settings.minimalDays,
          weekend: Array.from(settings.weekend)
        };
      }
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, rounding = "round") {
      const factor = 10 ** digits;
      switch (rounding) {
        case "expand":
          return number > 0 ? Math.ceil(number * factor) / factor : Math.floor(number * factor) / factor;
        case "trunc":
          return Math.trunc(number * factor) / factor;
        case "round":
          return Math.round(number * factor) / factor;
        case "floor":
          return Math.floor(number * factor) / factor;
        case "ceil":
          return Math.ceil(number * factor) / factor;
        default:
          throw new RangeError(`Value rounding ${rounding} is out of range`);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d;
    }
    function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
      const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
      return -fwdlw + minDaysInFirstWeek - 1;
    }
    function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
      const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
      const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
      return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = {
        timeZoneName: offsetFormat,
        ...intlOpts
      };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || !Number.isFinite(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null) continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format2) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format2) {
        case "short":
          return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format2} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s2 = "";
      for (const token of splits) {
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class _Formatter {
      static create(locale, opts = {}) {
        return new _Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0 || bracketed) {
              splits.push({
                literal: bracketed || /^\s+$/.test(currentFull),
                val: currentFull === "" ? "'" : currentFull
              });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: /^\s+$/.test(currentFull),
                val: currentFull
              });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed || /^\s+$/.test(currentFull),
            val: currentFull
          });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, {
          ...this.opts,
          ...opts
        });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, {
          ...this.opts,
          ...opts
        });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n2, p = 0, signDisplay = void 0) {
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        const opts = {
          ...this.opts
        };
        if (p > 0) {
          opts.padTo = p;
        }
        if (signDisplay) {
          opts.signDisplay = signDisplay;
        }
        return this.loc.numberFormatter(opts).format(n2);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
          hour: "numeric",
          hourCycle: "h12"
        }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
          month: length
        } : {
          month: length,
          day: "numeric"
        }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
          weekday: length
        } : {
          weekday: length,
          month: "long",
          day: "numeric"
        }, "weekday"), maybeMacro = (token) => {
          const formatOpts = _Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({
          era: length
        }, "era"), tokenToString = (token) => {
          switch (token) {
            // ms
            case "S":
              return this.num(dt.millisecond);
            case "u":
            // falls through
            case "SSS":
              return this.num(dt.millisecond, 3);
            // seconds
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            // fractional seconds
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            // minutes
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            // hours
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            // offset
            case "Z":
              return formatOffset2({
                format: "narrow",
                allowZ: this.opts.allowZ
              });
            case "ZZ":
              return formatOffset2({
                format: "short",
                allowZ: this.opts.allowZ
              });
            case "ZZZ":
              return formatOffset2({
                format: "techie",
                allowZ: this.opts.allowZ
              });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: this.loc.locale
              });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: this.loc.locale
              });
            // zone
            case "z":
              return dt.zoneName;
            // meridiems
            case "a":
              return meridiem();
            // dates
            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : this.num(dt.day, 2);
            // weekdays - standalone
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            // weekdays - format
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            // months - standalone
            case "L":
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            // months - format
            case "M":
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            // years
            case "y":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : this.num(dt.year, 6);
            // eras
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "n":
              return this.num(dt.localWeekNumber);
            case "nn":
              return this.num(dt.localWeekNumber, 2);
            case "ii":
              return this.num(dt.localWeekYear.toString().slice(-2), 2);
            case "iiii":
              return this.num(dt.localWeekYear, 4);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const invertLargest = this.opts.signMode === "negativeLargestOnly" ? -1 : 1;
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "milliseconds";
            case "s":
              return "seconds";
            case "m":
              return "minutes";
            case "h":
              return "hours";
            case "d":
              return "days";
            case "w":
              return "weeks";
            case "M":
              return "months";
            case "y":
              return "years";
            default:
              return null;
          }
        }, tokenToString = (lildur, info) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            const inversionFactor = info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;
            let signDisplay;
            if (this.opts.signMode === "negativeLargestOnly" && mapped !== info.largestUnit) {
              signDisplay = "never";
            } else if (this.opts.signMode === "all") {
              signDisplay = "always";
            } else {
              signDisplay = "auto";
            }
            return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);
          } else {
            return token;
          }
        }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
          literal,
          val
        }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)), durationInfo = {
          isNegativeDuration: collapsed < 0,
          // this relies on "collapsed" being based on "shiftTo", which builds up the object
          // in order
          largestUnit: Object.keys(collapsed.values)[0]
        };
        return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f, r) => f + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
        const [val, zone, next] = ex(m, cursor);
        return [{
          ...mergedVals,
          ...val
        }, zone || mergedZone, next];
      }, [{}, null, 1]).slice(0, 2);
    }
    function parse(s2, ...patterns) {
      if (s2 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match2, pos, fallback) {
      const m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s2[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [{
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr) result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseISODate(s2) {
      return parse(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s2) {
      return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s2) {
      return parse(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s2) {
      return parse(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
      },
      seconds: {
        milliseconds: 1e3
      }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : {
          ...dur.values,
          ...alts.values || {}
        },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function durationToMillis(matrix, vals) {
      var _vals$milliseconds;
      let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
      for (const unit of reverseUnits.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues(matrix, vals) {
      const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class _Duration {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return _Duration.fromObject({
          milliseconds: count
        }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
        }
        return new _Duration({
          values: normalizeObject(obj, _Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber(durationLike)) {
          return _Duration.fromMillis(durationLike);
        } else if (_Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return _Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid2);
        } else {
          return new _Duration({
            invalid: invalid2
          });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized) throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat("d s", { signMode: "all" }) //=> "+6 +2"
       * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "all" }) //=> "-6 -2"
       * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "negativeLargestOnly" }) //=> "-6 2"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
       * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
       * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
       * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
       * @example
       * ```js
       * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
       * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid) return INVALID$2;
        const showZeros = opts.showZeros !== false;
        const l2 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val) || val === 0 && !showZeros) {
            return null;
          }
          return this.loc.numberFormatter({
            style: "unit",
            unitDisplay: "long",
            ...opts,
            unit: unit.slice(0, -1)
          }).format(val);
        }).filter((n2) => n2);
        return this.loc.listFormatter({
          type: "conjunction",
          style: opts.listStyle || "narrow",
          ...opts
        }).format(l2);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid) return {};
        return {
          ...this.values
        };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid) return null;
        let s2 = "P";
        if (this.years !== 0) s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0) s2 += this.weeks + "W";
        if (this.days !== 0) s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s2 += "T";
        if (this.hours !== 0) s2 += this.hours + "H";
        if (this.minutes !== 0) s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P") s2 += "T0S";
        return s2;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid) return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5) return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime.fromMillis(millis, {
          zone: "UTC"
        });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns a string representation of this Duration appropriate for the REPL.
       * @return {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        if (this.isValid) {
          return `Duration { values: ${JSON.stringify(this.values)} }`;
        } else {
          return `Duration { Invalid, reason: ${this.invalidReason} }`;
        }
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid) return NaN;
        return durationToMillis(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid) return this;
        const dur = _Duration.fromDurationLike(duration), result = {};
        for (const k of orderedUnits$1) {
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, {
          values: result
        }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid) return this;
        const dur = _Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid) return this;
        const result = {};
        for (const k of Object.keys(this.values)) {
          result[k] = asNumber(fn(this.values[k], k));
        }
        return clone$1(this, {
          values: result
        }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[_Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid) return this;
        const mixed = {
          ...this.values,
          ...normalizeObject(values, _Duration.normalizeUnit)
        };
        return clone$1(this, {
          values: mixed
        });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({
        locale,
        numberingSystem,
        conversionAccuracy,
        matrix
      } = {}) {
        const loc = this.loc.clone({
          locale,
          numberingSystem
        });
        const opts = {
          loc,
          matrix,
          conversionAccuracy
        };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see third example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid) return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, {
          values: vals
        }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid) return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, {
          values: vals
        }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid) return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => _Duration.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$1) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
          } else if (isNumber(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues(this.matrix, built);
        return clone$1(this, {
          values: built
        }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid) return this;
        return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid) return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, {
          values: negated
        }, true);
      }
      /**
       * Removes all units with values equal to 0 from this Duration.
       * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
       * @return {Duration}
       */
      removeZeros() {
        if (!this.isValid) return this;
        const vals = removeZeroes(this.values);
        return clone$1(this, {
          values: vals
        }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$1) {
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
      } else {
        return null;
      }
    }
    var Interval = class _Interval {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid2);
        } else {
          return new _Interval({
            invalid: invalid2
          });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new _Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return _Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return _Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s2, e] = (text || "").split("/", 2);
        if (s2 && e) {
          let start, startIsValid;
          try {
            start = DateTime.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return _Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return _Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s2, opts);
            if (dur.isValid) {
              return _Interval.before(end, dur);
            }
          }
        }
        return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval. This is the first instant which is not part of the interval
       * (Interval is half-open).
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns the last DateTime included in the interval (since end is not part of the interval)
       * @type {DateTime}
       */
      get lastDateTime() {
        return this.isValid ? this.e ? this.e.minus(1) : null : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @param {Object} opts - options
       * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
       * @return {number}
       */
      count(unit = "milliseconds", opts) {
        if (!this.isValid) return NaN;
        const start = this.start.startOf(unit, opts);
        let end;
        if (opts != null && opts.useLocaleWeeks) {
          end = this.end.reconfigure({
            locale: start.locale
          });
        } else {
          end = this.end;
        }
        end = end.startOf(unit, opts);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid) return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid) return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid) return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({
        start,
        end
      } = {}) {
        if (!this.isValid) return this;
        return _Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid) return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
        let {
          s: s2
        } = this, i = 0;
        while (s2 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let {
          s: s2
        } = this, idx = 1, next;
        const results = [];
        while (s2 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid) return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid) return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid) return false;
        return +other.e === +this.s;
      }
      /**
       * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid) return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid) return this;
        const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return _Interval.fromDateTimes(s2, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid) return this;
        const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return _Interval.fromDateTimes(s2, e);
      }
      /**
       * Merge an array of Intervals into an equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
       * and ending with the latest.
       *
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]);
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [{
          time: i.s,
          type: "s"
        }, {
          time: i.e,
          type: "e"
        }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(_Interval.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return _Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid) return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a string representation of this Interval appropriate for the REPL.
       * @return {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        if (this.isValid) {
          return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
        } else {
          return `Interval { Invalid, reason: ${this.invalidReason} }`;
        }
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid) return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid) return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid) return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, {
        separator = " \u2013 "
      } = {}) {
        if (!this.isValid) return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime.now().setZone(zone).set({
          month: 12
        });
        return !zone.isUniversal && proto.offset !== proto.set({
          month: 6
        }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Get the weekday on which the week starts according to the given locale.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
       */
      static getStartOfWeek({
        locale = null,
        locObj = null
      } = {}) {
        return (locObj || Locale.create(locale)).getStartOfWeek();
      }
      /**
       * Get the minimum number of days necessary in a week before it is considered part of the next year according
       * to the given locale.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @returns {number}
       */
      static getMinimumDaysInFirstWeek({
        locale = null,
        locObj = null
      } = {}) {
        return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
      }
      /**
       * Get the weekdays, which are considered the weekend according to the given locale
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
       */
      static getWeekendWeekdays({
        locale = null,
        locObj = null
      } = {}) {
        return (locObj || Locale.create(locale)).getWeekendDays().slice();
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      static months(length = "long", {
        locale = null,
        numberingSystem = null,
        locObj = null,
        outputCalendar = "gregory"
      } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", {
        locale = null,
        numberingSystem = null,
        locObj = null,
        outputCalendar = "gregory"
      } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      static weekdays(length = "long", {
        locale = null,
        numberingSystem = null,
        locObj = null
      } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", {
        locale = null,
        numberingSystem = null,
        locObj = null
      } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      static meridiems({
        locale = null
      } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", {
        locale = null
      } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
       * @example Info.features() //=> { relative: false, localeWeek: true }
       * @return {Object}
       */
      static features() {
        return {
          relative: hasRelative(),
          localeWeek: hasLocaleWeekInfo()
        };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, {
        keepLocalTime: true
      }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({
            [lowestOrder]: 1
          });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i) => i) {
      return {
        regex,
        deser: ([s2]) => post(parseDigits(s2))
      };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return {
        regex,
        deser: ([, h, m]) => signedOffset(h, m),
        groups
      };
    }
    function simple(regex) {
      return {
        regex,
        deser: ([s2]) => s2
      };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({
        regex: RegExp(escapeToken(t.val)),
        deser: ([s2]) => s2,
        literal: true
      }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          // era
          case "G":
            return oneOf(loc.eras("short"), 0);
          case "GG":
            return oneOf(loc.eras("long"), 0);
          // years
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          // months
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true), 1);
          case "MMMM":
            return oneOf(loc.months("long", true), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false), 1);
          // dates
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          // ordinals
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          // time
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          // meridiem
          case "a":
            return oneOf(loc.meridiems(), 0);
          // weekYear (k)
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          // weekNumber (W)
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          // weekdays
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true), 1);
          // offset/zone
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
          // because we don't have any way to figure out what they are
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          // this special-case "token" represents a place where a macro-token expanded into a white-space literal
          // in this case we accept any non-newline white-space
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts, resolvedOpts) {
      const {
        type,
        value
      } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
    }
    var TokenParser = class {
      constructor(locale, format2) {
        this.locale = locale;
        this.format = format2;
        this.tokens = expandMacroTokens(Formatter.parseFormat(format2), locale);
        this.units = this.tokens.map((t) => unitForToken(t, locale));
        this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
        if (!this.disqualifyingUnit) {
          const [regexString, handlers] = buildRegex(this.units);
          this.regex = RegExp(regexString, "i");
          this.handlers = handlers;
        }
      }
      explainFromTokens(input) {
        if (!this.isValid) {
          return {
            input,
            tokens: this.tokens,
            invalidReason: this.invalidReason
          };
        } else {
          const [rawMatches, matches] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
          if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
            throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
          }
          return {
            input,
            tokens: this.tokens,
            regex: this.regex,
            rawMatches,
            matches,
            result,
            zone,
            specificOffset
          };
        }
      }
      get isValid() {
        return !this.disqualifyingUnit;
      }
      get invalidReason() {
        return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
      }
    };
    function explainFromTokens(locale, input, format2) {
      const parser = new TokenParser(locale, format2);
      return parser.explainFromTokens(input);
    }
    function parseFromTokens(locale, input, format2) {
      const {
        result,
        zone,
        specificOffset,
        invalidReason
      } = explainFromTokens(locale, input, format2);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function possiblyCachedLocalWeekData(dt) {
      if (dt.localWeekData === null) {
        dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
      }
      return dt.localWeekData;
    }
    function clone(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime({
        ...current,
        ...alts,
        old: current
      });
    }
    function fixOffset(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      let [ts, o] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return {
        ts,
        o
      };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format2, text, specificOffset) {
      const {
        setZone,
        zone
      } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format2}`));
      }
    }
    function toTechFormat(dt, format2, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format2) : null;
    }
    function toISODate(o, extended, precision) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0) c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);
      if (precision === "year") return c;
      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        if (precision === "month") return c;
        c += "-";
      } else {
        c += padStart(o.c.month);
        if (precision === "month") return c;
      }
      c += padStart(o.c.day);
      return c;
    }
    function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision) {
      let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0, c = "";
      switch (precision) {
        case "day":
        case "month":
        case "year":
          break;
        default:
          c += padStart(o.c.hour);
          if (precision === "hour") break;
          if (extended) {
            c += ":";
            c += padStart(o.c.minute);
            if (precision === "minute") break;
            if (showSeconds) {
              c += ":";
              c += padStart(o.c.second);
            }
          } else {
            c += padStart(o.c.minute);
            if (precision === "minute") break;
            if (showSeconds) {
              c += padStart(o.c.second);
            }
          }
          if (precision === "second") break;
          if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {
            c += ".";
            c += padStart(o.c.millisecond, 3);
          }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized) throw new InvalidUnitError(unit);
      return normalized;
    }
    function normalizeUnitWithLocalWeeks(unit) {
      switch (unit.toLowerCase()) {
        case "localweekday":
        case "localweekdays":
          return "localWeekday";
        case "localweeknumber":
        case "localweeknumbers":
          return "localWeekNumber";
        case "localweekyear":
        case "localweekyears":
          return "localWeekYear";
        default:
          return normalizeUnit(unit);
      }
    }
    function guessOffsetForZone(zone) {
      if (zoneOffsetTs === void 0) {
        zoneOffsetTs = Settings.now();
      }
      if (zone.type !== "iana") {
        return zone.offset(zoneOffsetTs);
      }
      const zoneName = zone.name;
      let offsetGuess = zoneOffsetGuessCache.get(zoneName);
      if (offsetGuess === void 0) {
        offsetGuess = zone.offset(zoneOffsetTs);
        zoneOffsetGuessCache.set(zoneName, offsetGuess);
      }
      return offsetGuess;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      }
      const loc = Locale.fromObject(opts);
      let ts, o;
      if (!isUndefined(obj.year)) {
        for (const u of orderedUnits) {
          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        const invalid2 = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid2) {
          return DateTime.invalid(invalid2);
        }
        const offsetProvis = guessOffsetForZone(zone);
        [ts, o] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = Settings.now();
      }
      return new DateTime({
        ts,
        zone,
        loc,
        o
      });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, rounding = isUndefined(opts.rounding) ? "trunc" : opts.rounding, format2 = (c, unit) => {
        c = roundTo(c, round || opts.calendary ? 0 : 2, opts.calendary ? "round" : rounding);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format2(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format2(count, unit);
        }
      }
      return format2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var zoneOffsetTs;
    var zoneOffsetGuessCache = /* @__PURE__ */ new Map();
    var DateTime = class _DateTime {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings.defaultZone;
        let invalid2 = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        let c = null, o = null;
        if (!invalid2) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid2 = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid2 ? null : c;
            o = invalid2 ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid2;
        this.weekData = null;
        this.localWeekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new _DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return _DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone(zoneToUse));
        }
        return new _DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber(milliseconds)) {
          throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return _DateTime.invalid("Timestamp out of range");
        } else {
          return new _DateTime({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new _DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.localWeekYear - a week year, according to the locale
       * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
       * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone(zoneToUse));
        }
        const loc = Locale.fromObject(opts);
        const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
        const {
          minDaysInFirstWeek,
          startOfWeek
        } = usesLocalWeekValues(normalized, loc);
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid2 = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid2) {
          return _DateTime.invalid(invalid2);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return _DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
        }
        if (!inst.isValid) {
          return _DateTime.invalid(inst.invalid);
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const {
          locale = null,
          numberingSystem = null
        } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid2] = parseFromTokens(localeToUse, text, fmt);
        if (invalid2) {
          return _DateTime.invalid(invalid2);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return _DateTime.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid2);
        } else {
          return new _DateTime({
            invalid: invalid2
          });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      static resetCache() {
        zoneOffsetTs = void 0;
        zoneOffsetGuessCache.clear();
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Returns true if this date is on a weekend according to the locale, false otherwise
       * @returns {boolean}
       */
      get isWeekend() {
        return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
      }
      /**
       * Get the day of the week according to the locale.
       * 1 is the first day of the week and 7 is the last day of the week.
       * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
       * @returns {number}
       */
      get localWeekday() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
      }
      /**
       * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
       * because the week can start on different days of the week (see localWeekday) and because a different number of days
       * is required for a week to count as the first week of a year.
       * @returns {number}
       */
      get localWeekNumber() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
       * differently, see localWeekNumber.
       * @returns {number}
       */
      get localWeekYear() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", {
          locObj: this.loc
        })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", {
          locObj: this.loc
        })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", {
          locObj: this.loc
        })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", {
          locObj: this.loc
        })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({
            month: 1,
            day: 1
          }).offset || this.offset > this.set({
            month: 5
          }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj(ts1, o1);
        const c2 = tsToObj(ts2, o2);
        if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
          return [clone(this, {
            ts: ts1
          }), clone(this, {
            ts: ts2
          })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's local week year
       * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
       * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
       * @type {number}
       */
      get weeksInLocalWeekYear() {
        return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const {
          locale,
          numberingSystem,
          calendar
        } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
        return {
          locale,
          numberingSystem,
          outputCalendar: calendar
        };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, {
        keepLocalTime = false,
        keepCalendarTime = false
      } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return _DateTime.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone(this, {
            ts: newTS,
            zone
          });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({
        locale,
        numberingSystem,
        outputCalendar
      } = {}) {
        const loc = this.loc.clone({
          locale,
          numberingSystem,
          outputCalendar
        });
        return clone(this, {
          loc
        });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({
          locale
        });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       *
       * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
       * They cannot be mixed with ISO-week units like `weekday`.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid) return this;
        const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
        const {
          minDaysInFirstWeek,
          startOfWeek
        } = usesLocalWeekValues(normalized, this.loc);
        const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({
            ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
            ...normalized
          }, minDaysInFirstWeek, startOfWeek);
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({
            ...gregorianToOrdinal(this.c),
            ...normalized
          });
        } else {
          mixed = {
            ...this.toObject(),
            ...normalized
          };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS(mixed, this.o, this.zone);
        return clone(this, {
          ts,
          o
        });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid) return this;
        const dur = Duration.fromDurationLike(duration);
        return clone(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid) return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @param {Object} opts - options
       * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit, {
        useLocaleWeeks = false
      } = {}) {
        if (!this.isValid) return this;
        const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          // falls through
          case "quarters":
          case "months":
            o.day = 1;
          // falls through
          case "weeks":
          case "days":
            o.hour = 0;
          // falls through
          case "hours":
            o.minute = 0;
          // falls through
          case "minutes":
            o.second = 0;
          // falls through
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          if (useLocaleWeeks) {
            const startOfWeek = this.loc.getStartOfWeek();
            const {
              weekday
            } = this;
            if (weekday < startOfWeek) {
              o.weekNumber = this.weekNumber - 1;
            }
            o.weekday = startOfWeek;
          } else {
            o.weekday = 1;
          }
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @param {Object} opts - options
       * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit, opts) {
        return this.isValid ? this.plus({
          [unit]: 1
        }).startOf(unit, opts).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'
       * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'
       * @return {string|null}
       */
      toISO({
        format: format2 = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false,
        precision = "milliseconds"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        precision = normalizeUnit(precision);
        const ext = format2 === "extended";
        let c = toISODate(this, ext, precision);
        if (orderedUnits.indexOf(precision) >= 3) c += "T";
        c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'
       * @return {string|null}
       */
      toISODate({
        format: format2 = "extended",
        precision = "day"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format2 === "extended", normalizeUnit(precision));
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format: format2 = "extended",
        precision = "milliseconds"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        precision = normalizeUnit(precision);
        let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? "T" : "";
        return c + toISOTime(this, format2 === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision);
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string|null}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({
        includeOffset = true,
        includeZone = false,
        includeOffsetSpace = true
      } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns a string representation of this DateTime appropriate for the REPL.
       * @return {string}
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        if (this.isValid) {
          return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
        } else {
          return `DateTime { Invalid, reason: ${this.invalidReason} }`;
        }
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid) return {};
        const base = {
          ...this.c
        };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = {
          locale: this.locale,
          numberingSystem: this.numberingSystem,
          ...opts
        };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(_DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval|DateTime}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @param {Object} opts - options
       * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit, opts) {
        if (!this.isValid) return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {string} [options.rounding="trunc"] - rounding method to use when rounding the numbers in the output. Can be "trunc" (toward zero), "expand" (away from zero), "round", "floor", or "ceil".
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid) return null;
        const base = options.base || _DateTime.fromObject({}, {
          zone: this.zone
        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid) return null;
        return diffRelative(options.base || _DateTime.fromObject({}, {
          zone: this.zone
        }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const {
          locale = null,
          numberingSystem = null
        } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return _DateTime.fromFormatExplain(text, fmt, options);
      }
      /**
       * Build a parser for `fmt` using the given locale. This parser can be passed
       * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
       * can be used to optimize cases where many dates need to be parsed in a
       * specific format.
       *
       * @param {String} fmt - the format the string is expected to be in (see
       * description)
       * @param {Object} options - options used to set locale and numberingSystem
       * for parser
       * @returns {TokenParser} - opaque object to be used
       */
      static buildFormatParser(fmt, options = {}) {
        const {
          locale = null,
          numberingSystem = null
        } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return new TokenParser(localeToUse, fmt);
      }
      /**
       * Create a DateTime from an input string and format parser.
       *
       * The format parser must have been created with the same locale as this call.
       *
       * @param {String} text - the string to parse
       * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
       * @param {Object} opts - options taken by fromFormat()
       * @returns {DateTime}
       */
      static fromFormatParser(text, formatParser, opts = {}) {
        if (isUndefined(text) || isUndefined(formatParser)) {
          throw new InvalidArgumentError("fromFormatParser requires an input string and a format parser");
        }
        const {
          locale = null,
          numberingSystem = null
        } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        if (!localeToUse.equals(formatParser.locale)) {
          throw new InvalidArgumentError(`fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`);
        }
        const {
          result,
          zone,
          specificOffset,
          invalidReason
        } = formatParser.explainFromTokens(text);
        if (invalidReason) {
          return _DateTime.invalid(invalidReason);
        } else {
          return parseDataToDateTime(result, zone, opts, `format ${formatParser.format}`, text, specificOffset);
        }
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
      }
    }
    var VERSION2 = "3.7.2";
    exports2.DateTime = DateTime;
    exports2.Duration = Duration;
    exports2.FixedOffsetZone = FixedOffsetZone;
    exports2.IANAZone = IANAZone;
    exports2.Info = Info;
    exports2.Interval = Interval;
    exports2.InvalidZone = InvalidZone;
    exports2.Settings = Settings;
    exports2.SystemZone = SystemZone;
    exports2.VERSION = VERSION2;
    exports2.Zone = Zone;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronDate.js
var require_CronDate = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronDate = exports2.DAYS_IN_MONTH = exports2.DateMathOp = exports2.TimeUnit = void 0;
    var luxon_1 = require_luxon();
    var TimeUnit;
    (function(TimeUnit2) {
      TimeUnit2["Second"] = "Second";
      TimeUnit2["Minute"] = "Minute";
      TimeUnit2["Hour"] = "Hour";
      TimeUnit2["Day"] = "Day";
      TimeUnit2["Month"] = "Month";
      TimeUnit2["Year"] = "Year";
    })(TimeUnit || (exports2.TimeUnit = TimeUnit = {}));
    var DateMathOp;
    (function(DateMathOp2) {
      DateMathOp2["Add"] = "Add";
      DateMathOp2["Subtract"] = "Subtract";
    })(DateMathOp || (exports2.DateMathOp = DateMathOp = {}));
    exports2.DAYS_IN_MONTH = Object.freeze([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]);
    var CronDate = class _CronDate {
      #date;
      #dstStart = null;
      #dstEnd = null;
      /**
       * Maps the verb to the appropriate method
       */
      #verbMap = {
        add: {
          [TimeUnit.Year]: this.addYear.bind(this),
          [TimeUnit.Month]: this.addMonth.bind(this),
          [TimeUnit.Day]: this.addDay.bind(this),
          [TimeUnit.Hour]: this.addHour.bind(this),
          [TimeUnit.Minute]: this.addMinute.bind(this),
          [TimeUnit.Second]: this.addSecond.bind(this)
        },
        subtract: {
          [TimeUnit.Year]: this.subtractYear.bind(this),
          [TimeUnit.Month]: this.subtractMonth.bind(this),
          [TimeUnit.Day]: this.subtractDay.bind(this),
          [TimeUnit.Hour]: this.subtractHour.bind(this),
          [TimeUnit.Minute]: this.subtractMinute.bind(this),
          [TimeUnit.Second]: this.subtractSecond.bind(this)
        }
      };
      /**
       * Constructs a new CronDate instance.
       * @param {CronDate | Date | number | string} [timestamp] - The timestamp to initialize the CronDate with.
       * @param {string} [tz] - The timezone to use for the CronDate.
       */
      constructor(timestamp, tz) {
        const dateOpts = { zone: tz };
        if (!timestamp) {
          this.#date = luxon_1.DateTime.local();
        } else if (timestamp instanceof _CronDate) {
          this.#date = timestamp.#date;
          this.#dstStart = timestamp.#dstStart;
          this.#dstEnd = timestamp.#dstEnd;
        } else if (timestamp instanceof Date) {
          this.#date = luxon_1.DateTime.fromJSDate(timestamp, dateOpts);
        } else if (typeof timestamp === "number") {
          this.#date = luxon_1.DateTime.fromMillis(timestamp, dateOpts);
        } else {
          this.#date = luxon_1.DateTime.fromISO(timestamp, dateOpts);
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromRFC2822(timestamp, dateOpts));
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromSQL(timestamp, dateOpts));
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromFormat(timestamp, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
        }
        if (!this.#date.isValid) {
          throw new Error(`CronDate: unhandled timestamp: ${timestamp}`);
        }
        if (tz && tz !== this.#date.zoneName) {
          this.#date = this.#date.setZone(tz);
        }
      }
      /**
       * Determines if the given year is a leap year.
       * @param {number} year - The year to check
       * @returns {boolean} - True if the year is a leap year, false otherwise
       * @private
       */
      static #isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      /**
       * Returns daylight savings start time.
       * @returns {number | null}
       */
      get dstStart() {
        return this.#dstStart;
      }
      /**
       * Sets daylight savings start time.
       * @param {number | null} value
       */
      set dstStart(value) {
        this.#dstStart = value;
      }
      /**
       * Returns daylight savings end time.
       * @returns {number | null}
       */
      get dstEnd() {
        return this.#dstEnd;
      }
      /**
       * Sets daylight savings end time.
       * @param {number | null} value
       */
      set dstEnd(value) {
        this.#dstEnd = value;
      }
      /**
       * Adds one year to the current CronDate.
       */
      addYear() {
        this.#date = this.#date.plus({ years: 1 });
      }
      /**
       * Adds one month to the current CronDate.
       */
      addMonth() {
        this.#date = this.#date.plus({ months: 1 }).startOf("month");
      }
      /**
       * Adds one day to the current CronDate.
       */
      addDay() {
        this.#date = this.#date.plus({ days: 1 }).startOf("day");
      }
      /**
       * Adds one hour to the current CronDate.
       */
      addHour() {
        this.#date = this.#date.plus({ hours: 1 }).startOf("hour");
      }
      /**
       * Adds one minute to the current CronDate.
       */
      addMinute() {
        this.#date = this.#date.plus({ minutes: 1 }).startOf("minute");
      }
      /**
       * Adds one second to the current CronDate.
       */
      addSecond() {
        this.#date = this.#date.plus({ seconds: 1 });
      }
      /**
       * Subtracts one year from the current CronDate.
       */
      subtractYear() {
        this.#date = this.#date.minus({ years: 1 });
      }
      /**
       * Subtracts one month from the current CronDate.
       * If the month is 1, it will subtract one year instead.
       */
      subtractMonth() {
        this.#date = this.#date.minus({ months: 1 }).endOf("month").startOf("second");
      }
      /**
       * Subtracts one day from the current CronDate.
       * If the day is 1, it will subtract one month instead.
       */
      subtractDay() {
        this.#date = this.#date.minus({ days: 1 }).endOf("day").startOf("second");
      }
      /**
       * Subtracts one hour from the current CronDate.
       * If the hour is 0, it will subtract one day instead.
       */
      subtractHour() {
        this.#date = this.#date.minus({ hours: 1 }).endOf("hour").startOf("second");
      }
      /**
       * Subtracts one minute from the current CronDate.
       * If the minute is 0, it will subtract one hour instead.
       */
      subtractMinute() {
        this.#date = this.#date.minus({ minutes: 1 }).endOf("minute").startOf("second");
      }
      /**
       * Subtracts one second from the current CronDate.
       * If the second is 0, it will subtract one minute instead.
       */
      subtractSecond() {
        this.#date = this.#date.minus({ seconds: 1 });
      }
      /**
       * Adds a unit of time to the current CronDate.
       * @param {TimeUnit} unit
       */
      addUnit(unit) {
        this.#verbMap.add[unit]();
      }
      /**
       * Subtracts a unit of time from the current CronDate.
       * @param {TimeUnit} unit
       */
      subtractUnit(unit) {
        this.#verbMap.subtract[unit]();
      }
      /**
       * Handles a math operation.
       * @param {DateMathOp} verb - {'add' | 'subtract'}
       * @param {TimeUnit} unit - {'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'}
       */
      invokeDateOperation(verb, unit) {
        if (verb === DateMathOp.Add) {
          this.addUnit(unit);
          return;
        }
        if (verb === DateMathOp.Subtract) {
          this.subtractUnit(unit);
          return;
        }
        throw new Error(`Invalid verb: ${verb}`);
      }
      /**
       * Returns the day.
       * @returns {number}
       */
      getDate() {
        return this.#date.day;
      }
      /**
       * Returns the year.
       * @returns {number}
       */
      getFullYear() {
        return this.#date.year;
      }
      /**
       * Returns the day of the week.
       * @returns {number}
       */
      getDay() {
        const weekday = this.#date.weekday;
        return weekday === 7 ? 0 : weekday;
      }
      /**
       * Returns the month.
       * @returns {number}
       */
      getMonth() {
        return this.#date.month - 1;
      }
      /**
       * Returns the hour.
       * @returns {number}
       */
      getHours() {
        return this.#date.hour;
      }
      /**
       * Returns the minutes.
       * @returns {number}
       */
      getMinutes() {
        return this.#date.minute;
      }
      /**
       * Returns the seconds.
       * @returns {number}
       */
      getSeconds() {
        return this.#date.second;
      }
      /**
       * Returns the milliseconds.
       * @returns {number}
       */
      getMilliseconds() {
        return this.#date.millisecond;
      }
      /**
       * Returns the time.
       * @returns {number}
       */
      getTime() {
        return this.#date.valueOf();
      }
      /**
       * Returns the UTC day.
       * @returns {number}
       */
      getUTCDate() {
        return this.#getUTC().day;
      }
      /**
       * Returns the UTC year.
       * @returns {number}
       */
      getUTCFullYear() {
        return this.#getUTC().year;
      }
      /**
       * Returns the UTC day of the week.
       * @returns {number}
       */
      getUTCDay() {
        const weekday = this.#getUTC().weekday;
        return weekday === 7 ? 0 : weekday;
      }
      /**
       * Returns the UTC month.
       * @returns {number}
       */
      getUTCMonth() {
        return this.#getUTC().month - 1;
      }
      /**
       * Returns the UTC hour.
       * @returns {number}
       */
      getUTCHours() {
        return this.#getUTC().hour;
      }
      /**
       * Returns the UTC minutes.
       * @returns {number}
       */
      getUTCMinutes() {
        return this.#getUTC().minute;
      }
      /**
       * Returns the UTC seconds.
       * @returns {number}
       */
      getUTCSeconds() {
        return this.#getUTC().second;
      }
      /**
       * Returns the UTC milliseconds.
       * @returns {string | null}
       */
      toISOString() {
        return this.#date.toUTC().toISO();
      }
      /**
       * Returns the date as a JSON string.
       * @returns {string | null}
       */
      toJSON() {
        return this.#date.toJSON();
      }
      /**
       * Sets the day.
       * @param d
       */
      setDate(d) {
        this.#date = this.#date.set({ day: d });
      }
      /**
       * Sets the year.
       * @param y
       */
      setFullYear(y) {
        this.#date = this.#date.set({ year: y });
      }
      /**
       * Sets the day of the week.
       * @param d
       */
      setDay(d) {
        this.#date = this.#date.set({ weekday: d });
      }
      /**
       * Sets the month.
       * @param m
       */
      setMonth(m) {
        this.#date = this.#date.set({ month: m + 1 });
      }
      /**
       * Sets the hour.
       * @param h
       */
      setHours(h) {
        this.#date = this.#date.set({ hour: h });
      }
      /**
       * Sets the minutes.
       * @param m
       */
      setMinutes(m) {
        this.#date = this.#date.set({ minute: m });
      }
      /**
       * Sets the seconds.
       * @param s
       */
      setSeconds(s) {
        this.#date = this.#date.set({ second: s });
      }
      /**
       * Sets the milliseconds.
       * @param s
       */
      setMilliseconds(s) {
        this.#date = this.#date.set({ millisecond: s });
      }
      /**
       * Returns the date as a string.
       * @returns {string}
       */
      toString() {
        return this.toDate().toString();
      }
      /**
       * Returns the date as a Date object.
       * @returns {Date}
       */
      toDate() {
        return this.#date.toJSDate();
      }
      /**
       * Returns true if the day is the last day of the month.
       * @returns {boolean}
       */
      isLastDayOfMonth() {
        const { day, month } = this.#date;
        if (month === 2) {
          const isLeap = _CronDate.#isLeapYear(this.#date.year);
          return day === exports2.DAYS_IN_MONTH[month - 1] - (isLeap ? 0 : 1);
        }
        return day === exports2.DAYS_IN_MONTH[month - 1];
      }
      /**
       * Returns true if the day is the last weekday of the month.
       * @returns {boolean}
       */
      isLastWeekdayOfMonth() {
        const { day, month } = this.#date;
        let lastDay;
        if (month === 2) {
          lastDay = exports2.DAYS_IN_MONTH[month - 1] - (_CronDate.#isLeapYear(this.#date.year) ? 0 : 1);
        } else {
          lastDay = exports2.DAYS_IN_MONTH[month - 1];
        }
        return day > lastDay - 7;
      }
      /**
       * Primarily for internal use.
       * @param {DateMathOp} op - The operation to perform.
       * @param {TimeUnit} unit - The unit of time to use.
       * @param {number} [hoursLength] - The length of the hours. Required when unit is not month or day.
       */
      applyDateOperation(op, unit, hoursLength) {
        if (unit === TimeUnit.Month || unit === TimeUnit.Day) {
          this.invokeDateOperation(op, unit);
          return;
        }
        const previousHour = this.getHours();
        this.invokeDateOperation(op, unit);
        const currentHour = this.getHours();
        const diff = currentHour - previousHour;
        if (diff === 2) {
          if (hoursLength !== 24) {
            this.dstStart = currentHour;
          }
        } else if (diff === 0 && this.getMinutes() === 0 && this.getSeconds() === 0) {
          if (hoursLength !== 24) {
            this.dstEnd = currentHour;
          }
        }
      }
      /**
       * Returns the UTC date.
       * @private
       * @returns {DateTime}
       */
      #getUTC() {
        return this.#date.toUTC();
      }
    };
    exports2.CronDate = CronDate;
    exports2.default = CronDate;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronMonth.js
var require_CronMonth = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronMonth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronMonth = void 0;
    var CronDate_1 = require_CronDate();
    var CronField_1 = require_CronField();
    var MIN_MONTH = 1;
    var MAX_MONTH = 12;
    var MONTH_CHARS = Object.freeze([]);
    var CronMonth = class extends CronField_1.CronField {
      static get min() {
        return MIN_MONTH;
      }
      static get max() {
        return MAX_MONTH;
      }
      static get chars() {
        return MONTH_CHARS;
      }
      static get daysInMonth() {
        return CronDate_1.DAYS_IN_MONTH;
      }
      /**
       * CronDayOfMonth constructor. Initializes the "day of the month" field with the provided values.
       * @param {MonthRange[]} values - Values for the "day of the month" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "day of the month" field.
       * @returns {MonthRange[]}
       */
      get values() {
        return super.values;
      }
    };
    exports2.CronMonth = CronMonth;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronSecond.js
var require_CronSecond = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/CronSecond.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronSecond = void 0;
    var CronField_1 = require_CronField();
    var MIN_SECOND = 0;
    var MAX_SECOND = 59;
    var SECOND_CHARS = Object.freeze([]);
    var CronSecond = class extends CronField_1.CronField {
      static get min() {
        return MIN_SECOND;
      }
      static get max() {
        return MAX_SECOND;
      }
      static get chars() {
        return SECOND_CHARS;
      }
      /**
       * CronSecond constructor. Initializes the "second" field with the provided values.
       * @param {SixtyRange[]} values - Values for the "second" field
       * @param {CronFieldOptions} [options] - Options provided by the parser
       */
      constructor(values, options) {
        super(values, options);
        this.validate();
      }
      /**
       * Returns an array of allowed values for the "second" field.
       * @returns {SixtyRange[]}
       */
      get values() {
        return super.values;
      }
    };
    exports2.CronSecond = CronSecond;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/index.js
var require_fields = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/fields/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_types(), exports2);
    __exportStar(require_CronDayOfMonth(), exports2);
    __exportStar(require_CronDayOfWeek(), exports2);
    __exportStar(require_CronField(), exports2);
    __exportStar(require_CronHour(), exports2);
    __exportStar(require_CronMinute(), exports2);
    __exportStar(require_CronMonth(), exports2);
    __exportStar(require_CronSecond(), exports2);
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronFieldCollection.js
var require_CronFieldCollection = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronFieldCollection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronFieldCollection = void 0;
    var fields_1 = require_fields();
    var CronFieldCollection = class _CronFieldCollection {
      #second;
      #minute;
      #hour;
      #dayOfMonth;
      #month;
      #dayOfWeek;
      /**
       * Creates a new CronFieldCollection instance by partially overriding fields from an existing one.
       * @param {CronFieldCollection} base - The base CronFieldCollection to copy fields from
       * @param {CronFieldOverride} fields - The fields to override, can be CronField instances or raw values
       * @returns {CronFieldCollection} A new CronFieldCollection instance
       * @example
       * const base = new CronFieldCollection({
       *   second: new CronSecond([0]),
       *   minute: new CronMinute([0]),
       *   hour: new CronHour([12]),
       *   dayOfMonth: new CronDayOfMonth([1]),
       *   month: new CronMonth([1]),
       *   dayOfWeek: new CronDayOfWeek([1])
       * });
       *
       * // Using CronField instances
       * const modified1 = CronFieldCollection.from(base, {
       *   hour: new CronHour([15]),
       *   minute: new CronMinute([30])
       * });
       *
       * // Using raw values
       * const modified2 = CronFieldCollection.from(base, {
       *   hour: [15],        // Will create new CronHour
       *   minute: [30]       // Will create new CronMinute
       * });
       */
      static from(base, fields) {
        return new _CronFieldCollection({
          second: this.resolveField(fields_1.CronSecond, base.second, fields.second),
          minute: this.resolveField(fields_1.CronMinute, base.minute, fields.minute),
          hour: this.resolveField(fields_1.CronHour, base.hour, fields.hour),
          dayOfMonth: this.resolveField(fields_1.CronDayOfMonth, base.dayOfMonth, fields.dayOfMonth),
          month: this.resolveField(fields_1.CronMonth, base.month, fields.month),
          dayOfWeek: this.resolveField(fields_1.CronDayOfWeek, base.dayOfWeek, fields.dayOfWeek)
        });
      }
      /**
       * Resolves a field value, either using the provided CronField instance or creating a new one from raw values.
       * @param constructor - The constructor for creating new field instances
       * @param baseField - The base field to use if no override is provided
       * @param fieldValue - The override value, either a CronField instance or raw values
       * @returns The resolved CronField instance
       * @private
       */
      static resolveField(constructor, baseField, fieldValue) {
        if (!fieldValue) {
          return baseField;
        }
        if (fieldValue instanceof fields_1.CronField) {
          return fieldValue;
        }
        return new constructor(fieldValue);
      }
      /**
       * CronFieldCollection constructor. Initializes the cron fields with the provided values.
       * @param {CronFields} param0 - The cron fields values
       * @throws {Error} if validation fails
       * @example
       * const cronFields = new CronFieldCollection({
       *   second: new CronSecond([0]),
       *   minute: new CronMinute([0, 30]),
       *   hour: new CronHour([9]),
       *   dayOfMonth: new CronDayOfMonth([15]),
       *   month: new CronMonth([1]),
       *   dayOfWeek: new CronDayOfTheWeek([1, 2, 3, 4, 5]),
       * })
       *
       * console.log(cronFields.second.values); // [0]
       * console.log(cronFields.minute.values); // [0, 30]
       * console.log(cronFields.hour.values); // [9]
       * console.log(cronFields.dayOfMonth.values); // [15]
       * console.log(cronFields.month.values); // [1]
       * console.log(cronFields.dayOfWeek.values); // [1, 2, 3, 4, 5]
       */
      constructor({ second, minute, hour, dayOfMonth, month, dayOfWeek }) {
        if (!second) {
          throw new Error("Validation error, Field second is missing");
        }
        if (!minute) {
          throw new Error("Validation error, Field minute is missing");
        }
        if (!hour) {
          throw new Error("Validation error, Field hour is missing");
        }
        if (!dayOfMonth) {
          throw new Error("Validation error, Field dayOfMonth is missing");
        }
        if (!month) {
          throw new Error("Validation error, Field month is missing");
        }
        if (!dayOfWeek) {
          throw new Error("Validation error, Field dayOfWeek is missing");
        }
        if (month.values.length === 1 && !dayOfMonth.hasLastChar) {
          if (!(parseInt(dayOfMonth.values[0], 10) <= fields_1.CronMonth.daysInMonth[month.values[0] - 1])) {
            throw new Error("Invalid explicit day of month definition");
          }
        }
        this.#second = second;
        this.#minute = minute;
        this.#hour = hour;
        this.#month = month;
        this.#dayOfWeek = dayOfWeek;
        this.#dayOfMonth = dayOfMonth;
      }
      /**
       * Returns the second field.
       * @returns {CronSecond}
       */
      get second() {
        return this.#second;
      }
      /**
       * Returns the minute field.
       * @returns {CronMinute}
       */
      get minute() {
        return this.#minute;
      }
      /**
       * Returns the hour field.
       * @returns {CronHour}
       */
      get hour() {
        return this.#hour;
      }
      /**
       * Returns the day of the month field.
       * @returns {CronDayOfMonth}
       */
      get dayOfMonth() {
        return this.#dayOfMonth;
      }
      /**
       * Returns the month field.
       * @returns {CronMonth}
       */
      get month() {
        return this.#month;
      }
      /**
       * Returns the day of the week field.
       * @returns {CronDayOfWeek}
       */
      get dayOfWeek() {
        return this.#dayOfWeek;
      }
      /**
       * Returns a string representation of the cron fields.
       * @param {(number | CronChars)[]} input - The cron fields values
       * @static
       * @returns {FieldRange[]} - The compacted cron fields
       */
      static compactField(input) {
        if (input.length === 0) {
          return [];
        }
        const output = [];
        let current = void 0;
        input.forEach((item, i, arr) => {
          if (current === void 0) {
            current = { start: item, count: 1 };
            return;
          }
          const prevItem = arr[i - 1] || current.start;
          const nextItem = arr[i + 1];
          if (item === "L" || item === "W") {
            output.push(current);
            output.push({ start: item, count: 1 });
            current = void 0;
            return;
          }
          if (current.step === void 0 && nextItem !== void 0) {
            const step = item - prevItem;
            const nextStep = nextItem - item;
            if (step <= nextStep) {
              current = { ...current, count: 2, end: item, step };
              return;
            }
            current.step = 1;
          }
          if (item - (current.end ?? 0) === current.step) {
            current.count++;
            current.end = item;
          } else {
            if (current.count === 1) {
              output.push({ start: current.start, count: 1 });
            } else if (current.count === 2) {
              output.push({ start: current.start, count: 1 });
              output.push({
                start: current.end ?? /* istanbul ignore next - see above */
                prevItem,
                count: 1
              });
            } else {
              output.push(current);
            }
            current = { start: item, count: 1 };
          }
        });
        if (current) {
          output.push(current);
        }
        return output;
      }
      /**
       * Handles a single range.
       * @param {CronField} field - The cron field to stringify
       * @param {FieldRange} range {start: number, end: number, step: number, count: number} The range to handle.
       * @param {number} max The maximum value for the field.
       * @returns {string | null} The stringified range or null if it cannot be stringified.
       * @private
       */
      static #handleSingleRange(field, range, max) {
        const step = range.step;
        if (!step) {
          return null;
        }
        if (step === 1 && range.start === field.min && range.end && range.end >= max) {
          return field.hasQuestionMarkChar ? "?" : "*";
        }
        if (step !== 1 && range.start === field.min && range.end && range.end >= max - step + 1) {
          return `*/${step}`;
        }
        return null;
      }
      /**
       * Handles multiple ranges.
       * @param {FieldRange} range {start: number, end: number, step: number, count: number} The range to handle.
       * @param {number} max The maximum value for the field.
       * @returns {string} The stringified range.
       * @private
       */
      static #handleMultipleRanges(range, max) {
        const step = range.step;
        if (step === 1) {
          return `${range.start}-${range.end}`;
        }
        const multiplier = range.start === 0 ? range.count - 1 : range.count;
        if (!step) {
          throw new Error("Unexpected range step");
        }
        if (!range.end) {
          throw new Error("Unexpected range end");
        }
        if (step * multiplier > range.end) {
          const mapFn = (_, index) => {
            if (typeof range.start !== "number") {
              throw new Error("Unexpected range start");
            }
            return index % step === 0 ? range.start + index : null;
          };
          if (typeof range.start !== "number") {
            throw new Error("Unexpected range start");
          }
          const seed = { length: range.end - range.start + 1 };
          return Array.from(seed, mapFn).filter((value) => value !== null).join(",");
        }
        return range.end === max - step + 1 ? `${range.start}/${step}` : `${range.start}-${range.end}/${step}`;
      }
      /**
       * Returns a string representation of the cron fields.
       * @param {CronField} field - The cron field to stringify
       * @static
       * @returns {string} - The stringified cron field
       */
      stringifyField(field) {
        let max = field.max;
        let values = field.values;
        if (field instanceof fields_1.CronDayOfWeek) {
          max = 6;
          const dayOfWeek = this.#dayOfWeek.values;
          values = dayOfWeek[dayOfWeek.length - 1] === 7 ? dayOfWeek.slice(0, -1) : dayOfWeek;
        }
        if (field instanceof fields_1.CronDayOfMonth) {
          max = this.#month.values.length === 1 ? fields_1.CronMonth.daysInMonth[this.#month.values[0] - 1] : field.max;
        }
        const ranges = _CronFieldCollection.compactField(values);
        if (ranges.length === 1) {
          const singleRangeResult = _CronFieldCollection.#handleSingleRange(field, ranges[0], max);
          if (singleRangeResult) {
            return singleRangeResult;
          }
        }
        return ranges.map((range) => {
          const value = range.count === 1 ? range.start.toString() : _CronFieldCollection.#handleMultipleRanges(range, max);
          if (field instanceof fields_1.CronDayOfWeek && field.nthDay > 0) {
            return `${value}#${field.nthDay}`;
          }
          return value;
        }).join(",");
      }
      /**
       * Returns a string representation of the cron field values.
       * @param {boolean} includeSeconds - Whether to include seconds in the output
       * @returns {string} The formatted cron string
       */
      stringify(includeSeconds = false) {
        const arr = [];
        if (includeSeconds) {
          arr.push(this.stringifyField(this.#second));
        }
        arr.push(
          this.stringifyField(this.#minute),
          // minute
          this.stringifyField(this.#hour),
          // hour
          this.stringifyField(this.#dayOfMonth),
          // dayOfMonth
          this.stringifyField(this.#month),
          // month
          this.stringifyField(this.#dayOfWeek)
        );
        return arr.join(" ");
      }
      /**
       * Returns a serialized representation of the cron fields values.
       * @returns {SerializedCronFields} An object containing the cron field values
       */
      serialize() {
        return {
          second: this.#second.serialize(),
          minute: this.#minute.serialize(),
          hour: this.#hour.serialize(),
          dayOfMonth: this.#dayOfMonth.serialize(),
          month: this.#month.serialize(),
          dayOfWeek: this.#dayOfWeek.serialize()
        };
      }
    };
    exports2.CronFieldCollection = CronFieldCollection;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronExpression.js
var require_CronExpression = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronExpression = exports2.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE = exports2.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE = void 0;
    var CronDate_1 = require_CronDate();
    exports2.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE = "Out of the time span range";
    exports2.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE = "Invalid expression, loop limit exceeded";
    var LOOP_LIMIT = 1e4;
    var CronExpression2 = class _CronExpression {
      #options;
      #tz;
      #currentDate;
      #startDate;
      #endDate;
      #fields;
      /**
       * Creates a new CronExpression instance.
       *
       * @param {CronFieldCollection} fields - Cron fields.
       * @param {CronExpressionOptions} options - Parser options.
       */
      constructor(fields, options) {
        this.#options = options;
        this.#tz = options.tz;
        this.#startDate = options.startDate ? new CronDate_1.CronDate(options.startDate, this.#tz) : null;
        this.#endDate = options.endDate ? new CronDate_1.CronDate(options.endDate, this.#tz) : null;
        let currentDateValue = options.currentDate ?? options.startDate;
        if (currentDateValue) {
          const tempCurrentDate = new CronDate_1.CronDate(currentDateValue, this.#tz);
          if (this.#startDate && tempCurrentDate.getTime() < this.#startDate.getTime()) {
            currentDateValue = this.#startDate;
          } else if (this.#endDate && tempCurrentDate.getTime() > this.#endDate.getTime()) {
            currentDateValue = this.#endDate;
          }
        }
        this.#currentDate = new CronDate_1.CronDate(currentDateValue, this.#tz);
        this.#fields = fields;
      }
      /**
       * Getter for the cron fields.
       *
       * @returns {CronFieldCollection} Cron fields.
       */
      get fields() {
        return this.#fields;
      }
      /**
       * Converts cron fields back to a CronExpression instance.
       *
       * @public
       * @param {Record<string, number[]>} fields - The input cron fields object.
       * @param {CronExpressionOptions} [options] - Optional parsing options.
       * @returns {CronExpression} - A new CronExpression instance.
       */
      static fieldsToExpression(fields, options) {
        return new _CronExpression(fields, options || {});
      }
      /**
       * Checks if the given value matches any element in the sequence.
       *
       * @param {number} value - The value to be matched.
       * @param {number[]} sequence - The sequence to be checked against.
       * @returns {boolean} - True if the value matches an element in the sequence; otherwise, false.
       * @memberof CronExpression
       * @private
       */
      static #matchSchedule(value, sequence) {
        return sequence.some((element) => element === value);
      }
      /**
       * Determines if the current date matches the last specified weekday of the month.
       *
       * @param {Array<(number|string)>} expressions - An array of expressions containing weekdays and "L" for the last weekday.
       * @param {CronDate} currentDate - The current date object.
       * @returns {boolean} - True if the current date matches the last specified weekday of the month; otherwise, false.
       * @memberof CronExpression
       * @private
       */
      static #isLastWeekdayOfMonthMatch(expressions, currentDate) {
        const isLastWeekdayOfMonth = currentDate.isLastWeekdayOfMonth();
        return expressions.some((expression) => {
          const weekday = parseInt(expression.toString().charAt(0), 10) % 7;
          if (Number.isNaN(weekday)) {
            throw new Error(`Invalid last weekday of the month expression: ${expression}`);
          }
          return currentDate.getDay() === weekday && isLastWeekdayOfMonth;
        });
      }
      /**
       * Find the next scheduled date based on the cron expression.
       * @returns {CronDate} - The next scheduled date or an ES6 compatible iterator object.
       * @memberof CronExpression
       * @public
       */
      next() {
        return this.#findSchedule();
      }
      /**
       * Find the previous scheduled date based on the cron expression.
       * @returns {CronDate} - The previous scheduled date or an ES6 compatible iterator object.
       * @memberof CronExpression
       * @public
       */
      prev() {
        return this.#findSchedule(true);
      }
      /**
       * Check if there is a next scheduled date based on the current date and cron expression.
       * @returns {boolean} - Returns true if there is a next scheduled date, false otherwise.
       * @memberof CronExpression
       * @public
       */
      hasNext() {
        const current = this.#currentDate;
        try {
          this.#findSchedule();
          return true;
        } catch {
          return false;
        } finally {
          this.#currentDate = current;
        }
      }
      /**
       * Check if there is a previous scheduled date based on the current date and cron expression.
       * @returns {boolean} - Returns true if there is a previous scheduled date, false otherwise.
       * @memberof CronExpression
       * @public
       */
      hasPrev() {
        const current = this.#currentDate;
        try {
          this.#findSchedule(true);
          return true;
        } catch {
          return false;
        } finally {
          this.#currentDate = current;
        }
      }
      /**
       * Iterate over a specified number of steps and optionally execute a callback function for each step.
       * @param {number} steps - The number of steps to iterate. Positive value iterates forward, negative value iterates backward.
       * @returns {CronDate[]} - An array of iterator fields or CronDate objects.
       * @memberof CronExpression
       * @public
       */
      take(limit) {
        const items = [];
        if (limit >= 0) {
          for (let i = 0; i < limit; i++) {
            try {
              items.push(this.next());
            } catch {
              return items;
            }
          }
        } else {
          for (let i = 0; i > limit; i--) {
            try {
              items.push(this.prev());
            } catch {
              return items;
            }
          }
        }
        return items;
      }
      /**
       * Reset the iterators current date to a new date or the initial date.
       * @param {Date | CronDate} [newDate] - Optional new date to reset to. If not provided, it will reset to the initial date.
       * @memberof CronExpression
       * @public
       */
      reset(newDate) {
        this.#currentDate = new CronDate_1.CronDate(newDate || this.#options.currentDate);
      }
      /**
       * Generate a string representation of the cron expression.
       * @param {boolean} [includeSeconds=false] - Whether to include the seconds field in the string representation.
       * @returns {string} - The string representation of the cron expression.
       * @memberof CronExpression
       * @public
       */
      stringify(includeSeconds = false) {
        return this.#fields.stringify(includeSeconds);
      }
      /**
       * Check if the cron expression includes the given date
       * @param {Date|CronDate} date
       * @returns {boolean}
       */
      includesDate(date) {
        const { second, minute, hour, month } = this.#fields;
        const dt = new CronDate_1.CronDate(date, this.#tz);
        if (!second.values.includes(dt.getSeconds()) || !minute.values.includes(dt.getMinutes()) || !hour.values.includes(dt.getHours()) || !month.values.includes(dt.getMonth() + 1)) {
          return false;
        }
        if (!this.#matchDayOfMonth(dt)) {
          return false;
        }
        if (this.#fields.dayOfWeek.nthDay > 0) {
          const weekInMonth = Math.ceil(dt.getDate() / 7);
          if (weekInMonth !== this.#fields.dayOfWeek.nthDay) {
            return false;
          }
        }
        return true;
      }
      /**
       * Returns the string representation of the cron expression.
       * @returns {CronDate} - The next schedule date.
       */
      toString() {
        return this.#options.expression || this.stringify(true);
      }
      /**
       * Determines if the given date matches the cron expression's day of month and day of week fields.
       *
       * The function checks the following rules:
       * Rule 1: If both "day of month" and "day of week" are restricted (not wildcard), then one or both must match the current day.
       * Rule 2: If "day of month" is restricted and "day of week" is not restricted, then "day of month" must match the current day.
       * Rule 3: If "day of month" is a wildcard, "day of week" is not a wildcard, and "day of week" matches the current day, then the match is accepted.
       * If none of the rules match, the match is rejected.
       *
       * @param {CronDate} currentDate - The current date to be evaluated against the cron expression.
       * @returns {boolean} Returns true if the current date matches the cron expression's day of month and day of week fields, otherwise false.
       * @memberof CronExpression
       * @private
       */
      #matchDayOfMonth(currentDate) {
        const isDayOfMonthWildcardMatch = this.#fields.dayOfMonth.isWildcard;
        const isRestrictedDayOfMonth = !isDayOfMonthWildcardMatch;
        const isDayOfWeekWildcardMatch = this.#fields.dayOfWeek.isWildcard;
        const isRestrictedDayOfWeek = !isDayOfWeekWildcardMatch;
        const matchedDOM = _CronExpression.#matchSchedule(currentDate.getDate(), this.#fields.dayOfMonth.values) || this.#fields.dayOfMonth.hasLastChar && currentDate.isLastDayOfMonth();
        const matchedDOW = _CronExpression.#matchSchedule(currentDate.getDay(), this.#fields.dayOfWeek.values) || this.#fields.dayOfWeek.hasLastChar && _CronExpression.#isLastWeekdayOfMonthMatch(this.#fields.dayOfWeek.values, currentDate);
        if (isRestrictedDayOfMonth && isRestrictedDayOfWeek && (matchedDOM || matchedDOW)) {
          return true;
        }
        if (matchedDOM && !isRestrictedDayOfWeek) {
          return true;
        }
        if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && matchedDOW) {
          return true;
        }
        return false;
      }
      /**
       * Determines if the current hour matches the cron expression.
       *
       * @param {CronDate} currentDate - The current date object.
       * @param {DateMathOp} dateMathVerb - The date math operation enumeration value.
       * @param {boolean} reverse - A flag indicating whether the matching should be done in reverse order.
       * @returns {boolean} - True if the current hour matches the cron expression; otherwise, false.
       */
      #matchHour(currentDate, dateMathVerb, reverse) {
        const currentHour = currentDate.getHours();
        const isMatch = _CronExpression.#matchSchedule(currentHour, this.#fields.hour.values);
        const isDstStart = currentDate.dstStart === currentHour;
        const isDstEnd = currentDate.dstEnd === currentHour;
        if (!isMatch && !isDstStart) {
          currentDate.dstStart = null;
          currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Hour, this.#fields.hour.values.length);
          return false;
        }
        if (isDstStart && !_CronExpression.#matchSchedule(currentHour - 1, this.#fields.hour.values)) {
          currentDate.invokeDateOperation(dateMathVerb, CronDate_1.TimeUnit.Hour);
          return false;
        }
        if (isDstEnd && !reverse) {
          currentDate.dstEnd = null;
          currentDate.applyDateOperation(CronDate_1.DateMathOp.Add, CronDate_1.TimeUnit.Hour, this.#fields.hour.values.length);
          return false;
        }
        return true;
      }
      /**
       * Validates the current date against the start and end dates of the cron expression.
       * If the current date is outside the specified time span, an error is thrown.
       *
       * @param currentDate {CronDate} - The current date to validate.
       * @throws {Error} If the current date is outside the specified time span.
       * @private
       */
      #validateTimeSpan(currentDate) {
        if (!this.#startDate && !this.#endDate) {
          return;
        }
        const currentTime = currentDate.getTime();
        if (this.#startDate && currentTime < this.#startDate.getTime()) {
          throw new Error(exports2.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE);
        }
        if (this.#endDate && currentTime > this.#endDate.getTime()) {
          throw new Error(exports2.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE);
        }
      }
      /**
       * Finds the next or previous schedule based on the cron expression.
       *
       * @param {boolean} [reverse=false] - If true, finds the previous schedule; otherwise, finds the next schedule.
       * @returns {CronDate} - The next or previous schedule date.
       * @private
       */
      #findSchedule(reverse = false) {
        const dateMathVerb = reverse ? CronDate_1.DateMathOp.Subtract : CronDate_1.DateMathOp.Add;
        const currentDate = new CronDate_1.CronDate(this.#currentDate);
        const startTimestamp = currentDate.getTime();
        let stepCount = 0;
        while (++stepCount < LOOP_LIMIT) {
          this.#validateTimeSpan(currentDate);
          if (!this.#matchDayOfMonth(currentDate)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Day, this.#fields.hour.values.length);
            continue;
          }
          if (!(this.#fields.dayOfWeek.nthDay <= 0 || Math.ceil(currentDate.getDate() / 7) === this.#fields.dayOfWeek.nthDay)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Day, this.#fields.hour.values.length);
            continue;
          }
          if (!_CronExpression.#matchSchedule(currentDate.getMonth() + 1, this.#fields.month.values)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Month, this.#fields.hour.values.length);
            continue;
          }
          if (!this.#matchHour(currentDate, dateMathVerb, reverse)) {
            continue;
          }
          if (!_CronExpression.#matchSchedule(currentDate.getMinutes(), this.#fields.minute.values)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Minute, this.#fields.hour.values.length);
            continue;
          }
          if (!_CronExpression.#matchSchedule(currentDate.getSeconds(), this.#fields.second.values)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Second, this.#fields.hour.values.length);
            continue;
          }
          if (startTimestamp === currentDate.getTime()) {
            if (dateMathVerb === "Add" || currentDate.getMilliseconds() === 0) {
              currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Second, this.#fields.hour.values.length);
            }
            continue;
          }
          break;
        }
        if (stepCount > LOOP_LIMIT) {
          throw new Error(exports2.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE);
        }
        if (currentDate.getMilliseconds() !== 0) {
          currentDate.setMilliseconds(0);
        }
        this.#currentDate = currentDate;
        return currentDate;
      }
      /**
       * Returns an iterator for iterating through future CronDate instances
       *
       * @name Symbol.iterator
       * @memberof CronExpression
       * @returns {Iterator<CronDate>} An iterator object for CronExpression that returns CronDate values.
       */
      [Symbol.iterator]() {
        return {
          next: () => {
            const schedule = this.#findSchedule();
            return { value: schedule, done: !this.hasNext() };
          }
        };
      }
    };
    exports2.CronExpression = CronExpression2;
    exports2.default = CronExpression2;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/utils/random.js
var require_random2 = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/utils/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.seededRandom = seededRandom;
    function xfnv1a(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return () => h >>> 0;
    }
    function mulberry32(seed) {
      return () => {
        let t = seed += 1831565813;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    function seededRandom(str) {
      const seed = str ? xfnv1a(str)() : Math.floor(Math.random() * 1e10);
      return mulberry32(seed);
    }
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronExpressionParser.js
var require_CronExpressionParser = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronExpressionParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronExpressionParser = exports2.DayOfWeek = exports2.Months = exports2.CronUnit = exports2.PredefinedExpressions = void 0;
    var CronFieldCollection_1 = require_CronFieldCollection();
    var CronExpression_1 = require_CronExpression();
    var random_1 = require_random2();
    var fields_1 = require_fields();
    var PredefinedExpressions;
    (function(PredefinedExpressions2) {
      PredefinedExpressions2["@yearly"] = "0 0 0 1 1 *";
      PredefinedExpressions2["@annually"] = "0 0 0 1 1 *";
      PredefinedExpressions2["@monthly"] = "0 0 0 1 * *";
      PredefinedExpressions2["@weekly"] = "0 0 0 * * 0";
      PredefinedExpressions2["@daily"] = "0 0 0 * * *";
      PredefinedExpressions2["@hourly"] = "0 0 * * * *";
      PredefinedExpressions2["@minutely"] = "0 * * * * *";
      PredefinedExpressions2["@secondly"] = "* * * * * *";
      PredefinedExpressions2["@weekdays"] = "0 0 0 * * 1-5";
      PredefinedExpressions2["@weekends"] = "0 0 0 * * 0,6";
    })(PredefinedExpressions || (exports2.PredefinedExpressions = PredefinedExpressions = {}));
    var CronUnit;
    (function(CronUnit2) {
      CronUnit2["Second"] = "Second";
      CronUnit2["Minute"] = "Minute";
      CronUnit2["Hour"] = "Hour";
      CronUnit2["DayOfMonth"] = "DayOfMonth";
      CronUnit2["Month"] = "Month";
      CronUnit2["DayOfWeek"] = "DayOfWeek";
    })(CronUnit || (exports2.CronUnit = CronUnit = {}));
    var Months;
    (function(Months2) {
      Months2[Months2["jan"] = 1] = "jan";
      Months2[Months2["feb"] = 2] = "feb";
      Months2[Months2["mar"] = 3] = "mar";
      Months2[Months2["apr"] = 4] = "apr";
      Months2[Months2["may"] = 5] = "may";
      Months2[Months2["jun"] = 6] = "jun";
      Months2[Months2["jul"] = 7] = "jul";
      Months2[Months2["aug"] = 8] = "aug";
      Months2[Months2["sep"] = 9] = "sep";
      Months2[Months2["oct"] = 10] = "oct";
      Months2[Months2["nov"] = 11] = "nov";
      Months2[Months2["dec"] = 12] = "dec";
    })(Months || (exports2.Months = Months = {}));
    var DayOfWeek;
    (function(DayOfWeek2) {
      DayOfWeek2[DayOfWeek2["sun"] = 0] = "sun";
      DayOfWeek2[DayOfWeek2["mon"] = 1] = "mon";
      DayOfWeek2[DayOfWeek2["tue"] = 2] = "tue";
      DayOfWeek2[DayOfWeek2["wed"] = 3] = "wed";
      DayOfWeek2[DayOfWeek2["thu"] = 4] = "thu";
      DayOfWeek2[DayOfWeek2["fri"] = 5] = "fri";
      DayOfWeek2[DayOfWeek2["sat"] = 6] = "sat";
    })(DayOfWeek || (exports2.DayOfWeek = DayOfWeek = {}));
    var CronExpressionParser2 = class _CronExpressionParser {
      /**
       * Parses a cron expression and returns a CronExpression object.
       * @param {string} expression - The cron expression to parse.
       * @param {CronExpressionOptions} [options={}] - The options to use when parsing the expression.
       * @param {boolean} [options.strict=false] - If true, will throw an error if the expression contains both dayOfMonth and dayOfWeek.
       * @param {CronDate} [options.currentDate=new CronDate(undefined, 'UTC')] - The date to use when calculating the next/previous occurrence.
       *
       * @returns {CronExpression} A CronExpression object.
       */
      static parse(expression, options = {}) {
        const { strict = false, hashSeed } = options;
        const rand = (0, random_1.seededRandom)(hashSeed);
        expression = PredefinedExpressions[expression] || expression;
        const rawFields = _CronExpressionParser.#getRawFields(expression, strict);
        if (!(rawFields.dayOfMonth === "*" || rawFields.dayOfWeek === "*" || !strict)) {
          throw new Error("Cannot use both dayOfMonth and dayOfWeek together in strict mode!");
        }
        const second = _CronExpressionParser.#parseField(CronUnit.Second, rawFields.second, fields_1.CronSecond.constraints, rand);
        const minute = _CronExpressionParser.#parseField(CronUnit.Minute, rawFields.minute, fields_1.CronMinute.constraints, rand);
        const hour = _CronExpressionParser.#parseField(CronUnit.Hour, rawFields.hour, fields_1.CronHour.constraints, rand);
        const month = _CronExpressionParser.#parseField(CronUnit.Month, rawFields.month, fields_1.CronMonth.constraints, rand);
        const dayOfMonth = _CronExpressionParser.#parseField(CronUnit.DayOfMonth, rawFields.dayOfMonth, fields_1.CronDayOfMonth.constraints, rand);
        const { dayOfWeek: _dayOfWeek, nthDayOfWeek } = _CronExpressionParser.#parseNthDay(rawFields.dayOfWeek);
        const dayOfWeek = _CronExpressionParser.#parseField(CronUnit.DayOfWeek, _dayOfWeek, fields_1.CronDayOfWeek.constraints, rand);
        const fields = new CronFieldCollection_1.CronFieldCollection({
          second: new fields_1.CronSecond(second, { rawValue: rawFields.second }),
          minute: new fields_1.CronMinute(minute, { rawValue: rawFields.minute }),
          hour: new fields_1.CronHour(hour, { rawValue: rawFields.hour }),
          dayOfMonth: new fields_1.CronDayOfMonth(dayOfMonth, { rawValue: rawFields.dayOfMonth }),
          month: new fields_1.CronMonth(month, { rawValue: rawFields.month }),
          dayOfWeek: new fields_1.CronDayOfWeek(dayOfWeek, { rawValue: rawFields.dayOfWeek, nthDayOfWeek })
        });
        return new CronExpression_1.CronExpression(fields, { ...options, expression });
      }
      /**
       * Get the raw fields from a cron expression.
       * @param {string} expression - The cron expression to parse.
       * @param {boolean} strict - If true, will throw an error if the expression contains both dayOfMonth and dayOfWeek.
       * @private
       * @returns {RawCronFields} The raw fields.
       */
      static #getRawFields(expression, strict) {
        if (strict && !expression.length) {
          throw new Error("Invalid cron expression");
        }
        expression = expression || "0 * * * * *";
        const atoms = expression.trim().split(/\s+/);
        if (strict && atoms.length < 6) {
          throw new Error("Invalid cron expression, expected 6 fields");
        }
        if (atoms.length > 6) {
          throw new Error("Invalid cron expression, too many fields");
        }
        const defaults = ["*", "*", "*", "*", "*", "0"];
        if (atoms.length < defaults.length) {
          atoms.unshift(...defaults.slice(atoms.length));
        }
        const [second, minute, hour, dayOfMonth, month, dayOfWeek] = atoms;
        return { second, minute, hour, dayOfMonth, month, dayOfWeek };
      }
      /**
       * Parse a field from a cron expression.
       * @param {CronUnit} field - The field to parse.
       * @param {string} value - The value of the field.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       * @returns {(number | string)[]} The parsed field.
       */
      static #parseField(field, value, constraints, rand) {
        if (field === CronUnit.Month || field === CronUnit.DayOfWeek) {
          value = value.replace(/[a-z]{3}/gi, (match) => {
            match = match.toLowerCase();
            const replacer = Months[match] || DayOfWeek[match];
            if (replacer === void 0) {
              throw new Error(`Validation error, cannot resolve alias "${match}"`);
            }
            return replacer.toString();
          });
        }
        if (!constraints.validChars.test(value)) {
          throw new Error(`Invalid characters, got value: ${value}`);
        }
        value = this.#parseWildcard(value, constraints);
        value = this.#parseHashed(value, constraints, rand);
        return this.#parseSequence(field, value, constraints);
      }
      /**
       * Parse a wildcard from a cron expression.
       * @param {string} value - The value to parse.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       */
      static #parseWildcard(value, constraints) {
        return value.replace(/[*?]/g, constraints.min + "-" + constraints.max);
      }
      /**
       * Parse a hashed value from a cron expression.
       * @param {string} value - The value to parse.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @param {PRNG} rand - The random number generator to use.
       * @private
       */
      static #parseHashed(value, constraints, rand) {
        const randomValue = rand();
        return value.replace(/H(?:\((\d+)-(\d+)\))?(?:\/(\d+))?/g, (_, min, max, step) => {
          if (min && max && step) {
            const minNum = parseInt(min, 10);
            const maxNum = parseInt(max, 10);
            const stepNum = parseInt(step, 10);
            if (minNum > maxNum) {
              throw new Error(`Invalid range: ${minNum}-${maxNum}, min > max`);
            }
            if (stepNum <= 0) {
              throw new Error(`Invalid step: ${stepNum}, must be positive`);
            }
            const minStart = Math.max(minNum, constraints.min);
            const offset = Math.floor(randomValue * stepNum);
            const values = [];
            for (let i = Math.floor(minStart / stepNum) * stepNum + offset; i <= maxNum; i += stepNum) {
              if (i >= minStart) {
                values.push(i);
              }
            }
            return values.join(",");
          } else if (min && max) {
            const minNum = parseInt(min, 10);
            const maxNum = parseInt(max, 10);
            if (minNum > maxNum) {
              throw new Error(`Invalid range: ${minNum}-${maxNum}, min > max`);
            }
            return String(Math.floor(randomValue * (maxNum - minNum + 1)) + minNum);
          } else if (step) {
            const stepNum = parseInt(step, 10);
            if (stepNum <= 0) {
              throw new Error(`Invalid step: ${stepNum}, must be positive`);
            }
            const offset = Math.floor(randomValue * stepNum);
            const values = [];
            for (let i = Math.floor(constraints.min / stepNum) * stepNum + offset; i <= constraints.max; i += stepNum) {
              if (i >= constraints.min) {
                values.push(i);
              }
            }
            return values.join(",");
          } else {
            return String(Math.floor(randomValue * (constraints.max - constraints.min + 1) + constraints.min));
          }
        });
      }
      /**
       * Parse a sequence from a cron expression.
       * @param {CronUnit} field - The field to parse.
       * @param {string} val - The sequence to parse.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       */
      static #parseSequence(field, val, constraints) {
        const stack = [];
        function handleResult(result, constraints2) {
          if (Array.isArray(result)) {
            stack.push(...result);
          } else {
            if (_CronExpressionParser.#isValidConstraintChar(constraints2, result)) {
              stack.push(result);
            } else {
              const v = parseInt(result.toString(), 10);
              const isValid = v >= constraints2.min && v <= constraints2.max;
              if (!isValid) {
                throw new Error(`Constraint error, got value ${result} expected range ${constraints2.min}-${constraints2.max}`);
              }
              stack.push(field === CronUnit.DayOfWeek ? v % 7 : result);
            }
          }
        }
        const atoms = val.split(",");
        atoms.forEach((atom) => {
          if (!(atom.length > 0)) {
            throw new Error("Invalid list value format");
          }
          handleResult(_CronExpressionParser.#parseRepeat(field, atom, constraints), constraints);
        });
        return stack;
      }
      /**
       * Parse repeat from a cron expression.
       * @param {CronUnit} field - The field to parse.
       * @param {string} val - The repeat to parse.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       * @returns {(number | string)[]} The parsed repeat.
       */
      static #parseRepeat(field, val, constraints) {
        const atoms = val.split("/");
        if (atoms.length > 2) {
          throw new Error(`Invalid repeat: ${val}`);
        }
        if (atoms.length === 2) {
          if (!isNaN(parseInt(atoms[0], 10))) {
            atoms[0] = `${atoms[0]}-${constraints.max}`;
          }
          return _CronExpressionParser.#parseRange(field, atoms[0], parseInt(atoms[1], 10), constraints);
        }
        return _CronExpressionParser.#parseRange(field, val, 1, constraints);
      }
      /**
       * Validate a cron range.
       * @param {number} min - The minimum value of the range.
       * @param {number} max - The maximum value of the range.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       * @returns {void}
       * @throws {Error} Throws an error if the range is invalid.
       */
      static #validateRange(min, max, constraints) {
        const isValid = !isNaN(min) && !isNaN(max) && min >= constraints.min && max <= constraints.max;
        if (!isValid) {
          throw new Error(`Constraint error, got range ${min}-${max} expected range ${constraints.min}-${constraints.max}`);
        }
        if (min > max) {
          throw new Error(`Invalid range: ${min}-${max}, min(${min}) > max(${max})`);
        }
      }
      /**
       * Validate a cron repeat interval.
       * @param {number} repeatInterval - The repeat interval to validate.
       * @private
       * @returns {void}
       * @throws {Error} Throws an error if the repeat interval is invalid.
       */
      static #validateRepeatInterval(repeatInterval) {
        if (!(!isNaN(repeatInterval) && repeatInterval > 0)) {
          throw new Error(`Constraint error, cannot repeat at every ${repeatInterval} time.`);
        }
      }
      /**
       * Create a range from a cron expression.
       * @param {CronUnit} field - The field to parse.
       * @param {number} min - The minimum value of the range.
       * @param {number} max - The maximum value of the range.
       * @param {number} repeatInterval - The repeat interval of the range.
       * @private
       * @returns {number[]} The created range.
       */
      static #createRange(field, min, max, repeatInterval) {
        const stack = [];
        if (field === CronUnit.DayOfWeek && max % 7 === 0) {
          stack.push(0);
        }
        for (let index = min; index <= max; index += repeatInterval) {
          if (stack.indexOf(index) === -1) {
            stack.push(index);
          }
        }
        return stack;
      }
      /**
       * Parse a range from a cron expression.
       * @param {CronUnit} field - The field to parse.
       * @param {string} val - The range to parse.
       * @param {number} repeatInterval - The repeat interval of the range.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @private
       * @returns {number[] | string[] | number | string} The parsed range.
       */
      static #parseRange(field, val, repeatInterval, constraints) {
        const atoms = val.split("-");
        if (atoms.length <= 1) {
          return isNaN(+val) ? val : +val;
        }
        const [min, max] = atoms.map((num) => parseInt(num, 10));
        this.#validateRange(min, max, constraints);
        this.#validateRepeatInterval(repeatInterval);
        return this.#createRange(field, min, max, repeatInterval);
      }
      /**
       * Parse a cron expression.
       * @param {string} val - The cron expression to parse.
       * @private
       * @returns {string} The parsed cron expression.
       */
      static #parseNthDay(val) {
        const atoms = val.split("#");
        if (atoms.length <= 1) {
          return { dayOfWeek: atoms[0] };
        }
        const nthValue = +atoms[atoms.length - 1];
        const matches = val.match(/([,-/])/);
        if (matches !== null) {
          throw new Error(`Constraint error, invalid dayOfWeek \`#\` and \`${matches?.[0]}\` special characters are incompatible`);
        }
        if (!(atoms.length <= 2 && !isNaN(nthValue) && nthValue >= 1 && nthValue <= 5)) {
          throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
        }
        return { dayOfWeek: atoms[0], nthDayOfWeek: nthValue };
      }
      /**
       * Checks if a character is valid for a field.
       * @param {CronConstraints} constraints - The constraints for the field.
       * @param {string | number} value - The value to check.
       * @private
       * @returns {boolean} Whether the character is valid for the field.
       */
      static #isValidConstraintChar(constraints, value) {
        return constraints.chars.some((char) => value.toString().includes(char));
      }
    };
    exports2.CronExpressionParser = CronExpressionParser2;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronFileParser.js
var require_CronFileParser = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/CronFileParser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod2) {
        if (mod2 && mod2.__esModule) return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronFileParser = void 0;
    var CronExpressionParser_1 = require_CronExpressionParser();
    var CronFileParser = class _CronFileParser {
      /**
       * Parse a crontab file asynchronously
       * @param filePath Path to crontab file
       * @returns Promise resolving to parse results
       * @throws If file cannot be read
       */
      static async parseFile(filePath) {
        const { readFile } = await Promise.resolve().then(() => __importStar(require("fs/promises")));
        const data = await readFile(filePath, "utf8");
        return _CronFileParser.#parseContent(data);
      }
      /**
       * Parse a crontab file synchronously
       * @param filePath Path to crontab file
       * @returns Parse results
       * @throws If file cannot be read
       */
      static parseFileSync(filePath) {
        const { readFileSync } = require("fs");
        const data = readFileSync(filePath, "utf8");
        return _CronFileParser.#parseContent(data);
      }
      /**
       * Internal method to parse crontab file content
       * @private
       */
      static #parseContent(data) {
        const blocks = data.split("\n");
        const result = {
          variables: {},
          expressions: [],
          errors: {}
        };
        for (const block of blocks) {
          const entry = block.trim();
          if (entry.length === 0 || entry.startsWith("#")) {
            continue;
          }
          const variableMatch = entry.match(/^(.*)=(.*)$/);
          if (variableMatch) {
            const [, key, value] = variableMatch;
            result.variables[key] = value.replace(/["']/g, "");
            continue;
          }
          try {
            const parsedEntry = _CronFileParser.#parseEntry(entry);
            result.expressions.push(parsedEntry.interval);
          } catch (err) {
            result.errors[entry] = err;
          }
        }
        return result;
      }
      /**
       * Parse a single crontab entry
       * @private
       */
      static #parseEntry(entry) {
        const atoms = entry.split(" ");
        return {
          interval: CronExpressionParser_1.CronExpressionParser.parse(atoms.slice(0, 5).join(" ")),
          command: atoms.slice(5, atoms.length)
        };
      }
    };
    exports2.CronFileParser = CronFileParser;
  }
});

// node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/cron-parser@5.4.0/node_modules/cron-parser/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CronFileParser = exports2.CronExpressionParser = exports2.CronExpression = exports2.CronFieldCollection = exports2.CronDate = void 0;
    var CronExpressionParser_1 = require_CronExpressionParser();
    var CronDate_1 = require_CronDate();
    Object.defineProperty(exports2, "CronDate", { enumerable: true, get: function() {
      return CronDate_1.CronDate;
    } });
    var CronFieldCollection_1 = require_CronFieldCollection();
    Object.defineProperty(exports2, "CronFieldCollection", { enumerable: true, get: function() {
      return CronFieldCollection_1.CronFieldCollection;
    } });
    var CronExpression_1 = require_CronExpression();
    Object.defineProperty(exports2, "CronExpression", { enumerable: true, get: function() {
      return CronExpression_1.CronExpression;
    } });
    var CronExpressionParser_2 = require_CronExpressionParser();
    Object.defineProperty(exports2, "CronExpressionParser", { enumerable: true, get: function() {
      return CronExpressionParser_2.CronExpressionParser;
    } });
    var CronFileParser_1 = require_CronFileParser();
    Object.defineProperty(exports2, "CronFileParser", { enumerable: true, get: function() {
      return CronFileParser_1.CronFileParser;
    } });
    __exportStar(require_fields(), exports2);
    exports2.default = CronExpressionParser_1.CronExpressionParser;
  }
});

// packages/task-parser/yaml-dsl/parser2.ts
var parser2_exports = {};
__export(parser2_exports, {
  YamlParser: () => YamlParser
});
module.exports = __toCommonJS(parser2_exports);

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports = {};
__export(value_exports, {
  HasPropertyKey: () => HasPropertyKey,
  IsArray: () => IsArray,
  IsAsyncIterator: () => IsAsyncIterator,
  IsBigInt: () => IsBigInt,
  IsBoolean: () => IsBoolean,
  IsDate: () => IsDate,
  IsFunction: () => IsFunction,
  IsIterator: () => IsIterator,
  IsNull: () => IsNull,
  IsNumber: () => IsNumber,
  IsObject: () => IsObject,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString,
  IsSymbol: () => IsSymbol,
  IsUint8Array: () => IsUint8Array,
  IsUndefined: () => IsUndefined
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === void 0;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === void 0 ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === void 0;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== void 0 ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
var TypeBoxError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports = {};
__export(type_exports, {
  IsAny: () => IsAny2,
  IsArgument: () => IsArgument2,
  IsArray: () => IsArray4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsBigInt: () => IsBigInt4,
  IsBoolean: () => IsBoolean4,
  IsComputed: () => IsComputed2,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate4,
  IsFunction: () => IsFunction4,
  IsImport: () => IsImport,
  IsInteger: () => IsInteger3,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator4,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue2,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull4,
  IsNumber: () => IsNumber4,
  IsObject: () => IsObject4,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise3,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString4,
  IsSymbol: () => IsSymbol4,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array4,
  IsUndefined: () => IsUndefined4,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var format_exports = {};
__export(format_exports, {
  Clear: () => Clear,
  Delete: () => Delete,
  Entries: () => Entries,
  Get: () => Get,
  Has: () => Has,
  Set: () => Set2
});
var map = /* @__PURE__ */ new Map();
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format2) {
  return map.delete(format2);
}
function Has(format2) {
  return map.has(format2);
}
function Set2(format2, func) {
  map.set(format2, func);
}
function Get(format2) {
  return map.get(format2);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var type_exports2 = {};
__export(type_exports2, {
  Clear: () => Clear2,
  Delete: () => Delete2,
  Entries: () => Entries2,
  Get: () => Get2,
  Has: () => Has2,
  Set: () => Set3
});
var map2 = /* @__PURE__ */ new Map();
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2; i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0; i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return (
    // unevaluated modifier types
    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : (
        // unevaluated types
        IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T
      )
    )
  );
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult.True : type_exports.IsUnion(right) ? ExtendsResult.Union : type_exports.IsUnknown(right) ? ExtendsResult.True : type_exports.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return type_exports.IsNot(left) ? Visit3(UnwrapTNot(left), right) : type_exports.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports.IsString(left) && IsObjectStringLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsNumber(left) && IsObjectNumberLike(right) || type_exports.IsInteger(left) && IsObjectNumberLike(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports.IsDate(left) && IsObjectDateLike(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : !type_exports.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = type_exports.IsRegExp(left) ? String2() : left;
  const R = type_exports.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult.True : type_exports.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : type_exports.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult.True : type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports.IsTuple(right) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsVoid(right) ? FromVoidRight(left, right) : type_exports.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : type_exports.IsArray(right) ? FromArrayRight(left, right) : type_exports.IsTuple(right) ? FromTupleRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult.True : type_exports.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return (
    // resolvable
    type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot(left, right) : (
      // standard
      type_exports.IsAny(left) ? FromAny(left, right) : type_exports.IsArray(left) ? FromArray4(left, right) : type_exports.IsBigInt(left) ? FromBigInt(left, right) : type_exports.IsBoolean(left) ? FromBoolean(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : type_exports.IsConstructor(left) ? FromConstructor(left, right) : type_exports.IsDate(left) ? FromDate(left, right) : type_exports.IsFunction(left) ? FromFunction(left, right) : type_exports.IsInteger(left) ? FromInteger(left, right) : type_exports.IsIntersect(left) ? FromIntersect4(left, right) : type_exports.IsIterator(left) ? FromIterator(left, right) : type_exports.IsLiteral(left) ? FromLiteral2(left, right) : type_exports.IsNever(left) ? FromNever(left, right) : type_exports.IsNull(left) ? FromNull(left, right) : type_exports.IsNumber(left) ? FromNumber(left, right) : type_exports.IsObject(left) ? FromObject(left, right) : type_exports.IsRecord(left) ? FromRecord(left, right) : type_exports.IsString(left) ? FromString(left, right) : type_exports.IsSymbol(left) ? FromSymbol(left, right) : type_exports.IsTuple(left) ? FromTuple3(left, right) : type_exports.IsPromise(left) ? FromPromise2(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array(left, right) : type_exports.IsUndefined(left) ? FromUndefined(left, right) : type_exports.IsUnion(left) ? FromUnion6(left, right) : type_exports.IsUnknown(left) ? FromUnknown(left, right) : type_exports.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : (
        // Default Type
        CreateType(schema, options)
      )
    )
  );
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return (
    // Modifiers
    IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : (
      // Transform
      IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : (
        // Types
        IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type
      )
    )
  );
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
var TModule = class {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  /** `[Json]` Imports a Type by Key. */
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  // prettier-ignore
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module(properties) {
  return new TModule(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode2 = (value) => schema[TransformKind].Encode(encode(value));
    const Decode2 = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Argument: () => Argument,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean2,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function2,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Instantiate: () => Instantiate,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Module: () => Module,
  Never: () => Never,
  Not: () => Not2,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  String: () => String2,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports3;

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function SetErrorFunction(callback) {
  errorFunction = callback;
}
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
var TypeDereferenceError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
};
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === void 0)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
var ValueHashError = class extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
};
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt(
  "18446744073709551616"
  /* 2 ^ 64 */
)];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0; i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0; i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0; i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
var ValueCheckUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
};
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== void 0;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !(function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  })()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!format_exports.Has(schema.format))
      return false;
    const func = format_exports.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === void 0 && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0; i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!type_exports2.Has(schema[Kind]))
    return false;
  const func = type_exports2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));
var ValueErrorsUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== void 0;
}
var ValueErrorIterator = class {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  /** Returns the first value error or undefined if no errors */
  First() {
    const next = this.iterator.next();
    return next.done ? void 0 : next.value;
  }
};
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {
}
function* FromArgument3(schema, references, path, value) {
}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0; i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !(function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  })()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!format_exports.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format2 = format_exports.Get(schema.format);
      if (!format2(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === void 0 && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0; i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {
}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = type_exports2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
var TransformDecodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformDecodeError = class extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
};
function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray9(schema, references, path, value) {
  return IsArray2(value) ? Default(schema, path, value.map((value2, index) => Visit7(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit7(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromImport3(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit7(target, [...references, ...additional], path, value);
  return Default(schema, path, result);
}
function FromNot4(schema, references, path, value) {
  return Default(schema, path, Visit7(schema.not, references, path, value));
}
function FromObject10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit7(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRecord6(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit7(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRef7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromThis3(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromTuple8(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit7(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit7(subschema, references, path, value);
    return Default(schema, path, decoded);
  }
  return Default(schema, path, value);
}
function Visit7(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, path, value);
    case "Import":
      return FromImport3(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot4(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord6(schema_, references_, path, value);
    case "Ref":
      return FromRef7(schema_, references_, path, value);
    case "Symbol":
      return Default(schema_, path, value);
    case "This":
      return FromThis3(schema_, references_, path, value);
    case "Tuple":
      return FromTuple8(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit7(schema, references, "", value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
var TransformEncodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformEncodeError = class extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
};
function Default2(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray10(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit8(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport4(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default2(schema, path, value);
  return Visit8(target, [...references, ...additional], path, result);
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit8(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot5(schema, references, path, value) {
  return Default2(schema.not, path, Default2(schema, path, value));
}
function FromObject11(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit8(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord7(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit8(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromThis4(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromTuple9(schema, references, path, value) {
  const value1 = Default2(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit8(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit8(subschema, references, path, value);
    return Default2(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit8(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default2(schema, path, value1);
  }
  return Default2(schema, path, value);
}
function Visit8(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, path, value);
    case "Import":
      return FromImport4(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject11(schema_, references_, path, value);
    case "Record":
      return FromRecord7(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "This":
      return FromThis4(schema_, references_, path, value);
    case "Tuple":
      return FromTuple9(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default2(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit8(schema, references, "", value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray11(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromFunction6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit9(schema2, references));
}
function FromImport5(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit9(target, [...additional, ...references]);
}
function FromIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
  return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject12(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit9(schema2, references)) || IsSchema(schema.additionalProperties) && Visit9(schema.additionalProperties, references);
}
function FromPromise6(schema, references) {
  return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord8(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit9(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromThis5(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromTuple10(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit9(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit9(schema2, references));
}
function Visit9(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Not":
      return FromNot6(schema_, references_);
    case "Object":
      return FromObject12(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord8(schema_, references_);
    case "Ref":
      return FromRef9(schema_, references_);
    case "This":
      return FromThis5(schema_, references_);
    case "Tuple":
      return FromTuple10(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = /* @__PURE__ */ new Set();
function HasTransform(schema, references) {
  visited.clear();
  return Visit9(schema, references);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
var TypeCheck = class {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns the schema type used to validate */
  Schema() {
    return this.schema;
  }
  /** Returns reference types used to validate */
  References() {
    return this.references;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value) {
    return this.checkFunc(value);
  }
  /** Decodes a value or throws if error */
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  /** Encodes a value or throws if error */
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
};
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0; i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0; i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));
var TypeCompilerUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
var TypeCompilerTypeGuardError = class extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
};
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArgument5(schema, references, value) {
    yield "true";
  }
  function* FromArray18(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate8(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport11(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple16(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === void 0)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0; i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion21(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value);
      case "Array":
        return yield* FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value);
      case "Date":
        return yield* FromDate8(schema_, references_, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, value);
      case "Import":
        return yield* FromImport11(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject19(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!type_exports2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    // target language
    functions: /* @__PURE__ */ new Map(),
    // local functions
    variables: /* @__PURE__ */ new Map(),
    // local variables
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!type_exports2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = type_exports2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format2, value) {
      if (!format_exports.Has(format2))
        return false;
      const checkFunc = format_exports.Get(format2);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// packages/schema/typebox-utils.ts
SetErrorFunction((error) => {
  if (error.schema.errorMessage && typeof error.schema.errorMessage === "string") return error.schema.errorMessage;
  return DefaultErrorFunction(error);
});
function TBrandedString(options) {
  return Type.String(options);
}
function TBrandedNumber() {
  return Type.Number();
}
function TLiteralUnion(values) {
  const literals = values.map((value) => Type.Literal(value));
  return Type.Union(literals);
}

// packages/utils/verify-exists.ts
function verifyExists(val) {
  if (val === void 0 || val === null) {
    throw new Error("Value does not exist");
  }
  return val;
}

// packages/schema/errors/message.ts
var TStackEntry = Type.Object({
  fileName: Type.String(),
  line: Type.Number(),
  column: Type.Number(),
  name: Type.Optional(Type.String()),
  endLine: Type.Optional(Type.Number()),
  endColumn: Type.Optional(Type.Number())
});
var TUserMessage = Type.Object({
  type: Type.String(),
  message: Type.String(),
  advice: Type.Optional(Type.String()),
  fileName: Type.Optional(Type.String()),
  line: Type.Optional(Type.Number()),
  column: Type.Optional(Type.Number()),
  stackTrace: Type.Optional(Type.Array(TStackEntry)),
  frame: Type.Optional(Type.String())
});
var UserError = class extends Error {
  type;
  messageWithoutFileLocation;
  advice;
  fileName;
  line;
  column;
  stackTrace;
  constructor({ type, message, advice, fileName, line, column, stackTrace, frame }) {
    super(messageWithFileLocation({ message, fileName, line, column, stackTrace, frame }));
    this.type = type;
    this.messageWithoutFileLocation = message;
    this.name = "UserError";
    this.advice = advice;
    this.stackTrace = stackTrace;
    this.fileName = fileName;
    this.line = line;
    this.column = column;
    if (this.stackTrace) {
      const lastStackEntry = verifyExists(this.stackTrace.findLast((e) => e));
      this.fileName = lastStackEntry.fileName;
      this.line = lastStackEntry.line;
      this.column = lastStackEntry.column;
    }
  }
  get messageWithAdvice() {
    return this.advice ? `${this.message}

${this.advice}` : this.message;
  }
  asMessage() {
    const userMessage = { type: this.type, message: this.messageWithoutFileLocation };
    if (this.advice) userMessage.advice = this.advice;
    if (this.fileName) userMessage.fileName = this.fileName;
    if (this.line) userMessage.line = this.line;
    if (this.column) userMessage.column = this.column;
    if (this.stackTrace) userMessage.stackTrace = this.stackTrace;
    return userMessage;
  }
};
function buildMessage({
  type,
  message,
  advice,
  docs,
  fileName,
  line,
  column,
  stackTrace,
  frame
}) {
  if (docs) {
    advice = advice ?? [];
    advice.push(docs);
  }
  const messageStr = message.join("\n");
  const adviceStr = advice?.join("\n");
  const userMessage = { type, message: messageStr };
  if (adviceStr) userMessage.advice = adviceStr;
  if (fileName) userMessage.fileName = fileName;
  if (line !== void 0) userMessage.line = line;
  if (column !== void 0) userMessage.column = column;
  if (stackTrace) {
    userMessage.stackTrace = stackTrace;
    const lastStackEntry = verifyExists(stackTrace.findLast((e) => e));
    userMessage.fileName = lastStackEntry.fileName;
    userMessage.line = lastStackEntry.line;
    userMessage.column = lastStackEntry.column;
  }
  if (frame) userMessage.frame = frame;
  return userMessage;
}
function codeQuote(message) {
  return `\`${message}\``;
}
function indent(message) {
  return message.split("\n").map((line) => `\u2002\u2002${line}`).join("\n");
}
function messageWithFileLocation({
  message,
  fileName,
  line,
  column,
  stackTrace,
  frame
}) {
  if (!stackTrace) {
    const location = [fileName, line, column].filter((l) => l).join(":");
    if (location !== "") {
      return message + `
  at ${location}`;
    } else {
      return message;
    }
  }
  const formattedStackTrace = [...stackTrace].reverse().map((se) => {
    const namePart = se.name ? `${se.name} (${se.fileName}:${se.line}:${se.column})` : `${se.fileName}:${se.line}:${se.column}`;
    return `  at ${namePart}`;
  }).join("\n");
  if (frame) {
    return message + "\n\n" + frame + "\n" + formattedStackTrace;
  } else {
    return message + "\n" + formattedStackTrace;
  }
}

// packages/schema/task-cache/versioned/latest.ts
var TOutputBlob = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest = Object2({
  id: String2(),
  cliVersion: String2(),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact = Composite([
  TOutputBlob,
  Object2({
    manifest: Union([TArtifactManifest, Null()])
  })
]);
var TRetryAction = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact),
  description: Optional(String2())
});
var TImageConfig = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2()),
  workspace: Optional(String2())
});
var TTiming = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming)
    })
  )
});
var TTaskOrGroupId = TBrandedString();
var TDateString = TBrandedString();
var Severity = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity || {});
var TProblemMatcherPattern = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity = Enum(Severity);
var TProblemMatcher = Object2({
  owner: String2(),
  severity: Optional(TSeverity),
  pattern: Array2(TProblemMatcherPattern)
});
var TProblemPath = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestCliVersion: String2(),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus || {});
var BackgroundProcessResultFinishedSubStatus = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus || {});
var TBackgroundProcessResult = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus),
  startedAt: Optional(TDateString),
  completedAt: Optional(TDateString),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey || {});
var TEnvironmentVariables = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey)
  })
);
var TTip = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult = Object2({
  schemaVersion: Literal("v27" /* V27 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask),
  environmentVariables: TEnvironmentVariables,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest),
  whiteoutLayer: Optional(TLayerWithManifest),
  filesystemLayers: Array2(TLayerWithManifest),
  problems: Array2(TProblem),
  testResults: Array2(TTestResults),
  artifacts: Array2(TArtifact),
  outputBlobs: Optional(Array2(TOutputBlob)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps,
  outputRetryActions: Array2(TRetryAction),
  outputImageConfig: TImageConfig,
  dockerLayer: Optional(TLayerWithManifest),
  tips: Array2(TTip)
});

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;
var AssertError = class extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === void 0 ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, void 0);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  /** Returns an iterator for each error in this value. */
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
};
_AssertError_iterator = /* @__PURE__ */ new WeakMap(), _AssertError_instances = /* @__PURE__ */ new WeakSet(), _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject13(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray12(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray12(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject13(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
var ValueCreateError = class extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
};
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray13(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== void 0) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit10(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return (async function* () {
    })();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit10(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== void 0) {
    return new Date(schema.minimumTimestamp);
  } else {
    return /* @__PURE__ */ new Date();
  }
}
function FromFunction7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit10(schema.returns, references);
  }
}
function FromImport6(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit10(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return (function* () {
    })();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit10(subschema, references);
    }
    return Acc;
  }
}
function FromPromise7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit10(schema.item, references));
  }
}
function FromRecord9(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromRef10(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== void 0) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== void 0) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== void 0) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis6(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromTuple11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === void 0) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit10(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromUnion16(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit10(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== void 0) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit10(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor7(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport6(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect14(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject14(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord9(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis6(schema_, references_);
    case "Tuple":
      return FromTuple11(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion16(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit10(args[0], args[1]) : Visit10(args[0], []);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
var ValueCastError = class extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
};
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? 100 : 0;
      const checks = Check(schema2, references, value[key]) ? 10 : 0;
      const exists = keys.includes(key) ? 1 : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default3(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray14(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit11(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor8(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === void 0)
      continue;
    result.prototype[key] = Visit11(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport7(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit11(target, [...references, ...definitions], value);
}
function IntersectAssign(correct, value) {
  if (IsObject2(correct) && !IsObject2(value) || !IsObject2(correct) && IsObject2(value))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value))
    return value;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
}
function FromIntersect15(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value);
  return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject15(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === void 0)
      continue;
    result[key] = Visit11(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit11(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord10(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit11(subschema, references, propValue);
  }
  return result;
}
function FromRef11(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple12(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === void 0)
    return [];
  return schema.items.map((schema2, index) => Visit11(schema2, references, value[index]));
}
function FromUnion17(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit11(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    // --------------------------------------------------------------
    // Structural
    // --------------------------------------------------------------
    case "Array":
      return FromArray14(schema_, references_, value);
    case "Constructor":
      return FromConstructor8(schema_, references_, value);
    case "Import":
      return FromImport7(schema_, references_, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject15(schema_, references_, value);
    case "Record":
      return FromRecord10(schema_, references_, value);
    case "Ref":
      return FromRef11(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple12(schema_, references_, value);
    case "Union":
      return FromUnion17(schema_, references_, value);
    // --------------------------------------------------------------
    // DefaultClone
    // --------------------------------------------------------------
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    // --------------------------------------------------------------
    // Default
    // --------------------------------------------------------------
    default:
      return Default3(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray15(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit12(schema.items, references, value2));
}
function FromImport8(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit12(target, [...references, ...definitions], value);
}
function FromIntersect16(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit12(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit12(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject16(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit12(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord11(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit12(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef12(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromThis8(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromTuple13(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0; i < length; i++) {
    value[i] = Visit12(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion18(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit12(inner, references, value);
    }
  }
  return value;
}
function Visit12(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, value);
    case "Import":
      return FromImport8(schema_, references_, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, value);
    case "Object":
      return FromObject16(schema_, references_, value);
    case "Record":
      return FromRecord11(schema_, references_, value);
    case "Ref":
      return FromRef12(schema_, references_, value);
    case "This":
      return FromThis8(schema_, references_, value);
    case "Tuple":
      return FromTuple13(schema_, references_, value);
    case "Union":
      return FromUnion18(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit12(args[0], args[1], args[2]) : Visit12(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== void 0 ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? void 0 : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
}
function Default4(value) {
  return value;
}
function FromArray16(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit13(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport9(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit13(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect17(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit13(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject17(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit13(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord12(schema, references, value) {
  const isConvertable = IsObject2(value) && !IsArray2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit13(property, references, propValue);
  }
  return value;
}
function FromRef13(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis9(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromTuple14(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit13(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion19(schema, references, value) {
  for (const subschema of schema.anyOf) {
    if (Check(subschema, references, value)) {
      return value;
    }
  }
  for (const subschema of schema.anyOf) {
    const converted = Visit13(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit13(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport9(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect17(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject17(schema_, references_, value);
    case "Record":
      return FromRecord12(schema_, references_, value);
    case "Ref":
      return FromRef13(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis9(schema_, references_, value);
    case "Tuple":
      return FromTuple14(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion19(schema_, references_, value);
    default:
      return Default4(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit13(args[0], args[1], args[2]) : Visit13(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : void 0;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0; i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0; i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0; i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var pointer_exports = {};
__export(pointer_exports, {
  Delete: () => Delete3,
  Format: () => Format,
  Get: () => Get3,
  Has: () => Has3,
  Set: () => Set4,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  ValuePointerRootSetError: () => ValuePointerRootSetError
});
var ValuePointerRootSetError = class extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
};
var ValuePointerRootDeleteError = class extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
};
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0; i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0 || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === void 0)
      return void 0;
    current = current[component];
  }
  return current;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);
var ValueDiffError = class extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
};
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0; i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1; i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        pointer_exports.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}
var ValueMutateError = class extends TypeBoxError {
  constructor(message) {
    super(message);
  }
};
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    pointer_exports.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    pointer_exports.Set(root, path, Clone2(next));
  } else {
    for (let index = 0; index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0; i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    pointer_exports.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  pointer_exports.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
var ParseError = class extends TypeBoxError {
  constructor(message) {
    super(message);
  }
};
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = /* @__PURE__ */ new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.41/node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var value_exports2 = {};
__export(value_exports2, {
  Assert: () => Assert,
  Cast: () => Cast,
  Check: () => Check,
  Clean: () => Clean,
  Clone: () => Clone2,
  Convert: () => Convert,
  Create: () => Create2,
  Decode: () => Decode,
  Default: () => Default5,
  Diff: () => Diff,
  Edit: () => Edit,
  Encode: () => Encode,
  Equal: () => Equal,
  Errors: () => Errors,
  Hash: () => Hash,
  Mutate: () => Mutate,
  Parse: () => Parse,
  Patch: () => Patch,
  ValueErrorIterator: () => ValueErrorIterator
});

// packages/schema/task-cache/versioned/v1.ts
var TTaskOrGroupId2 = TBrandedString();
var TDateString2 = TBrandedString();
var Severity2 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity2 || {});
var TProblemMatcherPattern2 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity2 = Enum(Severity2);
var TProblemMatcher2 = Object2({
  owner: String2(),
  severity: Optional(TSeverity2),
  pattern: Array2(TProblemMatcherPattern2)
});
var TProblemPath2 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem2 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity2,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest2 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId2)
});
var BackgroundProcessResultStatus2 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus2 || {});
var BackgroundProcessResultFinishedSubStatus2 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus2 || {});
var TOldBackgroundProcessResult = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  result: Object2({
    type: Enum(BackgroundProcessResultStatus2),
    startedAt: Optional(TDateString2),
    completedAt: Optional(TDateString2),
    exitCode: Optional(Number2()),
    signal: Optional(String2()),
    subStatus: Optional(Enum(BackgroundProcessResultFinishedSubStatus2)),
    readyCheckStdout: Optional(String2()),
    readyCheckStderr: Optional(String2())
  })
});
var TBackgroundProcessResult2 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus2),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus2),
  startedAt: Optional(TDateString2),
  completedAt: Optional(TDateString2),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact2 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath2 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults2 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask2 = Object2({ sourceFilePath: String2(), source: String2() });
var TCachedTaskResult2 = Object2({
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(Union([TBackgroundProcessResult2, TOldBackgroundProcessResult])),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask2),
  environmentVariables: Record(String2(), String2()),
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest2),
  whiteoutLayer: Optional(TLayerWithManifest2),
  problems: Array2(TProblem2),
  testResults: Array2(TTestResults2),
  artifacts: Optional(Array2(TArtifact2))
  // optional because we have stored cached results that don't have this new field
});

// packages/schema/task-cache/versioned/v2.ts
var TTaskOrGroupId3 = TBrandedString();
var TDateString3 = TBrandedString();
var Severity3 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity3 || {});
var TProblemMatcherPattern3 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity3 = Enum(Severity3);
var TProblemMatcher3 = Object2({
  owner: String2(),
  severity: Optional(TSeverity3),
  pattern: Array2(TProblemMatcherPattern3)
});
var TProblemPath3 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem3 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity3,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest3 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId3)
});
var BackgroundProcessResultStatus3 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus3 || {});
var BackgroundProcessResultFinishedSubStatus3 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus3 || {});
var TBackgroundProcessResult3 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus3),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus3),
  startedAt: Optional(TDateString3),
  completedAt: Optional(TDateString3),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact3 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath3 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults3 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask3 = Object2({ sourceFilePath: String2(), source: String2() });
var TCachedTaskResult3 = Object2({
  schemaVersion: Literal("v2" /* V2 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult3),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask3),
  environmentVariables: Record(String2(), String2()),
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest3),
  whiteoutLayer: Optional(TLayerWithManifest3),
  problems: Array2(TProblem3),
  testResults: Array2(TTestResults3),
  artifacts: Array2(TArtifact3)
});

// packages/schema/task-cache/versioned/v3.ts
var TTaskOrGroupId4 = TBrandedString();
var TDateString4 = TBrandedString();
var Severity4 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity4 || {});
var TProblemMatcherPattern4 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity4 = Enum(Severity4);
var TProblemMatcher4 = Object2({
  owner: String2(),
  severity: Optional(TSeverity4),
  pattern: Array2(TProblemMatcherPattern4)
});
var TProblemPath4 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem4 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity4,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest4 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId4)
});
var BackgroundProcessResultStatus4 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus4 || {});
var BackgroundProcessResultFinishedSubStatus4 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus4 || {});
var TBackgroundProcessResult4 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus4),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus4),
  startedAt: Optional(TDateString4),
  completedAt: Optional(TDateString4),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact4 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath4 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults4 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask4 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey2 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey2 || {});
var TEnvironmentVariables2 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey2)
  })
);
var TCachedTaskResult4 = Object2({
  schemaVersion: Literal("v3" /* V3 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult4),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask4),
  environmentVariables: TEnvironmentVariables2,
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest4),
  whiteoutLayer: Optional(TLayerWithManifest4),
  problems: Array2(TProblem4),
  testResults: Array2(TTestResults4),
  artifacts: Array2(TArtifact4)
});

// packages/schema/task-cache/versioned/v4.ts
var TTaskOrGroupId5 = TBrandedString();
var TDateString5 = TBrandedString();
var Severity5 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity5 || {});
var TProblemMatcherPattern5 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity5 = Enum(Severity5);
var TProblemMatcher5 = Object2({
  owner: String2(),
  severity: Optional(TSeverity5),
  pattern: Array2(TProblemMatcherPattern5)
});
var TProblemPath5 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem5 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity5,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest5 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId5)
});
var BackgroundProcessResultStatus5 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus5 || {});
var BackgroundProcessResultFinishedSubStatus5 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus5 || {});
var TBackgroundProcessResult5 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus5),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus5),
  startedAt: Optional(TDateString5),
  completedAt: Optional(TDateString5),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact5 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath5 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults5 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask5 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey3 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey3 || {});
var TEnvironmentVariables3 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey3)
  })
);
var TCachedTaskResult5 = Object2({
  schemaVersion: Literal("v4" /* V4 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult5),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask5),
  environmentVariables: TEnvironmentVariables3,
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest5),
  whiteoutLayer: Optional(TLayerWithManifest5),
  problems: Array2(TProblem5),
  testResults: Array2(TTestResults5),
  artifacts: Array2(TArtifact5),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/task-cache/versioned/v5.ts
var TTaskOrGroupId6 = TBrandedString();
var TDateString6 = TBrandedString();
var Severity6 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity6 || {});
var TProblemMatcherPattern6 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity6 = Enum(Severity6);
var TProblemMatcher6 = Object2({
  owner: String2(),
  severity: Optional(TSeverity6),
  pattern: Array2(TProblemMatcherPattern6)
});
var TProblemPath6 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem6 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity6,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest6 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId6)
});
var BackgroundProcessResultStatus6 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus6 || {});
var BackgroundProcessResultFinishedSubStatus6 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus6 || {});
var TBackgroundProcessResult6 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus6),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus6),
  startedAt: Optional(TDateString6),
  completedAt: Optional(TDateString6),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact6 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath6 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults6 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask6 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey4 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey4 || {});
var TEnvironmentVariables4 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey4)
  })
);
var TCachedTaskResult6 = Object2({
  schemaVersion: Literal("v5" /* V5 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult6),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask6),
  environmentVariables: TEnvironmentVariables4,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest6),
  whiteoutLayer: Optional(TLayerWithManifest6),
  problems: Array2(TProblem6),
  testResults: Array2(TTestResults6),
  artifacts: Array2(TArtifact6),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/manifests/versioned/version.ts
var SchemaVersion2 = /* @__PURE__ */ ((SchemaVersion4) => {
  SchemaVersion4["V1"] = "v1";
  SchemaVersion4["V2"] = "v2";
  SchemaVersion4["V3"] = "v3";
  SchemaVersion4["V4"] = "v4";
  SchemaVersion4["V5"] = "v5";
  SchemaVersion4["V6"] = "v6";
  SchemaVersion4["V7"] = "v7";
  return SchemaVersion4;
})(SchemaVersion2 || {});

// packages/schema/task-cache/versioned/v6.ts
var TTaskOrGroupId7 = TBrandedString();
var TDateString7 = TBrandedString();
var Severity7 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity7 || {});
var TProblemMatcherPattern7 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity7 = Enum(Severity7);
var TProblemMatcher7 = Object2({
  owner: String2(),
  severity: Optional(TSeverity7),
  pattern: Array2(TProblemMatcherPattern7)
});
var TProblemPath7 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem7 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity7,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest7 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId7)
});
var BackgroundProcessResultStatus7 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus7 || {});
var BackgroundProcessResultFinishedSubStatus7 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus7 || {});
var TBackgroundProcessResult7 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus7),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus7),
  startedAt: Optional(TDateString7),
  completedAt: Optional(TDateString7),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact7 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath7 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults7 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask7 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey5 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey5 || {});
var TEnvironmentVariables5 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey5)
  })
);
var TCachedTaskResult7 = Object2({
  schemaVersion: Literal("v6" /* V6 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult7),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask7),
  environmentVariables: TEnvironmentVariables5,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest7),
  whiteoutLayer: Optional(TLayerWithManifest7),
  problems: Array2(TProblem7),
  testResults: Array2(TTestResults7),
  artifacts: Array2(TArtifact7),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/task-cache/versioned/v7.ts
var TTaskOrGroupId8 = TBrandedString();
var TDateString8 = TBrandedString();
var Severity8 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity8 || {});
var TProblemMatcherPattern8 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity8 = Enum(Severity8);
var TProblemMatcher8 = Object2({
  owner: String2(),
  severity: Optional(TSeverity8),
  pattern: Array2(TProblemMatcherPattern8)
});
var TProblemPath8 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem8 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity8,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest8 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId8)
});
var BackgroundProcessResultStatus8 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus8 || {});
var BackgroundProcessResultFinishedSubStatus8 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus8 || {});
var TBackgroundProcessResult8 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus8),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus8),
  startedAt: Optional(TDateString8),
  completedAt: Optional(TDateString8),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact8 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath8 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults8 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask8 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey6 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey6 || {});
var TEnvironmentVariables6 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey6)
  })
);
var TCachedTaskResult8 = Object2({
  schemaVersion: Literal("v7" /* V7 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult8),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask8),
  environmentVariables: TEnvironmentVariables6,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest8),
  whiteoutLayer: Optional(TLayerWithManifest8),
  filesystemLayers: Array2(TLayerWithManifest8),
  problems: Array2(TProblem8),
  testResults: Array2(TTestResults8),
  artifacts: Array2(TArtifact8),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/task-cache/versioned/v8.ts
var TTaskOrGroupId9 = TBrandedString();
var TDateString9 = TBrandedString();
var Severity9 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity9 || {});
var TProblemMatcherPattern9 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity9 = Enum(Severity9);
var TProblemMatcher9 = Object2({
  owner: String2(),
  severity: Optional(TSeverity9),
  pattern: Array2(TProblemMatcherPattern9)
});
var TProblemPath9 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem9 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity9,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest9 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId9,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus9 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus9 || {});
var BackgroundProcessResultFinishedSubStatus9 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus9 || {});
var TBackgroundProcessResult9 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus9),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus9),
  startedAt: Optional(TDateString9),
  completedAt: Optional(TDateString9),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact9 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath9 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults9 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask9 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey7 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey7 || {});
var TEnvironmentVariables7 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey7)
  })
);
var TCachedTaskResult9 = Object2({
  schemaVersion: Literal("v8" /* V8 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult9),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask9),
  environmentVariables: TEnvironmentVariables7,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest9),
  whiteoutLayer: Optional(TLayerWithManifest9),
  filesystemLayers: Array2(TLayerWithManifest9),
  problems: Array2(TProblem9),
  testResults: Array2(TTestResults9),
  artifacts: Array2(TArtifact9),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/task-cache/versioned/v9.ts
var TTiming2 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps2 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming2)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming2)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming2),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming2),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming2.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming2),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming2),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming2),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming2),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming2),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming2),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming2),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming2)
    })
  )
});
var TTaskOrGroupId10 = TBrandedString();
var TDateString10 = TBrandedString();
var Severity10 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity10 || {});
var TProblemMatcherPattern10 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity10 = Enum(Severity10);
var TProblemMatcher10 = Object2({
  owner: String2(),
  severity: Optional(TSeverity10),
  pattern: Array2(TProblemMatcherPattern10)
});
var TProblemPath10 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem10 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity10,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest10 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId10,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus10 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus10 || {});
var BackgroundProcessResultFinishedSubStatus10 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus10 || {});
var TBackgroundProcessResult10 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus10),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus10),
  startedAt: Optional(TDateString10),
  completedAt: Optional(TDateString10),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact10 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath10 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults10 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask10 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey8 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey8 || {});
var TEnvironmentVariables8 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey8)
  })
);
var TCachedTaskResult10 = Object2({
  schemaVersion: Literal("v9" /* V9 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult10),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask10),
  environmentVariables: TEnvironmentVariables8,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest10),
  whiteoutLayer: Optional(TLayerWithManifest10),
  filesystemLayers: Array2(TLayerWithManifest10),
  problems: Array2(TProblem10),
  testResults: Array2(TTestResults10),
  artifacts: Array2(TArtifact10),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps2
});

// packages/schema/task-cache/versioned/v10.ts
var TTiming3 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps3 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming3)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming3)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming3),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming3),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming3.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming3),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming3),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming3),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming3),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming3),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming3),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming3),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming3)
    })
  )
});
var TTaskOrGroupId11 = TBrandedString();
var TDateString11 = TBrandedString();
var Severity11 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity11 || {});
var TProblemMatcherPattern11 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity11 = Enum(Severity11);
var TProblemMatcher11 = Object2({
  owner: String2(),
  severity: Optional(TSeverity11),
  pattern: Array2(TProblemMatcherPattern11)
});
var TProblemPath11 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem11 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity11,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest11 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId11,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus11 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus11 || {});
var BackgroundProcessResultFinishedSubStatus11 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus11 || {});
var TBackgroundProcessResult11 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus11),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus11),
  startedAt: Optional(TDateString11),
  completedAt: Optional(TDateString11),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact11 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifestContentAddress: Union([String2(), Null()]),
  manifestSizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TTestResultsPath11 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults11 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask11 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey9 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey9 || {});
var TEnvironmentVariables9 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey9)
  })
);
var TCachedTaskResult11 = Object2({
  schemaVersion: Literal("v10" /* V10 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult11),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask11),
  environmentVariables: TEnvironmentVariables9,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest11),
  whiteoutLayer: Optional(TLayerWithManifest11),
  filesystemLayers: Array2(TLayerWithManifest11),
  problems: Array2(TProblem11),
  testResults: Array2(TTestResults11),
  artifacts: Array2(TArtifact11),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps3
});

// packages/schema/task-cache/versioned/v11.ts
var TArtifactManifest2 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TTiming4 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps4 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming4)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming4)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming4),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming4),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming4.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming4),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming4),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming4),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming4),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming4),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming4),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming4),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming4)
    })
  )
});
var TTaskOrGroupId12 = TBrandedString();
var TDateString12 = TBrandedString();
var Severity12 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity12 || {});
var TProblemMatcherPattern12 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity12 = Enum(Severity12);
var TProblemMatcher12 = Object2({
  owner: String2(),
  severity: Optional(TSeverity12),
  pattern: Array2(TProblemMatcherPattern12)
});
var TProblemPath12 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem12 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity12,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest12 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId12,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus12 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus12 || {});
var BackgroundProcessResultFinishedSubStatus12 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus12 || {});
var TBackgroundProcessResult12 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus12),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus12),
  startedAt: Optional(TDateString12),
  completedAt: Optional(TDateString12),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact12 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest2, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TTestResultsPath12 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults12 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask12 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey10 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey10 || {});
var TEnvironmentVariables10 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey10)
  })
);
var TCachedTaskResult12 = Object2({
  schemaVersion: Literal("v11" /* V11 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult12),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask12),
  environmentVariables: TEnvironmentVariables10,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest12),
  whiteoutLayer: Optional(TLayerWithManifest12),
  filesystemLayers: Array2(TLayerWithManifest12),
  problems: Array2(TProblem12),
  testResults: Array2(TTestResults12),
  artifacts: Array2(TArtifact12),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps4
});

// packages/schema/task-cache/versioned/v12.ts
var TArtifactManifest3 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact13 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest3, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction2 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact13)
});
var TTiming5 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps5 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming5)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming5)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming5),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming5),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming5.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming5),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming5),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming5),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming5),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming5),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming5),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming5),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming5)
    })
  )
});
var TTaskOrGroupId13 = TBrandedString();
var TDateString13 = TBrandedString();
var Severity13 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity13 || {});
var TProblemMatcherPattern13 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity13 = Enum(Severity13);
var TProblemMatcher13 = Object2({
  owner: String2(),
  severity: Optional(TSeverity13),
  pattern: Array2(TProblemMatcherPattern13)
});
var TProblemPath13 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem13 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity13,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest13 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId13,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus13 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus13 || {});
var BackgroundProcessResultFinishedSubStatus13 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus13 || {});
var TBackgroundProcessResult13 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus13),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus13),
  startedAt: Optional(TDateString13),
  completedAt: Optional(TDateString13),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath13 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults13 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask13 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey11 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey11 || {});
var TEnvironmentVariables11 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey11)
  })
);
var TCachedTaskResult13 = Object2({
  schemaVersion: Literal("v12" /* V12 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult13),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask13),
  environmentVariables: TEnvironmentVariables11,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest13),
  whiteoutLayer: Optional(TLayerWithManifest13),
  filesystemLayers: Array2(TLayerWithManifest13),
  problems: Array2(TProblem13),
  testResults: Array2(TTestResults13),
  artifacts: Array2(TArtifact13),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps5,
  outputRetryActions: Array2(TRetryAction2),
  dockerLayer: Optional(TLayerWithManifest13)
});

// packages/schema/task-cache/versioned/v13.ts
var TArtifactManifest4 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact14 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest4, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction3 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact14),
  description: Optional(String2())
});
var TTiming6 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps6 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming6)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming6)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming6),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming6),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming6.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming6),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming6),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming6),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming6),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming6),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming6),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming6),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming6)
    })
  )
});
var TTaskOrGroupId14 = TBrandedString();
var TDateString14 = TBrandedString();
var Severity14 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity14 || {});
var TProblemMatcherPattern14 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity14 = Enum(Severity14);
var TProblemMatcher14 = Object2({
  owner: String2(),
  severity: Optional(TSeverity14),
  pattern: Array2(TProblemMatcherPattern14)
});
var TProblemPath14 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem14 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity14,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest14 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId14,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus14 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus14 || {});
var BackgroundProcessResultFinishedSubStatus14 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus14 || {});
var TBackgroundProcessResult14 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus14),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus14),
  startedAt: Optional(TDateString14),
  completedAt: Optional(TDateString14),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath14 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults14 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask14 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey12 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey12 || {});
var TEnvironmentVariables12 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey12)
  })
);
var TCachedTaskResult14 = Object2({
  schemaVersion: Literal("v13" /* V13 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult14),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask14),
  environmentVariables: TEnvironmentVariables12,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest14),
  whiteoutLayer: Optional(TLayerWithManifest14),
  filesystemLayers: Array2(TLayerWithManifest14),
  problems: Array2(TProblem14),
  testResults: Array2(TTestResults14),
  artifacts: Array2(TArtifact14),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps6,
  outputRetryActions: Array2(TRetryAction3),
  dockerLayer: Optional(TLayerWithManifest14)
});

// packages/schema/task-cache/versioned/v14.ts
var TArtifactManifest5 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact15 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest5, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction4 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact15),
  description: Optional(String2())
});
var TTiming7 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps7 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming7)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming7)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming7),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming7),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming7.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming7),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming7),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming7),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming7),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming7),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming7),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming7),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming7)
    })
  )
});
var TTaskOrGroupId15 = TBrandedString();
var TDateString15 = TBrandedString();
var Severity15 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity15 || {});
var TProblemMatcherPattern15 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity15 = Enum(Severity15);
var TProblemMatcher15 = Object2({
  owner: String2(),
  severity: Optional(TSeverity15),
  pattern: Array2(TProblemMatcherPattern15)
});
var TProblemPath15 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem15 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity15,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest15 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId15,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus15 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus15 || {});
var BackgroundProcessResultFinishedSubStatus15 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus15 || {});
var TBackgroundProcessResult15 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus15),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus15),
  startedAt: Optional(TDateString15),
  completedAt: Optional(TDateString15),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath15 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults15 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask15 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey13 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey13 || {});
var TEnvironmentVariables13 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey13)
  })
);
var TTip2 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult15 = Object2({
  schemaVersion: Literal("v14" /* V14 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult15),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask15),
  environmentVariables: TEnvironmentVariables13,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest15),
  whiteoutLayer: Optional(TLayerWithManifest15),
  filesystemLayers: Array2(TLayerWithManifest15),
  problems: Array2(TProblem15),
  testResults: Array2(TTestResults15),
  artifacts: Array2(TArtifact15),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps7,
  outputRetryActions: Array2(TRetryAction4),
  dockerLayer: Optional(TLayerWithManifest15),
  tips: Array2(TTip2)
});

// packages/schema/task-cache/versioned/v15.ts
var TArtifactManifest6 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact16 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest6, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction5 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact16),
  description: Optional(String2())
});
var TTiming8 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps8 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming8)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming8)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming8),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming8),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming8.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming8),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming8),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming8),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming8),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming8),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming8),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming8),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming8)
    })
  )
});
var TTaskOrGroupId16 = TBrandedString();
var TDateString16 = TBrandedString();
var Severity16 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity16 || {});
var TProblemMatcherPattern16 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity16 = Enum(Severity16);
var TProblemMatcher16 = Object2({
  owner: String2(),
  severity: Optional(TSeverity16),
  pattern: Array2(TProblemMatcherPattern16)
});
var TProblemPath16 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem16 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity16,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest16 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId16,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus16 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus16 || {});
var BackgroundProcessResultFinishedSubStatus16 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus16 || {});
var TBackgroundProcessResult16 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus16),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus16),
  startedAt: Optional(TDateString16),
  completedAt: Optional(TDateString16),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath16 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults16 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask16 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey14 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey14 || {});
var TEnvironmentVariables14 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey14)
  })
);
var TTip3 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult16 = Object2({
  schemaVersion: Literal("v15" /* V15 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult16),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask16),
  environmentVariables: TEnvironmentVariables14,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest16),
  whiteoutLayer: Optional(TLayerWithManifest16),
  filesystemLayers: Array2(TLayerWithManifest16),
  problems: Array2(TProblem16),
  testResults: Array2(TTestResults16),
  artifacts: Array2(TArtifact16),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps8,
  outputRetryActions: Array2(TRetryAction5),
  dockerLayer: Optional(TLayerWithManifest16),
  tips: Array2(TTip3)
});

// packages/schema/task-cache/versioned/v16.ts
var TArtifactManifest7 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact17 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest7, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction6 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact17),
  description: Optional(String2())
});
var TTiming9 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps9 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming9)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming9)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming9),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming9),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming9.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming9),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming9),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming9),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming9),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming9),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming9),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming9),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming9)
    })
  )
});
var TTaskOrGroupId17 = TBrandedString();
var TDateString17 = TBrandedString();
var Severity17 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity17 || {});
var TProblemMatcherPattern17 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity17 = Enum(Severity17);
var TProblemMatcher17 = Object2({
  owner: String2(),
  severity: Optional(TSeverity17),
  pattern: Array2(TProblemMatcherPattern17)
});
var TProblemPath17 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem17 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity17,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest17 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId17,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus17 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus17 || {});
var BackgroundProcessResultFinishedSubStatus17 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus17 || {});
var TBackgroundProcessResult17 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus17),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus17),
  startedAt: Optional(TDateString17),
  completedAt: Optional(TDateString17),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath17 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary2 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults17 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary2),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask17 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey15 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey15 || {});
var TEnvironmentVariables15 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey15)
  })
);
var TTip4 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult17 = Object2({
  schemaVersion: Literal("v16" /* V16 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult17),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask17),
  environmentVariables: TEnvironmentVariables15,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest17),
  whiteoutLayer: Optional(TLayerWithManifest17),
  filesystemLayers: Array2(TLayerWithManifest17),
  problems: Array2(TProblem17),
  testResults: Array2(TTestResults17),
  artifacts: Array2(TArtifact17),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps9,
  outputRetryActions: Array2(TRetryAction6),
  dockerLayer: Optional(TLayerWithManifest17),
  tips: Array2(TTip4)
});

// packages/schema/task-cache/versioned/v17.ts
var TArtifactManifest8 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact18 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest8, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction7 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact18),
  description: Optional(String2())
});
var TImageConfig2 = Object2({
  user: Optional(String2())
});
var TTiming10 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps10 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming10)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming10)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming10),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming10),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming10.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming10),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming10),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming10),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming10),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming10),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming10),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming10),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming10)
    })
  )
});
var TTaskOrGroupId18 = TBrandedString();
var TDateString18 = TBrandedString();
var Severity18 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity18 || {});
var TProblemMatcherPattern18 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity18 = Enum(Severity18);
var TProblemMatcher18 = Object2({
  owner: String2(),
  severity: Optional(TSeverity18),
  pattern: Array2(TProblemMatcherPattern18)
});
var TProblemPath18 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem18 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity18,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest18 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId18,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus18 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus18 || {});
var BackgroundProcessResultFinishedSubStatus18 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus18 || {});
var TBackgroundProcessResult18 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus18),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus18),
  startedAt: Optional(TDateString18),
  completedAt: Optional(TDateString18),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath18 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary3 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults18 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary3),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask18 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey16 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey16 || {});
var TEnvironmentVariables16 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey16)
  })
);
var TTip5 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult18 = Object2({
  schemaVersion: Literal("v17" /* V17 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult18),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask18),
  environmentVariables: TEnvironmentVariables16,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest18),
  whiteoutLayer: Optional(TLayerWithManifest18),
  filesystemLayers: Array2(TLayerWithManifest18),
  problems: Array2(TProblem18),
  testResults: Array2(TTestResults18),
  artifacts: Array2(TArtifact18),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps10,
  outputRetryActions: Array2(TRetryAction7),
  outputImageConfig: TImageConfig2,
  dockerLayer: Optional(TLayerWithManifest18),
  tips: Array2(TTip5)
});

// packages/schema/task-cache/versioned/v18.ts
var TArtifactManifest9 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact19 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest9, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction8 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact19),
  description: Optional(String2())
});
var TImageConfig3 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TTiming11 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps11 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming11)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming11)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming11),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming11),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming11.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming11),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming11),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming11),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming11),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming11),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming11),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming11),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming11)
    })
  )
});
var TTaskOrGroupId19 = TBrandedString();
var TDateString19 = TBrandedString();
var Severity19 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity19 || {});
var TProblemMatcherPattern19 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity19 = Enum(Severity19);
var TProblemMatcher19 = Object2({
  owner: String2(),
  severity: Optional(TSeverity19),
  pattern: Array2(TProblemMatcherPattern19)
});
var TProblemPath19 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem19 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity19,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest19 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId19,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus19 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus19 || {});
var BackgroundProcessResultFinishedSubStatus19 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus19 || {});
var TBackgroundProcessResult19 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus19),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus19),
  startedAt: Optional(TDateString19),
  completedAt: Optional(TDateString19),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath19 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary4 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults19 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary4),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask19 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey17 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey17 || {});
var TEnvironmentVariables17 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey17)
  })
);
var TTip6 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult19 = Object2({
  schemaVersion: Literal("v18" /* V18 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult19),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask19),
  environmentVariables: TEnvironmentVariables17,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest19),
  whiteoutLayer: Optional(TLayerWithManifest19),
  filesystemLayers: Array2(TLayerWithManifest19),
  problems: Array2(TProblem19),
  testResults: Array2(TTestResults19),
  artifacts: Array2(TArtifact19),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps11,
  outputRetryActions: Array2(TRetryAction8),
  outputImageConfig: TImageConfig3,
  dockerLayer: Optional(TLayerWithManifest19),
  tips: Array2(TTip6)
});

// packages/schema/task-cache/versioned/v19.ts
var TArtifactManifest10 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact20 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest10, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction9 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact20),
  description: Optional(String2())
});
var TImageConfig4 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TTiming12 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps12 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming12)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming12)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming12),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming12),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming12.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming12),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming12),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming12),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming12),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming12),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming12),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming12),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming12)
    })
  )
});
var TTaskOrGroupId20 = TBrandedString();
var TDateString20 = TBrandedString();
var Severity20 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity20 || {});
var TProblemMatcherPattern20 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity20 = Enum(Severity20);
var TProblemMatcher20 = Object2({
  owner: String2(),
  severity: Optional(TSeverity20),
  pattern: Array2(TProblemMatcherPattern20)
});
var TProblemPath20 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem20 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity20,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest20 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId20,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus20 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus20 || {});
var BackgroundProcessResultFinishedSubStatus20 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus20 || {});
var TBackgroundProcessResult20 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus20),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus20),
  startedAt: Optional(TDateString20),
  completedAt: Optional(TDateString20),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath20 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary5 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults20 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary5),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask20 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey18 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey18 || {});
var TEnvironmentVariables18 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey18)
  })
);
var TTip7 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult20 = Object2({
  schemaVersion: Literal("v19" /* V19 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult20),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask20),
  environmentVariables: TEnvironmentVariables18,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest20),
  whiteoutLayer: Optional(TLayerWithManifest20),
  filesystemLayers: Array2(TLayerWithManifest20),
  problems: Array2(TProblem20),
  testResults: Array2(TTestResults20),
  artifacts: Array2(TArtifact20),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps12,
  outputRetryActions: Array2(TRetryAction9),
  outputImageConfig: TImageConfig4,
  dockerLayer: Optional(TLayerWithManifest20),
  tips: Array2(TTip7)
});

// packages/schema/task-cache/versioned/v20.ts
var TArtifactManifest11 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact21 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest11, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction10 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact21),
  description: Optional(String2())
});
var TImageConfig5 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2()),
  os: Optional(String2())
});
var TTiming13 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps13 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming13)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming13)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming13),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming13),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming13.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming13),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming13),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming13),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming13),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming13),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming13),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming13),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming13)
    })
  )
});
var TTaskOrGroupId21 = TBrandedString();
var TDateString21 = TBrandedString();
var Severity21 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity21 || {});
var TProblemMatcherPattern21 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity21 = Enum(Severity21);
var TProblemMatcher21 = Object2({
  owner: String2(),
  severity: Optional(TSeverity21),
  pattern: Array2(TProblemMatcherPattern21)
});
var TProblemPath21 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem21 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity21,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest21 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId21,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus21 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus21 || {});
var BackgroundProcessResultFinishedSubStatus21 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus21 || {});
var TBackgroundProcessResult21 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus21),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus21),
  startedAt: Optional(TDateString21),
  completedAt: Optional(TDateString21),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath21 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary6 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults21 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary6),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask21 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey19 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey19 || {});
var TEnvironmentVariables19 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey19)
  })
);
var TTip8 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult21 = Object2({
  schemaVersion: Literal("v20" /* V20 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult21),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask21),
  environmentVariables: TEnvironmentVariables19,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest21),
  whiteoutLayer: Optional(TLayerWithManifest21),
  filesystemLayers: Array2(TLayerWithManifest21),
  problems: Array2(TProblem21),
  testResults: Array2(TTestResults21),
  artifacts: Array2(TArtifact21),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps13,
  outputRetryActions: Array2(TRetryAction10),
  outputImageConfig: TImageConfig5,
  dockerLayer: Optional(TLayerWithManifest21),
  tips: Array2(TTip8)
});

// packages/schema/task-cache/versioned/v21.ts
var TArtifactManifest12 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact22 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest12, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction11 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact22),
  description: Optional(String2())
});
var TImageConfig6 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  os: Optional(String2())
});
var TTiming14 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps14 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming14)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming14)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming14),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming14),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming14.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming14),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming14),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming14),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming14),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming14),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming14),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming14),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming14)
    })
  )
});
var TTaskOrGroupId22 = TBrandedString();
var TDateString22 = TBrandedString();
var Severity22 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity22 || {});
var TProblemMatcherPattern22 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity22 = Enum(Severity22);
var TProblemMatcher22 = Object2({
  owner: String2(),
  severity: Optional(TSeverity22),
  pattern: Array2(TProblemMatcherPattern22)
});
var TProblemPath22 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem22 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity22,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest22 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId22,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus22 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus22 || {});
var BackgroundProcessResultFinishedSubStatus22 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus22 || {});
var TBackgroundProcessResult22 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus22),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus22),
  startedAt: Optional(TDateString22),
  completedAt: Optional(TDateString22),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath22 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary7 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults22 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary7),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask22 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey20 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey20 || {});
var TEnvironmentVariables20 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey20)
  })
);
var TTip9 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult22 = Object2({
  schemaVersion: Literal("v21" /* V21 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult22),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask22),
  environmentVariables: TEnvironmentVariables20,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest22),
  whiteoutLayer: Optional(TLayerWithManifest22),
  filesystemLayers: Array2(TLayerWithManifest22),
  problems: Array2(TProblem22),
  testResults: Array2(TTestResults22),
  artifacts: Array2(TArtifact22),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps14,
  outputRetryActions: Array2(TRetryAction11),
  outputImageConfig: TImageConfig6,
  dockerLayer: Optional(TLayerWithManifest22),
  tips: Array2(TTip9)
});

// packages/schema/task-cache/versioned/v22.ts
var TArtifactManifest13 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact23 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest13, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction12 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact23),
  description: Optional(String2())
});
var TImageConfig7 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TTiming15 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps15 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming15)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming15)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming15),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming15),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming15.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming15),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming15),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming15),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming15),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming15),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming15),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming15),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming15)
    })
  )
});
var TTaskOrGroupId23 = TBrandedString();
var TDateString23 = TBrandedString();
var Severity23 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity23 || {});
var TProblemMatcherPattern23 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity23 = Enum(Severity23);
var TProblemMatcher23 = Object2({
  owner: String2(),
  severity: Optional(TSeverity23),
  pattern: Array2(TProblemMatcherPattern23)
});
var TProblemPath23 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem23 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity23,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest23 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId23,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus23 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus23 || {});
var BackgroundProcessResultFinishedSubStatus23 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus23 || {});
var TBackgroundProcessResult23 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus23),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus23),
  startedAt: Optional(TDateString23),
  completedAt: Optional(TDateString23),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath23 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary8 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults23 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary8),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask23 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey21 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey21 || {});
var TEnvironmentVariables21 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey21)
  })
);
var TTip10 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult23 = Object2({
  schemaVersion: Literal("v22" /* V22 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult23),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask23),
  environmentVariables: TEnvironmentVariables21,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest23),
  whiteoutLayer: Optional(TLayerWithManifest23),
  filesystemLayers: Array2(TLayerWithManifest23),
  problems: Array2(TProblem23),
  testResults: Array2(TTestResults23),
  artifacts: Array2(TArtifact23),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps15,
  outputRetryActions: Array2(TRetryAction12),
  outputImageConfig: TImageConfig7,
  dockerLayer: Optional(TLayerWithManifest23),
  tips: Array2(TTip10)
});

// packages/schema/task-cache/versioned/v23.ts
var TArtifactManifest14 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact24 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest14, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction13 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact24),
  description: Optional(String2())
});
var TImageConfig8 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TTiming16 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps16 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming16)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming16)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming16),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming16),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming16.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming16),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming16),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming16),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming16),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming16),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming16),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming16),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming16)
    })
  )
});
var TTaskOrGroupId24 = TBrandedString();
var TDateString24 = TBrandedString();
var Severity24 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity24 || {});
var TProblemMatcherPattern24 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity24 = Enum(Severity24);
var TProblemMatcher24 = Object2({
  owner: String2(),
  severity: Optional(TSeverity24),
  pattern: Array2(TProblemMatcherPattern24)
});
var TProblemPath24 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem24 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity24,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest24 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId24,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus24 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus24 || {});
var BackgroundProcessResultFinishedSubStatus24 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus24 || {});
var TBackgroundProcessResult24 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus24),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus24),
  startedAt: Optional(TDateString24),
  completedAt: Optional(TDateString24),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath24 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary9 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults24 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary9),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask24 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey22 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey22 || {});
var TEnvironmentVariables22 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey22)
  })
);
var TTip11 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult24 = Object2({
  schemaVersion: Literal("v23" /* V23 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult24),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask24),
  environmentVariables: TEnvironmentVariables22,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest24),
  whiteoutLayer: Optional(TLayerWithManifest24),
  filesystemLayers: Array2(TLayerWithManifest24),
  problems: Array2(TProblem24),
  testResults: Array2(TTestResults24),
  artifacts: Array2(TArtifact24),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps16,
  outputRetryActions: Array2(TRetryAction13),
  outputImageConfig: TImageConfig8,
  dockerLayer: Optional(TLayerWithManifest24),
  tips: Array2(TTip11)
});

// packages/schema/task-cache/versioned/v24.ts
var TArtifactManifest15 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact25 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("playwright-trace"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest15, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction14 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact25),
  description: Optional(String2())
});
var TImageConfig9 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TTiming17 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps17 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming17)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming17)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming17),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming17),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming17.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming17),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming17),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming17),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming17),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming17),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming17),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming17),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming17)
    })
  )
});
var TTaskOrGroupId25 = TBrandedString();
var TDateString25 = TBrandedString();
var Severity25 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity25 || {});
var TProblemMatcherPattern25 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity25 = Enum(Severity25);
var TProblemMatcher25 = Object2({
  owner: String2(),
  severity: Optional(TSeverity25),
  pattern: Array2(TProblemMatcherPattern25)
});
var TProblemPath25 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem25 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity25,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest25 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId25,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus25 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus25 || {});
var BackgroundProcessResultFinishedSubStatus25 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus25 || {});
var TBackgroundProcessResult25 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus25),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus25),
  startedAt: Optional(TDateString25),
  completedAt: Optional(TDateString25),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath25 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary10 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults25 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary10),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask25 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey23 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey23 || {});
var TEnvironmentVariables23 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey23)
  })
);
var TTip12 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult25 = Object2({
  schemaVersion: Literal("v24" /* V24 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult25),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask25),
  environmentVariables: TEnvironmentVariables23,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest25),
  whiteoutLayer: Optional(TLayerWithManifest25),
  filesystemLayers: Array2(TLayerWithManifest25),
  problems: Array2(TProblem25),
  testResults: Array2(TTestResults25),
  artifacts: Array2(TArtifact25),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps17,
  outputRetryActions: Array2(TRetryAction14),
  outputImageConfig: TImageConfig9,
  dockerLayer: Optional(TLayerWithManifest25),
  tips: Array2(TTip12)
});

// packages/schema/task-cache/versioned/v25.ts
var TOutputBlob2 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest16 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact26 = Composite([
  TOutputBlob2,
  Object2({
    manifest: Union([TArtifactManifest16, Null()])
  })
]);
var TRetryAction15 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact26),
  description: Optional(String2())
});
var TImageConfig10 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TTiming18 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps18 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming18)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming18)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming18),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming18),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming18.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming18),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming18),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming18),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming18),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming18),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming18),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming18),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming18)
    })
  )
});
var TTaskOrGroupId26 = TBrandedString();
var TDateString26 = TBrandedString();
var Severity26 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity26 || {});
var TProblemMatcherPattern26 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity26 = Enum(Severity26);
var TProblemMatcher26 = Object2({
  owner: String2(),
  severity: Optional(TSeverity26),
  pattern: Array2(TProblemMatcherPattern26)
});
var TProblemPath26 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem26 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity26,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest26 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId26,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus26 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus26 || {});
var BackgroundProcessResultFinishedSubStatus26 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus26 || {});
var TBackgroundProcessResult26 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus26),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus26),
  startedAt: Optional(TDateString26),
  completedAt: Optional(TDateString26),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath26 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary11 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults26 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary11),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask26 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey24 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey24 || {});
var TEnvironmentVariables24 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey24)
  })
);
var TTip13 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult26 = Object2({
  schemaVersion: Literal("v25" /* V25 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult26),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask26),
  environmentVariables: TEnvironmentVariables24,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest26),
  whiteoutLayer: Optional(TLayerWithManifest26),
  filesystemLayers: Array2(TLayerWithManifest26),
  problems: Array2(TProblem26),
  testResults: Array2(TTestResults26),
  artifacts: Array2(TArtifact26),
  outputBlobs: Optional(Array2(TOutputBlob2)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps18,
  outputRetryActions: Array2(TRetryAction15),
  outputImageConfig: TImageConfig10,
  dockerLayer: Optional(TLayerWithManifest26),
  tips: Array2(TTip13)
});

// packages/schema/task-cache/versioned/v26.ts
var TOutputBlob3 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest17 = Object2({
  id: String2(),
  cliVersion: String2(),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact27 = Composite([
  TOutputBlob3,
  Object2({
    manifest: Union([TArtifactManifest17, Null()])
  })
]);
var TRetryAction16 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact27),
  description: Optional(String2())
});
var TImageConfig11 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TTiming19 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps19 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming19)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming19)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming19),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming19),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming19.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming19),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming19),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming19),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming19),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming19),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming19),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming19),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming19)
    })
  )
});
var TTaskOrGroupId27 = TBrandedString();
var TDateString27 = TBrandedString();
var Severity27 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity27 || {});
var TProblemMatcherPattern27 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity27 = Enum(Severity27);
var TProblemMatcher27 = Object2({
  owner: String2(),
  severity: Optional(TSeverity27),
  pattern: Array2(TProblemMatcherPattern27)
});
var TProblemPath27 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem27 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity27,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest27 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestCliVersion: String2(),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId27,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus27 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus27 || {});
var BackgroundProcessResultFinishedSubStatus27 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus27 || {});
var TBackgroundProcessResult27 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus27),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus27),
  startedAt: Optional(TDateString27),
  completedAt: Optional(TDateString27),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath27 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() })),
  isDiscovered: Optional(Boolean2())
});
var TTestResultsSummary12 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  flaky: Optional(Number2()),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults27 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary12),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask27 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey25 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey25 || {});
var TEnvironmentVariables25 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey25)
  })
);
var TTip14 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult27 = Object2({
  schemaVersion: Literal("v26" /* V26 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult27),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask27),
  environmentVariables: TEnvironmentVariables25,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest27),
  whiteoutLayer: Optional(TLayerWithManifest27),
  filesystemLayers: Array2(TLayerWithManifest27),
  problems: Array2(TProblem27),
  testResults: Array2(TTestResults27),
  artifacts: Array2(TArtifact27),
  outputBlobs: Optional(Array2(TOutputBlob3)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps19,
  outputRetryActions: Array2(TRetryAction16),
  outputImageConfig: TImageConfig11,
  dockerLayer: Optional(TLayerWithManifest27),
  tips: Array2(TTip14)
});

// packages/utils/type-assertions.ts
function assertType(_) {
}
function assertExhaustive(_) {
  throw new Error("not exhaustive");
}
assertType(true);
assertType(true);
assertType(true);
assertType(false);
assertType(false);
assertType(true);
assertType(false);
assertType(true);
assertType(true);
assertType(true);
assertType(true);
assertType(true);
assertType(true);

// packages/schema/task-cache/index.ts
var TVersionedCachedTaskResult = Type.Union([
  TCachedTaskResult,
  TCachedTaskResult27,
  TCachedTaskResult26,
  TCachedTaskResult25,
  TCachedTaskResult24,
  TCachedTaskResult23,
  TCachedTaskResult22,
  TCachedTaskResult21,
  TCachedTaskResult20,
  TCachedTaskResult19,
  TCachedTaskResult18,
  TCachedTaskResult17,
  TCachedTaskResult16,
  TCachedTaskResult15,
  TCachedTaskResult14,
  TCachedTaskResult13,
  TCachedTaskResult12,
  TCachedTaskResult11,
  TCachedTaskResult10,
  TCachedTaskResult9,
  TCachedTaskResult8,
  TCachedTaskResult7,
  TCachedTaskResult6,
  TCachedTaskResult5,
  TCachedTaskResult4,
  TCachedTaskResult3,
  TCachedTaskResult2
]);
var TVersionedCachedTaskResultChecker = TypeCompiler.Compile(TVersionedCachedTaskResult);

// packages/schema/strings.ts
var TContentAddress = TBrandedString();
var TTaskOrGroupId28 = TBrandedString();
var TGraphNodeId = TBrandedString();
var TTemplateString = TBrandedString();
var TEvaluatedString = TBrandedString();
var TDateString28 = TBrandedString();
var TEpochSeconds = TBrandedNumber();
var TScopedTaskKey = TBrandedString();

// packages/schema/initialization-parameters.ts
var TInitializationParameters = Type.Record(Type.String(), TEvaluatedString);

// packages/schema/persisted/versioned/latest.ts
var ThisSchemaVersion = "v95" /* V95 */;
var TTaskOrGroupId29 = TBrandedString();
var TGraphNodeId2 = TBrandedString();
var TTemplateString2 = TBrandedString();
var TEvaluatedString2 = TBrandedString();
var TDateString29 = TBrandedString();
var TEpochSeconds2 = TBrandedNumber();
var TScopedTaskKey2 = TBrandedString();
var TaskType = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType || {});
var TaskResultStatus = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus || {});
var TaskExecutionStatus = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus || {});
var TaskExecutionWaitingSubStatus = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus || {});
var TaskExecutionAbortedSubStatus = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus || {});
var TaskExecutionFinishedSubStatus = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus || {});
var TaskAttemptReason = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason || {});
var BackgroundProcessResultStatus28 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus28 || {});
var BackgroundProcessResultFinishedSubStatus28 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus28 || {});
var RunResultStatus = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus || {});
var RunExecutionStatus = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus || {});
var RunExecutionWaitingSubStatus = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus || {});
var RunExecutionAbortedSubStatus = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus || {});
var RunExecutionFinishedSubStatus = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus || {});
var GitClonePatchStatus = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus || {});
var TSource = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey26 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey26 || {});
var TExpandedEnvDescriptor = Object2({ value: Optional(TTemplateString2), cacheKey: Enum(EnvironmentVariableCacheKey26) });
var TEnvMergeStrategy = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath28 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern28 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity28 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity28 || {});
var TProblemMatcher28 = Object2({ owner: String2(), severity: Optional(Enum(Severity28)), pattern: Array2(TProblemMatcherPattern28) });
var TProblemPath28 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath = Object2({ key: String2(), path: TTemplateString2 });
var TResolvedArtifactPath = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck = Object2({ run: TTemplateString2, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess = Object2({
  key: String2(),
  command: TTemplateString2,
  readyCheck: Optional(TExpandedReadyCheck),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType || {});
var TParallelismValue = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification = Object2({
  cpus: Optional(TTemplateString2),
  memory: Optional(TTemplateString2),
  disk: Object2({ size: Optional(TTemplateString2) }),
  staticIps: Optional(TTemplateString2),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  ipv6: Optional(TTemplateString2)
});
var TResolvedAgentSpecification = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2(),
  ipv6: Optional(Boolean2())
});
var TTaskDefinitionOutputs = Object2({
  values: Optional(Record(String2(), TTemplateString2)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor = Object2({ path: TTemplateString2, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet = Union([TTemplateString2, Array2(Union([TTemplateString2, TFilterDescriptor]))]);
var TInputFilesystemFilter = Object2({
  workspace: Optional(TFilterSet),
  artifacts: Optional(Record(TTemplateString2, TFilterSet))
});
var TOutputFilesystemFilter = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration = Object2({
  enabled: TTemplateString2,
  ttl: Optional(TTemplateString2)
});
var TTaskDefinitionWithoutParallel = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification),
  type: Optional(Enum(TaskType)),
  after: Optional(TTemplateString2),
  if: Optional(TTemplateString2),
  source: Optional(TSource),
  cacheConfiguration: TCacheConfiguration,
  docker: Optional(TTemplateString2),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString2),
  filter: Optional(TInputFilesystemFilter),
  backgroundProcesses: Optional(Array2(TBackgroundProcess)),
  toolCache: Optional(TTemplateString2),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor)),
  envMerge: Optional(Array2(TEnvMergeStrategy)),
  timeout: Optional(TTemplateString2),
  healthTimeout: Optional(TTemplateString2),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath28)),
  artifactPaths: Optional(Array2(TArtifactPath)),
  outputs: Optional(TTaskDefinitionOutputs),
  problemMatchers: Optional(Array2(TProblemMatcher28)),
  problemPaths: Optional(Array2(TProblemPath28)),
  parallelismType: Optional(Enum(ParallelismType)),
  parallelismValue: Optional(TParallelismValue),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString2)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString2),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString2),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString2,
      if: Optional(TTemplateString2),
      action: Optional(TTemplateString2)
    })
  ),
  autoCancel: TTemplateString2
});
var TCrossRunSource = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource,
  relativeScopedKey: String2()
});
var TTaskDefinition = Composite([
  TTaskDefinitionWithoutParallel,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel),
    parallelKey: Optional(TTemplateString2),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString2), TTemplateString2]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString2)), TTemplateString2])),
    parallelismTotal: Optional(TTemplateString2)
  })
]);
var TLayerWithManifest28 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestCliVersion: String2(),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId29,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext = Union([String2(), Record(String2(), Any())]);
var TUsedSecret = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString2,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString2,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult28 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus28),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus28),
  startedAt: Optional(TDateString29),
  completedAt: Optional(TDateString29),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem28 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity28),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary13 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults28 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary13),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TOutputBlob4 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest18 = Object2({
  id: String2(),
  cliVersion: String2(),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact28 = Composite([
  TOutputBlob4,
  Object2({
    manifest: Union([TArtifactManifest18, Null()])
  })
]);
var TReferencedArtifact = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor))
      })
    )
  )
});
var TDefaultStatusCheck = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow || {});
var TConcurrencyPool = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow) });
var LeaseState = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState || {});
var TTiming20 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps20 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming20)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming20),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming20),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming20.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming20),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming20),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming20),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming20),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming20),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming20),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming20),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming20)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming20.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2()),
  workspace: Optional(String2())
});
var TResolvedImageConfig = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2()),
  workspace: String2()
});
var TRetryAction17 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact28)
});
var TBaseLayer = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit || {});
var TTTL = Object2({
  value: Number2(),
  unit: Enum(TTLUnit)
});
var TResolvedWriteCacheConfiguration = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration = Object2({
  enabled: Boolean2()
});
var TTip15 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask = Object2({
  schemaVersion: Literal(ThisSchemaVersion),
  taskId: TTaskOrGroupId29,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId2),
  generatorTaskId: Optional(TTaskOrGroupId29),
  definition: TTaskDefinition,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus),
  resultStatus: Enum(TaskResultStatus),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason)),
  attemptCounts: Record(TRetryCategory, Number2()),
  resolvedAt: Optional(TDateString29),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString29),
  debugReadyAt: Optional(TDateString29),
  debugStartedAt: Optional(TDateString29),
  debugEndedAt: Optional(TDateString29),
  cancellationRequestedAt: Optional(TDateString29),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString29),
  cancelledAt: Optional(TDateString29),
  concurrencyPool: Optional(TConcurrencyPool),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext),
  usedSecrets: Optional(Array2(TUsedSecret)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString2, cacheKey: Enum(EnvironmentVariableCacheKey26) }))),
  resolvedCommand: Optional(TEvaluatedString2),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest28)),
  previousLayers: Optional(Array2(TLayerWithManifest28)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest28)),
  resolvedImageConfig: Optional(TResolvedImageConfig),
  filesystemLayers: Optional(Array2(TLayerWithManifest28)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString2)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration),
      baseConfig: TResolvedBaseConfig,
      crossRunSource: Optional(TCrossRunSource)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult28)),
  whiteoutLayer: Optional(TLayerWithManifest28),
  outputLayers: Optional(Array2(TLayerWithManifest28)),
  outputImageConfig: Optional(TOutputImageConfig),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey26) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem28)),
  testResults: Optional(Array2(TTestResults28)),
  artifacts: Optional(Array2(TArtifact28)),
  outputBlobs: Optional(Array2(TOutputBlob4)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents),
  tips: Array2(TTip15),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps20,
  networkTraffic: TNetworkTraffic,
  outputRetryActions: Array2(TRetryAction17),
  retryAction: Optional(TRetryAction17),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest28),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString29),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2()),
  resolvedAutoCancel: Optional(Boolean2())
});
var TRetryManifestEntry = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString29,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString29),
  mostRecentlyAttemptedAt: Optional(TDateString29),
  finishedAt: Optional(TDateString29),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory
});
var TGraphRoots = Object2({ resolution: Array2(TGraphNodeId2), runtime: Array2(TGraphNodeId2) });
var TRunGraph = Object2({
  roots: TGraphRoots,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId2, Array2(TGraphNodeId2)),
    runtime: Record(TGraphNodeId2, Array2(TGraphNodeId2))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId2, Array2(TGraphNodeId2)),
    runtime: Record(TGraphNodeId2, Array2(TGraphNodeId2))
  }),
  subgraphs: Record(TGraphNodeId2, Object2({ roots: TGraphRoots })),
  parents: Record(TGraphNodeId2, TGraphNodeId2),
  definitionOrders: Record(TGraphNodeId2, Number2())
});
var TActor = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState)
});
var ApprovalRequestState = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState || {});
var TApprovalRequest = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState)
});
var TRun = Object2({
  schemaVersion: Literal(ThisSchemaVersion),
  persistenceExpiresAtSeconds: TEpochSeconds2,
  runId: String2(),
  createdAt: TDateString29,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor),
  mintDirectoryArtifact: Optional(TArtifact28),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck,
  customStatusChecks: Array2(TCustomStatusCheck),
  trigger: String2(),
  concurrencyPool: Optional(TConcurrencyPool),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration),
  eventNumber: Number2(),
  retries: Array2(TRetry),
  approvalRequests: Array2(TApprovalRequest),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey2, TConcurrencyPoolState),
  baseConfig: Optional(TResolvedBaseConfig),
  crossRunSource: TCrossRunSource,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus),
  resultStatus: Enum(RunResultStatus),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString29),
  waitingForManualStartAt: Optional(TDateString29),
  startedAt: Optional(TDateString29),
  cancellationRequestedAt: Optional(TDateString29),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString29),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v39.ts
var ThisSchemaVersion2 = "v39" /* V39 */;
var TTaskOrGroupId30 = TBrandedString();
var TGraphNodeId3 = TBrandedString();
var TTemplateString3 = TBrandedString();
var TEvaluatedString3 = TBrandedString();
var TDateString30 = TBrandedString();
var TEpochSeconds3 = TBrandedNumber();
var TScopedTaskKey3 = TBrandedString();
var TaskType2 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType2 || {});
var TaskResultStatus2 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus2 || {});
var TaskExecutionStatus2 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus2 || {});
var TaskExecutionWaitingSubStatus2 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus2 || {});
var TaskExecutionAbortedSubStatus2 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus2 || {});
var TaskExecutionFinishedSubStatus2 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus2 || {});
var TaskAttemptReason2 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason2 || {});
var BackgroundProcessResultStatus29 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus29 || {});
var BackgroundProcessResultFinishedSubStatus29 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus29 || {});
var RunResultStatus2 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus2 || {});
var RunExecutionStatus2 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus2 || {});
var RunExecutionWaitingSubStatus2 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus2 || {});
var RunExecutionAbortedSubStatus2 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus2 || {});
var RunExecutionFinishedSubStatus2 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus2 || {});
var TSource2 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey27 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey27 || {});
var TExpandedEnvDescriptor2 = Object2({ value: Optional(TTemplateString3), cacheKey: Enum(EnvironmentVariableCacheKey27) });
var TEnvMergeStrategy2 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath29 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern29 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity29 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity29 || {});
var TProblemMatcher29 = Object2({ owner: String2(), severity: Optional(Enum(Severity29)), pattern: Array2(TProblemMatcherPattern29) });
var TProblemPath29 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath2 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck2 = Object2({ run: TTemplateString3, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess2 = Object2({
  key: String2(),
  command: TTemplateString3,
  readyCheck: Optional(TExpandedReadyCheck2),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType2 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType2 || {});
var TParallelismValue2 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification2 = Object2({
  cpus: Optional(TTemplateString3),
  memory: Optional(TTemplateString3),
  disk: Object2({ size: Optional(TTemplateString3) }),
  staticIps: Optional(TTemplateString3)
});
var TResolvedAgentSpecification2 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2()))
});
var TTaskDefinitionOutputs2 = Object2({
  values: Optional(Record(String2(), TTemplateString3)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter2 = Object2({
  workspace: Optional(Union([Array2(TTemplateString3), TTemplateString3])),
  artifacts: Optional(Record(TTemplateString3, Union([Array2(TTemplateString3), TTemplateString3])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter2 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel2 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification2),
  type: Optional(Enum(TaskType2)),
  after: Optional(TTemplateString3),
  if: Optional(TTemplateString3),
  source: Optional(TSource2),
  allowCacheHit: Optional(TTemplateString3),
  docker: Optional(TTemplateString3),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString3),
  filter: Optional(TInputFilesystemFilter2),
  backgroundProcesses: Optional(Array2(TBackgroundProcess2)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor2)),
  envMerge: Optional(Array2(TEnvMergeStrategy2)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath29)),
  artifactPaths: Optional(Array2(TArtifactPath2)),
  outputs: Optional(TTaskDefinitionOutputs2),
  problemMatchers: Optional(Array2(TProblemMatcher29)),
  problemPaths: Optional(Array2(TProblemPath29)),
  parallelismType: Optional(Enum(ParallelismType2)),
  parallelismValue: Optional(TParallelismValue2),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString3)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString3),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter2)
});
var TTaskDefinition2 = Composite([
  TTaskDefinitionWithoutParallel2,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel2),
    parallelKey: Optional(TTemplateString3),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString3), TTemplateString3]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString3)), TTemplateString3])),
    parallelismTotal: Optional(TTemplateString3)
  })
]);
var TLayerWithManifest29 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId30,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext2 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret2 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess2 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString3,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString3,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer2 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult29 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus29),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus29),
  startedAt: Optional(TDateString30),
  completedAt: Optional(TDateString30),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem29 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity29),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults29 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest19 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact29 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest19, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact2 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration2 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow2 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow2 || {});
var TConcurrencyPool2 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow2) });
var LeaseState2 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState2 || {});
var TTiming21 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps21 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming21)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming21)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming21),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming21),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming21.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming21),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming21),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming21),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming21),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming21),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming21),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming21),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming21)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming21.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic2 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction18 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact29)
});
var TTask2 = Object2({
  schemaVersion: Literal(ThisSchemaVersion2),
  taskId: TTaskOrGroupId30,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId3),
  generatorTaskId: Optional(TTaskOrGroupId30),
  definition: TTaskDefinition2,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus2),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus2),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus2),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus2),
  resultStatus: Enum(TaskResultStatus2),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason2)),
  resolvedAt: Optional(TDateString30),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString30),
  debugReadyAt: Optional(TDateString30),
  debugStartedAt: Optional(TDateString30),
  debugEndedAt: Optional(TDateString30),
  cancellationRequestedAt: Optional(TDateString30),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString30),
  cancelledAt: Optional(TDateString30),
  concurrencyPool: Optional(TConcurrencyPool2),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext2),
  usedSecrets: Optional(Array2(TUsedSecret2)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString3, cacheKey: Enum(EnvironmentVariableCacheKey27) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString3),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess2)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact2)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest29)),
  previousLayers: Optional(Array2(TLayerWithManifest29)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest29)),
  filesystemLayers: Optional(Array2(TLayerWithManifest29)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString3)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration2) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification2),
  accessedVaultIds: Optional(Array2(String2())),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult29)),
  whiteoutLayer: Optional(TLayerWithManifest29),
  outputLayers: Optional(Array2(TLayerWithManifest29)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey27) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem29)),
  testResults: Optional(Array2(TTestResults29)),
  artifacts: Optional(Array2(TArtifact29)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps21,
  networkTraffic: TNetworkTraffic2,
  outputRetryActions: Array2(TRetryAction18),
  retryAction: Optional(TRetryAction18),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  dockerLayer: Optional(TLayerWithManifest29)
});
var TRetryManifestEntry2 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetryTaskRequest = Object2({
  id: String2(),
  createdAt: TDateString30,
  taskId: String2(),
  retryManifest: Optional(Array2(TRetryManifestEntry2)),
  status: String2(),
  lastAttemptedAt: Optional(TDateString30),
  processedAt: Optional(TDateString30),
  message: Optional(String2()),
  newTaskId: Optional(String2()),
  retryActionKey: Optional(String2()),
  debug: Optional(Boolean2())
});
var TRetry2 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString30,
  startedAt: Optional(TDateString30),
  mostRecentlyAttemptedAt: Optional(TDateString30),
  finishedAt: Optional(TDateString30),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots2 = Object2({ resolution: Array2(TGraphNodeId3), runtime: Array2(TGraphNodeId3) });
var TRunGraph2 = Object2({
  roots: TGraphRoots2,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId3, Array2(TGraphNodeId3)),
    runtime: Record(TGraphNodeId3, Array2(TGraphNodeId3))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId3, Array2(TGraphNodeId3)),
    runtime: Record(TGraphNodeId3, Array2(TGraphNodeId3))
  }),
  subgraphs: Record(TGraphNodeId3, Object2({ roots: TGraphRoots2 })),
  parents: Record(TGraphNodeId3, TGraphNodeId3),
  definitionOrders: Record(TGraphNodeId3, Number2())
});
var TActor2 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState2 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState2)
});
var TRun2 = Object2({
  schemaVersion: Literal(ThisSchemaVersion2),
  persistenceExpiresAtSeconds: TEpochSeconds3,
  runId: String2(),
  createdAt: TDateString30,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor2),
  mintDirectoryArtifact: Optional(TArtifact29),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool2),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration2),
  eventNumber: Number2(),
  retryTaskRequests: Array2(TRetryTaskRequest),
  retries: Optional(Array2(TRetry2)),
  retryBatches: Optional(Array2(TRetry2)),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph2,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry2)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey3, TConcurrencyPoolState2),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus2),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus2),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus2),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus2),
  resultStatus: Enum(RunResultStatus2),
  waitingForLeaseAt: Optional(TDateString30),
  startedAt: Optional(TDateString30),
  cancellationRequestedAt: Optional(TDateString30),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString30)
});

// packages/schema/persisted/versioned/v40.ts
var ThisSchemaVersion3 = "v40" /* V40 */;
var TTaskOrGroupId31 = TBrandedString();
var TGraphNodeId4 = TBrandedString();
var TTemplateString4 = TBrandedString();
var TEvaluatedString4 = TBrandedString();
var TDateString31 = TBrandedString();
var TEpochSeconds4 = TBrandedNumber();
var TScopedTaskKey4 = TBrandedString();
var TaskType3 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType3 || {});
var TaskResultStatus3 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus3 || {});
var TaskExecutionStatus3 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus3 || {});
var TaskExecutionWaitingSubStatus3 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus3 || {});
var TaskExecutionAbortedSubStatus3 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus3 || {});
var TaskExecutionFinishedSubStatus3 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus3 || {});
var TaskAttemptReason3 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason3 || {});
var BackgroundProcessResultStatus30 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus30 || {});
var BackgroundProcessResultFinishedSubStatus30 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus30 || {});
var RunResultStatus3 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus3 || {});
var RunExecutionStatus3 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus3 || {});
var RunExecutionWaitingSubStatus3 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus3 || {});
var RunExecutionAbortedSubStatus3 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus3 || {});
var RunExecutionFinishedSubStatus3 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus3 || {});
var TSource3 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey28 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey28 || {});
var TExpandedEnvDescriptor3 = Object2({ value: Optional(TTemplateString4), cacheKey: Enum(EnvironmentVariableCacheKey28) });
var TEnvMergeStrategy3 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath30 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern30 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity30 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity30 || {});
var TProblemMatcher30 = Object2({ owner: String2(), severity: Optional(Enum(Severity30)), pattern: Array2(TProblemMatcherPattern30) });
var TProblemPath30 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath3 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck3 = Object2({ run: TTemplateString4, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess3 = Object2({
  key: String2(),
  command: TTemplateString4,
  readyCheck: Optional(TExpandedReadyCheck3),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType3 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType3 || {});
var TParallelismValue3 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification3 = Object2({
  cpus: Optional(TTemplateString4),
  memory: Optional(TTemplateString4),
  disk: Object2({ size: Optional(TTemplateString4) }),
  staticIps: Optional(TTemplateString4),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification3 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs3 = Object2({
  values: Optional(Record(String2(), TTemplateString4)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter3 = Object2({
  workspace: Optional(Union([Array2(TTemplateString4), TTemplateString4])),
  artifacts: Optional(Record(TTemplateString4, Union([Array2(TTemplateString4), TTemplateString4])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter3 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel3 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification3),
  type: Optional(Enum(TaskType3)),
  after: Optional(TTemplateString4),
  if: Optional(TTemplateString4),
  source: Optional(TSource3),
  allowCacheHit: Optional(TTemplateString4),
  docker: Optional(TTemplateString4),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString4),
  filter: Optional(TInputFilesystemFilter3),
  backgroundProcesses: Optional(Array2(TBackgroundProcess3)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor3)),
  envMerge: Optional(Array2(TEnvMergeStrategy3)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath30)),
  artifactPaths: Optional(Array2(TArtifactPath3)),
  outputs: Optional(TTaskDefinitionOutputs3),
  problemMatchers: Optional(Array2(TProblemMatcher30)),
  problemPaths: Optional(Array2(TProblemPath30)),
  parallelismType: Optional(Enum(ParallelismType3)),
  parallelismValue: Optional(TParallelismValue3),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString4)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString4),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter3)
});
var TTaskDefinition3 = Composite([
  TTaskDefinitionWithoutParallel3,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel3),
    parallelKey: Optional(TTemplateString4),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString4), TTemplateString4]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString4)), TTemplateString4])),
    parallelismTotal: Optional(TTemplateString4)
  })
]);
var TLayerWithManifest30 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId31,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext3 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret3 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess3 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString4,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString4,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer3 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult30 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus30),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus30),
  startedAt: Optional(TDateString31),
  completedAt: Optional(TDateString31),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem30 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity30),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults30 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest20 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact30 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest20, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact3 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration3 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow3 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow3 || {});
var TConcurrencyPool3 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow3) });
var LeaseState3 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState3 || {});
var TTiming22 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps22 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming22)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming22)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming22),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming22),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming22.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming22),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming22),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming22),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming22),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming22),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming22),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming22),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming22)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming22.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic3 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction19 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact30)
});
var TTask3 = Object2({
  schemaVersion: Literal(ThisSchemaVersion3),
  taskId: TTaskOrGroupId31,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId4),
  generatorTaskId: Optional(TTaskOrGroupId31),
  definition: TTaskDefinition3,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus3),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus3),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus3),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus3),
  resultStatus: Enum(TaskResultStatus3),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason3)),
  resolvedAt: Optional(TDateString31),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString31),
  debugReadyAt: Optional(TDateString31),
  debugStartedAt: Optional(TDateString31),
  debugEndedAt: Optional(TDateString31),
  cancellationRequestedAt: Optional(TDateString31),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString31),
  cancelledAt: Optional(TDateString31),
  concurrencyPool: Optional(TConcurrencyPool3),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext3),
  usedSecrets: Optional(Array2(TUsedSecret3)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString4, cacheKey: Enum(EnvironmentVariableCacheKey28) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString4),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess3)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact3)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest30)),
  previousLayers: Optional(Array2(TLayerWithManifest30)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest30)),
  filesystemLayers: Optional(Array2(TLayerWithManifest30)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString4)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration3) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification3),
  accessedVaultIds: Optional(Array2(String2())),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult30)),
  whiteoutLayer: Optional(TLayerWithManifest30),
  outputLayers: Optional(Array2(TLayerWithManifest30)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey28) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem30)),
  testResults: Optional(Array2(TTestResults30)),
  artifacts: Optional(Array2(TArtifact30)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps22,
  networkTraffic: TNetworkTraffic3,
  outputRetryActions: Array2(TRetryAction19),
  retryAction: Optional(TRetryAction19),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  dockerLayer: Optional(TLayerWithManifest30)
});
var TRetryManifestEntry3 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry3 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString31,
  startedAt: Optional(TDateString31),
  mostRecentlyAttemptedAt: Optional(TDateString31),
  finishedAt: Optional(TDateString31),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots3 = Object2({ resolution: Array2(TGraphNodeId4), runtime: Array2(TGraphNodeId4) });
var TRunGraph3 = Object2({
  roots: TGraphRoots3,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId4, Array2(TGraphNodeId4)),
    runtime: Record(TGraphNodeId4, Array2(TGraphNodeId4))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId4, Array2(TGraphNodeId4)),
    runtime: Record(TGraphNodeId4, Array2(TGraphNodeId4))
  }),
  subgraphs: Record(TGraphNodeId4, Object2({ roots: TGraphRoots3 })),
  parents: Record(TGraphNodeId4, TGraphNodeId4),
  definitionOrders: Record(TGraphNodeId4, Number2())
});
var TActor3 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState3 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState3)
});
var TRun3 = Object2({
  schemaVersion: Literal(ThisSchemaVersion3),
  persistenceExpiresAtSeconds: TEpochSeconds4,
  runId: String2(),
  createdAt: TDateString31,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor3),
  mintDirectoryArtifact: Optional(TArtifact30),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool3),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration3),
  eventNumber: Number2(),
  retries: Array2(TRetry3),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph3,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry3)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey4, TConcurrencyPoolState3),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus3),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus3),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus3),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus3),
  resultStatus: Enum(RunResultStatus3),
  waitingForLeaseAt: Optional(TDateString31),
  startedAt: Optional(TDateString31),
  cancellationRequestedAt: Optional(TDateString31),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString31)
});

// packages/schema/persisted/versioned/v41.ts
var ThisSchemaVersion4 = "v41" /* V41 */;
var TTaskOrGroupId32 = TBrandedString();
var TGraphNodeId5 = TBrandedString();
var TTemplateString5 = TBrandedString();
var TEvaluatedString5 = TBrandedString();
var TDateString32 = TBrandedString();
var TEpochSeconds5 = TBrandedNumber();
var TScopedTaskKey5 = TBrandedString();
var TaskType4 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType4 || {});
var TaskResultStatus4 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus4 || {});
var TaskExecutionStatus4 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus4 || {});
var TaskExecutionWaitingSubStatus4 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus4 || {});
var TaskExecutionAbortedSubStatus4 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus4 || {});
var TaskExecutionFinishedSubStatus4 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus4 || {});
var TaskAttemptReason4 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason4 || {});
var BackgroundProcessResultStatus31 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus31 || {});
var BackgroundProcessResultFinishedSubStatus31 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus31 || {});
var RunResultStatus4 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus4 || {});
var RunExecutionStatus4 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus4 || {});
var RunExecutionWaitingSubStatus4 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus4 || {});
var RunExecutionAbortedSubStatus4 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus4 || {});
var RunExecutionFinishedSubStatus4 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus4 || {});
var TSource4 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey29 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey29 || {});
var TExpandedEnvDescriptor4 = Object2({ value: Optional(TTemplateString5), cacheKey: Enum(EnvironmentVariableCacheKey29) });
var TEnvMergeStrategy4 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath31 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern31 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity31 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity31 || {});
var TProblemMatcher31 = Object2({ owner: String2(), severity: Optional(Enum(Severity31)), pattern: Array2(TProblemMatcherPattern31) });
var TProblemPath31 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath4 = Object2({ key: String2(), path: TTemplateString5 });
var TResolvedArtifactPath2 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck4 = Object2({ run: TTemplateString5, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess4 = Object2({
  key: String2(),
  command: TTemplateString5,
  readyCheck: Optional(TExpandedReadyCheck4),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType4 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType4 || {});
var TParallelismValue4 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification4 = Object2({
  cpus: Optional(TTemplateString5),
  memory: Optional(TTemplateString5),
  disk: Object2({ size: Optional(TTemplateString5) }),
  staticIps: Optional(TTemplateString5),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification4 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs4 = Object2({
  values: Optional(Record(String2(), TTemplateString5)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter4 = Object2({
  workspace: Optional(Union([Array2(TTemplateString5), TTemplateString5])),
  artifacts: Optional(Record(TTemplateString5, Union([Array2(TTemplateString5), TTemplateString5])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter4 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel4 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification4),
  type: Optional(Enum(TaskType4)),
  after: Optional(TTemplateString5),
  if: Optional(TTemplateString5),
  source: Optional(TSource4),
  allowCacheHit: Optional(TTemplateString5),
  docker: Optional(TTemplateString5),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString5),
  filter: Optional(TInputFilesystemFilter4),
  backgroundProcesses: Optional(Array2(TBackgroundProcess4)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor4)),
  envMerge: Optional(Array2(TEnvMergeStrategy4)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath31)),
  artifactPaths: Optional(Array2(TArtifactPath4)),
  outputs: Optional(TTaskDefinitionOutputs4),
  problemMatchers: Optional(Array2(TProblemMatcher31)),
  problemPaths: Optional(Array2(TProblemPath31)),
  parallelismType: Optional(Enum(ParallelismType4)),
  parallelismValue: Optional(TParallelismValue4),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString5)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString5),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter4)
});
var TTaskDefinition4 = Composite([
  TTaskDefinitionWithoutParallel4,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel4),
    parallelKey: Optional(TTemplateString5),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString5), TTemplateString5]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString5)), TTemplateString5])),
    parallelismTotal: Optional(TTemplateString5)
  })
]);
var TLayerWithManifest31 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId32,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext4 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret4 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess4 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString5,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString5,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer4 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult31 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus31),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus31),
  startedAt: Optional(TDateString32),
  completedAt: Optional(TDateString32),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem31 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity31),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults31 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest21 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact31 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest21, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact4 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration4 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow4 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow4 || {});
var TConcurrencyPool4 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow4) });
var LeaseState4 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState4 || {});
var TTiming23 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps23 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming23)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming23)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming23),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming23),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming23.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming23),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming23),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming23),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming23),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming23),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming23),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming23),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming23)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming23.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic4 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction20 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact31)
});
var TTask4 = Object2({
  schemaVersion: Literal(ThisSchemaVersion4),
  taskId: TTaskOrGroupId32,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId5),
  generatorTaskId: Optional(TTaskOrGroupId32),
  definition: TTaskDefinition4,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus4),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus4),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus4),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus4),
  resultStatus: Enum(TaskResultStatus4),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason4)),
  resolvedAt: Optional(TDateString32),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString32),
  debugReadyAt: Optional(TDateString32),
  debugStartedAt: Optional(TDateString32),
  debugEndedAt: Optional(TDateString32),
  cancellationRequestedAt: Optional(TDateString32),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString32),
  cancelledAt: Optional(TDateString32),
  concurrencyPool: Optional(TConcurrencyPool4),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext4),
  usedSecrets: Optional(Array2(TUsedSecret4)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString5, cacheKey: Enum(EnvironmentVariableCacheKey29) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString5),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess4)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact4)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest31)),
  previousLayers: Optional(Array2(TLayerWithManifest31)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest31)),
  filesystemLayers: Optional(Array2(TLayerWithManifest31)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString5)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration4) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification4),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath2)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult31)),
  whiteoutLayer: Optional(TLayerWithManifest31),
  outputLayers: Optional(Array2(TLayerWithManifest31)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey29) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem31)),
  testResults: Optional(Array2(TTestResults31)),
  artifacts: Optional(Array2(TArtifact31)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps23,
  networkTraffic: TNetworkTraffic4,
  outputRetryActions: Array2(TRetryAction20),
  retryAction: Optional(TRetryAction20),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest31)
});
var TRetryManifestEntry4 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry4 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString32,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString32),
  mostRecentlyAttemptedAt: Optional(TDateString32),
  finishedAt: Optional(TDateString32),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots4 = Object2({ resolution: Array2(TGraphNodeId5), runtime: Array2(TGraphNodeId5) });
var TRunGraph4 = Object2({
  roots: TGraphRoots4,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId5, Array2(TGraphNodeId5)),
    runtime: Record(TGraphNodeId5, Array2(TGraphNodeId5))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId5, Array2(TGraphNodeId5)),
    runtime: Record(TGraphNodeId5, Array2(TGraphNodeId5))
  }),
  subgraphs: Record(TGraphNodeId5, Object2({ roots: TGraphRoots4 })),
  parents: Record(TGraphNodeId5, TGraphNodeId5),
  definitionOrders: Record(TGraphNodeId5, Number2())
});
var TActor4 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState4 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState4)
});
var TRun4 = Object2({
  schemaVersion: Literal(ThisSchemaVersion4),
  persistenceExpiresAtSeconds: TEpochSeconds5,
  runId: String2(),
  createdAt: TDateString32,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor4),
  mintDirectoryArtifact: Optional(TArtifact31),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool4),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration4),
  eventNumber: Number2(),
  retries: Array2(TRetry4),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph4,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry4)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey5, TConcurrencyPoolState4),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus4),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus4),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus4),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus4),
  resultStatus: Enum(RunResultStatus4),
  waitingForLeaseAt: Optional(TDateString32),
  startedAt: Optional(TDateString32),
  cancellationRequestedAt: Optional(TDateString32),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString32)
});

// packages/schema/persisted/versioned/v42.ts
var ThisSchemaVersion5 = "v42" /* V42 */;
var TTaskOrGroupId33 = TBrandedString();
var TGraphNodeId6 = TBrandedString();
var TTemplateString6 = TBrandedString();
var TEvaluatedString6 = TBrandedString();
var TDateString33 = TBrandedString();
var TEpochSeconds6 = TBrandedNumber();
var TScopedTaskKey6 = TBrandedString();
var TaskType5 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType5 || {});
var TaskResultStatus5 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus5 || {});
var TaskExecutionStatus5 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus5 || {});
var TaskExecutionWaitingSubStatus5 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus5 || {});
var TaskExecutionAbortedSubStatus5 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus5 || {});
var TaskExecutionFinishedSubStatus5 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus5 || {});
var TaskAttemptReason5 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason5 || {});
var BackgroundProcessResultStatus32 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus32 || {});
var BackgroundProcessResultFinishedSubStatus32 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus32 || {});
var RunResultStatus5 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus5 || {});
var RunExecutionStatus5 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus5 || {});
var RunExecutionWaitingSubStatus5 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus5 || {});
var RunExecutionAbortedSubStatus5 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus5 || {});
var RunExecutionFinishedSubStatus5 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus5 || {});
var TSource5 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey30 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey30 || {});
var TExpandedEnvDescriptor5 = Object2({ value: Optional(TTemplateString6), cacheKey: Enum(EnvironmentVariableCacheKey30) });
var TEnvMergeStrategy5 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath32 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern32 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity32 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity32 || {});
var TProblemMatcher32 = Object2({ owner: String2(), severity: Optional(Enum(Severity32)), pattern: Array2(TProblemMatcherPattern32) });
var TProblemPath32 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath5 = Object2({ key: String2(), path: TTemplateString6 });
var TResolvedArtifactPath3 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck5 = Object2({ run: TTemplateString6, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess5 = Object2({
  key: String2(),
  command: TTemplateString6,
  readyCheck: Optional(TExpandedReadyCheck5),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType5 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType5 || {});
var TParallelismValue5 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification5 = Object2({
  cpus: Optional(TTemplateString6),
  memory: Optional(TTemplateString6),
  disk: Object2({ size: Optional(TTemplateString6) }),
  staticIps: Optional(TTemplateString6),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification5 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs5 = Object2({
  values: Optional(Record(String2(), TTemplateString6)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter5 = Object2({
  workspace: Optional(Union([Array2(TTemplateString6), TTemplateString6])),
  artifacts: Optional(Record(TTemplateString6, Union([Array2(TTemplateString6), TTemplateString6])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter5 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel5 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification5),
  type: Optional(Enum(TaskType5)),
  after: Optional(TTemplateString6),
  if: Optional(TTemplateString6),
  source: Optional(TSource5),
  allowCacheHit: Optional(TTemplateString6),
  docker: Optional(TTemplateString6),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString6),
  filter: Optional(TInputFilesystemFilter5),
  backgroundProcesses: Optional(Array2(TBackgroundProcess5)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor5)),
  envMerge: Optional(Array2(TEnvMergeStrategy5)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath32)),
  artifactPaths: Optional(Array2(TArtifactPath5)),
  outputs: Optional(TTaskDefinitionOutputs5),
  problemMatchers: Optional(Array2(TProblemMatcher32)),
  problemPaths: Optional(Array2(TProblemPath32)),
  parallelismType: Optional(Enum(ParallelismType5)),
  parallelismValue: Optional(TParallelismValue5),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString6)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString6),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter5)
});
var TTaskDefinition5 = Composite([
  TTaskDefinitionWithoutParallel5,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel5),
    parallelKey: Optional(TTemplateString6),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString6), TTemplateString6]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString6)), TTemplateString6])),
    parallelismTotal: Optional(TTemplateString6)
  })
]);
var TLayerWithManifest32 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId33,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext5 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret5 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess5 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString6,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString6,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer5 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult32 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus32),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus32),
  startedAt: Optional(TDateString33),
  completedAt: Optional(TDateString33),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem32 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity32),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults32 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest22 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact32 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest22, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact5 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration5 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow5 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow5 || {});
var TConcurrencyPool5 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow5) });
var LeaseState5 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState5 || {});
var TTiming24 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps24 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming24)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming24)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming24),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming24),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming24.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming24),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming24),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming24),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming24),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming24),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming24),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming24),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming24)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming24.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic5 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction21 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact32)
});
var TTask5 = Object2({
  schemaVersion: Literal(ThisSchemaVersion5),
  taskId: TTaskOrGroupId33,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId6),
  generatorTaskId: Optional(TTaskOrGroupId33),
  definition: TTaskDefinition5,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus5),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus5),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus5),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus5),
  resultStatus: Enum(TaskResultStatus5),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason5)),
  resolvedAt: Optional(TDateString33),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString33),
  debugReadyAt: Optional(TDateString33),
  debugStartedAt: Optional(TDateString33),
  debugEndedAt: Optional(TDateString33),
  cancellationRequestedAt: Optional(TDateString33),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString33),
  cancelledAt: Optional(TDateString33),
  concurrencyPool: Optional(TConcurrencyPool5),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext5),
  usedSecrets: Optional(Array2(TUsedSecret5)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString6, cacheKey: Enum(EnvironmentVariableCacheKey30) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString6),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess5)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact5)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest32)),
  previousLayers: Optional(Array2(TLayerWithManifest32)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest32)),
  filesystemLayers: Optional(Array2(TLayerWithManifest32)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString6)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration5) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification5),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath3)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult32)),
  whiteoutLayer: Optional(TLayerWithManifest32),
  outputLayers: Optional(Array2(TLayerWithManifest32)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey30) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem32)),
  testResults: Optional(Array2(TTestResults32)),
  artifacts: Optional(Array2(TArtifact32)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps24,
  networkTraffic: TNetworkTraffic5,
  outputRetryActions: Array2(TRetryAction21),
  retryAction: Optional(TRetryAction21),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest32)
});
var TRetryManifestEntry5 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry5 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString33,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString33),
  mostRecentlyAttemptedAt: Optional(TDateString33),
  finishedAt: Optional(TDateString33),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots5 = Object2({ resolution: Array2(TGraphNodeId6), runtime: Array2(TGraphNodeId6) });
var TRunGraph5 = Object2({
  roots: TGraphRoots5,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId6, Array2(TGraphNodeId6)),
    runtime: Record(TGraphNodeId6, Array2(TGraphNodeId6))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId6, Array2(TGraphNodeId6)),
    runtime: Record(TGraphNodeId6, Array2(TGraphNodeId6))
  }),
  subgraphs: Record(TGraphNodeId6, Object2({ roots: TGraphRoots5 })),
  parents: Record(TGraphNodeId6, TGraphNodeId6),
  definitionOrders: Record(TGraphNodeId6, Number2())
});
var TActor5 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState5 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState5)
});
var ApprovalRequestState2 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState2 || {});
var TApprovalRequest2 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState2)
});
var TRun5 = Object2({
  schemaVersion: Literal(ThisSchemaVersion5),
  persistenceExpiresAtSeconds: TEpochSeconds6,
  runId: String2(),
  createdAt: TDateString33,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor5),
  mintDirectoryArtifact: Optional(TArtifact32),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool5),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration5),
  eventNumber: Number2(),
  retries: Array2(TRetry5),
  approvalRequests: Array2(TApprovalRequest2),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph5,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry5)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey6, TConcurrencyPoolState5),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer5,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus5),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus5),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus5),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus5),
  resultStatus: Enum(RunResultStatus5),
  waitingForLeaseAt: Optional(TDateString33),
  startedAt: Optional(TDateString33),
  cancellationRequestedAt: Optional(TDateString33),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString33)
});

// packages/schema/persisted/versioned/v43.ts
var ThisSchemaVersion6 = "v43" /* V43 */;
var TTaskOrGroupId34 = TBrandedString();
var TGraphNodeId7 = TBrandedString();
var TTemplateString7 = TBrandedString();
var TEvaluatedString7 = TBrandedString();
var TDateString34 = TBrandedString();
var TEpochSeconds7 = TBrandedNumber();
var TScopedTaskKey7 = TBrandedString();
var TaskType6 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType6 || {});
var TaskResultStatus6 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus6 || {});
var TaskExecutionStatus6 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus6 || {});
var TaskExecutionWaitingSubStatus6 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus6 || {});
var TaskExecutionAbortedSubStatus6 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus6 || {});
var TaskExecutionFinishedSubStatus6 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus6 || {});
var TaskAttemptReason6 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason6 || {});
var BackgroundProcessResultStatus33 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus33 || {});
var BackgroundProcessResultFinishedSubStatus33 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus33 || {});
var RunResultStatus6 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus6 || {});
var RunExecutionStatus6 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus6 || {});
var RunExecutionWaitingSubStatus6 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus6 || {});
var RunExecutionAbortedSubStatus6 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus6 || {});
var RunExecutionFinishedSubStatus6 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus6 || {});
var TSource6 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey31 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey31 || {});
var TExpandedEnvDescriptor6 = Object2({ value: Optional(TTemplateString7), cacheKey: Enum(EnvironmentVariableCacheKey31) });
var TEnvMergeStrategy6 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath33 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern33 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity33 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity33 || {});
var TProblemMatcher33 = Object2({ owner: String2(), severity: Optional(Enum(Severity33)), pattern: Array2(TProblemMatcherPattern33) });
var TProblemPath33 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath6 = Object2({ key: String2(), path: TTemplateString7 });
var TResolvedArtifactPath4 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck6 = Object2({ run: TTemplateString7, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess6 = Object2({
  key: String2(),
  command: TTemplateString7,
  readyCheck: Optional(TExpandedReadyCheck6),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType6 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType6 || {});
var TParallelismValue6 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification6 = Object2({
  cpus: Optional(TTemplateString7),
  memory: Optional(TTemplateString7),
  disk: Object2({ size: Optional(TTemplateString7) }),
  staticIps: Optional(TTemplateString7),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification6 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs6 = Object2({
  values: Optional(Record(String2(), TTemplateString7)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter6 = Object2({
  workspace: Optional(Union([Array2(TTemplateString7), TTemplateString7])),
  artifacts: Optional(Record(TTemplateString7, Union([Array2(TTemplateString7), TTemplateString7])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter6 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel6 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification6),
  type: Optional(Enum(TaskType6)),
  after: Optional(TTemplateString7),
  if: Optional(TTemplateString7),
  source: Optional(TSource6),
  allowCacheHit: Optional(TTemplateString7),
  docker: Optional(TTemplateString7),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString7),
  filter: Optional(TInputFilesystemFilter6),
  backgroundProcesses: Optional(Array2(TBackgroundProcess6)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor6)),
  envMerge: Optional(Array2(TEnvMergeStrategy6)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath33)),
  artifactPaths: Optional(Array2(TArtifactPath6)),
  outputs: Optional(TTaskDefinitionOutputs6),
  problemMatchers: Optional(Array2(TProblemMatcher33)),
  problemPaths: Optional(Array2(TProblemPath33)),
  parallelismType: Optional(Enum(ParallelismType6)),
  parallelismValue: Optional(TParallelismValue6),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString7)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString7),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter6)
});
var TTaskDefinition6 = Composite([
  TTaskDefinitionWithoutParallel6,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel6),
    parallelKey: Optional(TTemplateString7),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString7), TTemplateString7]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString7)), TTemplateString7])),
    parallelismTotal: Optional(TTemplateString7)
  })
]);
var TLayerWithManifest33 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId34,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext6 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret6 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess6 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString7,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString7,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer6 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult33 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus33),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus33),
  startedAt: Optional(TDateString34),
  completedAt: Optional(TDateString34),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem33 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity33),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults33 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest23 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact33 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest23, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact6 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration6 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow6 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow6 || {});
var TConcurrencyPool6 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow6) });
var LeaseState6 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState6 || {});
var TTiming25 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps25 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming25)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming25)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming25),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming25),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming25.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming25),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming25),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming25),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming25),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming25),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming25),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming25),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming25)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming25.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic6 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction22 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact33)
});
var TTask6 = Object2({
  schemaVersion: Literal(ThisSchemaVersion6),
  taskId: TTaskOrGroupId34,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId7),
  generatorTaskId: Optional(TTaskOrGroupId34),
  definition: TTaskDefinition6,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus6),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus6),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus6),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus6),
  resultStatus: Enum(TaskResultStatus6),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason6)),
  resolvedAt: Optional(TDateString34),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString34),
  debugReadyAt: Optional(TDateString34),
  debugStartedAt: Optional(TDateString34),
  debugEndedAt: Optional(TDateString34),
  cancellationRequestedAt: Optional(TDateString34),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString34),
  cancelledAt: Optional(TDateString34),
  concurrencyPool: Optional(TConcurrencyPool6),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext6),
  usedSecrets: Optional(Array2(TUsedSecret6)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString7, cacheKey: Enum(EnvironmentVariableCacheKey31) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString7),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess6)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact6)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest33)),
  previousLayers: Optional(Array2(TLayerWithManifest33)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest33)),
  filesystemLayers: Optional(Array2(TLayerWithManifest33)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString7)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration6) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification6),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath4)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult33)),
  whiteoutLayer: Optional(TLayerWithManifest33),
  outputLayers: Optional(Array2(TLayerWithManifest33)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey31) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem33)),
  testResults: Optional(Array2(TTestResults33)),
  artifacts: Optional(Array2(TArtifact33)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps25,
  networkTraffic: TNetworkTraffic6,
  outputRetryActions: Array2(TRetryAction22),
  retryAction: Optional(TRetryAction22),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest33)
});
var TRetryManifestEntry6 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry6 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString34,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString34),
  mostRecentlyAttemptedAt: Optional(TDateString34),
  finishedAt: Optional(TDateString34),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots6 = Object2({ resolution: Array2(TGraphNodeId7), runtime: Array2(TGraphNodeId7) });
var TRunGraph6 = Object2({
  roots: TGraphRoots6,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId7, Array2(TGraphNodeId7)),
    runtime: Record(TGraphNodeId7, Array2(TGraphNodeId7))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId7, Array2(TGraphNodeId7)),
    runtime: Record(TGraphNodeId7, Array2(TGraphNodeId7))
  }),
  subgraphs: Record(TGraphNodeId7, Object2({ roots: TGraphRoots6 })),
  parents: Record(TGraphNodeId7, TGraphNodeId7),
  definitionOrders: Record(TGraphNodeId7, Number2())
});
var TActor6 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState6 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState6)
});
var ApprovalRequestState3 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState3 || {});
var TApprovalRequest3 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState3)
});
var TRun6 = Object2({
  schemaVersion: Literal(ThisSchemaVersion6),
  persistenceExpiresAtSeconds: TEpochSeconds7,
  runId: String2(),
  createdAt: TDateString34,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor6),
  mintDirectoryArtifact: Optional(TArtifact33),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool6),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration6),
  eventNumber: Number2(),
  retries: Array2(TRetry6),
  approvalRequests: Array2(TApprovalRequest3),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph6,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry6)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey7, TConcurrencyPoolState6),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer6,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus6),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus6),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus6),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus6),
  resultStatus: Enum(RunResultStatus6),
  waitingForLeaseAt: Optional(TDateString34),
  startedAt: Optional(TDateString34),
  cancellationRequestedAt: Optional(TDateString34),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString34)
});

// packages/schema/persisted/versioned/v44.ts
var ThisSchemaVersion7 = "v44" /* V44 */;
var TTaskOrGroupId35 = TBrandedString();
var TGraphNodeId8 = TBrandedString();
var TTemplateString8 = TBrandedString();
var TEvaluatedString8 = TBrandedString();
var TDateString35 = TBrandedString();
var TEpochSeconds8 = TBrandedNumber();
var TScopedTaskKey8 = TBrandedString();
var TaskType7 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType7 || {});
var TaskResultStatus7 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus7 || {});
var TaskExecutionStatus7 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus7 || {});
var TaskExecutionWaitingSubStatus7 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus7 || {});
var TaskExecutionAbortedSubStatus7 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus7 || {});
var TaskExecutionFinishedSubStatus7 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus7 || {});
var TaskAttemptReason7 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason7 || {});
var BackgroundProcessResultStatus34 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus34 || {});
var BackgroundProcessResultFinishedSubStatus34 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus34 || {});
var RunResultStatus7 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus7 || {});
var RunExecutionStatus7 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus7 || {});
var RunExecutionWaitingSubStatus7 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus7 || {});
var RunExecutionAbortedSubStatus7 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus7 || {});
var RunExecutionFinishedSubStatus7 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus7 || {});
var TSource7 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey32 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey32 || {});
var TExpandedEnvDescriptor7 = Object2({ value: Optional(TTemplateString8), cacheKey: Enum(EnvironmentVariableCacheKey32) });
var TEnvMergeStrategy7 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath34 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern34 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity34 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity34 || {});
var TProblemMatcher34 = Object2({ owner: String2(), severity: Optional(Enum(Severity34)), pattern: Array2(TProblemMatcherPattern34) });
var TProblemPath34 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath7 = Object2({ key: String2(), path: TTemplateString8 });
var TResolvedArtifactPath5 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck7 = Object2({ run: TTemplateString8, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess7 = Object2({
  key: String2(),
  command: TTemplateString8,
  readyCheck: Optional(TExpandedReadyCheck7),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType7 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType7 || {});
var TParallelismValue7 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification7 = Object2({
  cpus: Optional(TTemplateString8),
  memory: Optional(TTemplateString8),
  disk: Object2({ size: Optional(TTemplateString8) }),
  staticIps: Optional(TTemplateString8),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification7 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs7 = Object2({
  values: Optional(Record(String2(), TTemplateString8)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter7 = Object2({
  workspace: Optional(Union([Array2(TTemplateString8), TTemplateString8])),
  artifacts: Optional(Record(TTemplateString8, Union([Array2(TTemplateString8), TTemplateString8])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter7 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel7 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification7),
  type: Optional(Enum(TaskType7)),
  after: Optional(TTemplateString8),
  if: Optional(TTemplateString8),
  source: Optional(TSource7),
  allowCacheHit: Optional(TTemplateString8),
  docker: Optional(TTemplateString8),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString8),
  filter: Optional(TInputFilesystemFilter7),
  backgroundProcesses: Optional(Array2(TBackgroundProcess7)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor7)),
  envMerge: Optional(Array2(TEnvMergeStrategy7)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath34)),
  artifactPaths: Optional(Array2(TArtifactPath7)),
  outputs: Optional(TTaskDefinitionOutputs7),
  problemMatchers: Optional(Array2(TProblemMatcher34)),
  problemPaths: Optional(Array2(TProblemPath34)),
  parallelismType: Optional(Enum(ParallelismType7)),
  parallelismValue: Optional(TParallelismValue7),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString8)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString8),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter7)
});
var TTaskDefinition7 = Composite([
  TTaskDefinitionWithoutParallel7,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel7),
    parallelKey: Optional(TTemplateString8),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString8), TTemplateString8]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString8)), TTemplateString8])),
    parallelismTotal: Optional(TTemplateString8)
  })
]);
var TLayerWithManifest34 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId35,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext7 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret7 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess7 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString8,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString8,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer7 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult34 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus34),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus34),
  startedAt: Optional(TDateString35),
  completedAt: Optional(TDateString35),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem34 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity34),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults34 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest24 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact34 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest24, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact7 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration7 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow7 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow7 || {});
var TConcurrencyPool7 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow7) });
var LeaseState7 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState7 || {});
var TTiming26 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps26 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming26)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming26)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming26),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming26),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming26.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming26),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming26),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming26),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming26),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming26),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming26),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming26),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming26)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming26.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic7 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction23 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact34)
});
var TTask7 = Object2({
  schemaVersion: Literal(ThisSchemaVersion7),
  taskId: TTaskOrGroupId35,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId8),
  generatorTaskId: Optional(TTaskOrGroupId35),
  definition: TTaskDefinition7,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus7),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus7),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus7),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus7),
  resultStatus: Enum(TaskResultStatus7),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason7)),
  resolvedAt: Optional(TDateString35),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString35),
  debugReadyAt: Optional(TDateString35),
  debugStartedAt: Optional(TDateString35),
  debugEndedAt: Optional(TDateString35),
  cancellationRequestedAt: Optional(TDateString35),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString35),
  cancelledAt: Optional(TDateString35),
  concurrencyPool: Optional(TConcurrencyPool7),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext7),
  usedSecrets: Optional(Array2(TUsedSecret7)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString8, cacheKey: Enum(EnvironmentVariableCacheKey32) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString8),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess7)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact7)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest34)),
  previousLayers: Optional(Array2(TLayerWithManifest34)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest34)),
  filesystemLayers: Optional(Array2(TLayerWithManifest34)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString8)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration7) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification7),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath5)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult34)),
  whiteoutLayer: Optional(TLayerWithManifest34),
  outputLayers: Optional(Array2(TLayerWithManifest34)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey32) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem34)),
  testResults: Optional(Array2(TTestResults34)),
  artifacts: Optional(Array2(TArtifact34)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps26,
  networkTraffic: TNetworkTraffic7,
  outputRetryActions: Array2(TRetryAction23),
  retryAction: Optional(TRetryAction23),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest34)
});
var TRetryManifestEntry7 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry7 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString35,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString35),
  mostRecentlyAttemptedAt: Optional(TDateString35),
  finishedAt: Optional(TDateString35),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots7 = Object2({ resolution: Array2(TGraphNodeId8), runtime: Array2(TGraphNodeId8) });
var TRunGraph7 = Object2({
  roots: TGraphRoots7,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId8, Array2(TGraphNodeId8)),
    runtime: Record(TGraphNodeId8, Array2(TGraphNodeId8))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId8, Array2(TGraphNodeId8)),
    runtime: Record(TGraphNodeId8, Array2(TGraphNodeId8))
  }),
  subgraphs: Record(TGraphNodeId8, Object2({ roots: TGraphRoots7 })),
  parents: Record(TGraphNodeId8, TGraphNodeId8),
  definitionOrders: Record(TGraphNodeId8, Number2())
});
var TActor7 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState7 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState7)
});
var ApprovalRequestState4 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState4 || {});
var TApprovalRequest4 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState4)
});
var TRun7 = Object2({
  schemaVersion: Literal(ThisSchemaVersion7),
  persistenceExpiresAtSeconds: TEpochSeconds8,
  runId: String2(),
  createdAt: TDateString35,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor7),
  mintDirectoryArtifact: Optional(TArtifact34),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool7),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration7),
  eventNumber: Number2(),
  retries: Array2(TRetry7),
  approvalRequests: Array2(TApprovalRequest4),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph7,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry7)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey8, TConcurrencyPoolState7),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer7,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus7),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus7),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus7),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus7),
  resultStatus: Enum(RunResultStatus7),
  waitingForLeaseAt: Optional(TDateString35),
  startedAt: Optional(TDateString35),
  cancellationRequestedAt: Optional(TDateString35),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString35)
});

// packages/schema/persisted/versioned/v45.ts
var ThisSchemaVersion8 = "v45" /* V45 */;
var TTaskOrGroupId36 = TBrandedString();
var TGraphNodeId9 = TBrandedString();
var TTemplateString9 = TBrandedString();
var TEvaluatedString9 = TBrandedString();
var TDateString36 = TBrandedString();
var TEpochSeconds9 = TBrandedNumber();
var TScopedTaskKey9 = TBrandedString();
var TaskType8 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType8 || {});
var TaskResultStatus8 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus8 || {});
var TaskExecutionStatus8 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus8 || {});
var TaskExecutionWaitingSubStatus8 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus8 || {});
var TaskExecutionAbortedSubStatus8 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus8 || {});
var TaskExecutionFinishedSubStatus8 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus8 || {});
var TaskAttemptReason8 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason8 || {});
var BackgroundProcessResultStatus35 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus35 || {});
var BackgroundProcessResultFinishedSubStatus35 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus35 || {});
var RunResultStatus8 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus8 || {});
var RunExecutionStatus8 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus8 || {});
var RunExecutionWaitingSubStatus8 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus8 || {});
var RunExecutionAbortedSubStatus8 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus8 || {});
var RunExecutionFinishedSubStatus8 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus8 || {});
var TSource8 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey33 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey33 || {});
var TExpandedEnvDescriptor8 = Object2({ value: Optional(TTemplateString9), cacheKey: Enum(EnvironmentVariableCacheKey33) });
var TEnvMergeStrategy8 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath35 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern35 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity35 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity35 || {});
var TProblemMatcher35 = Object2({ owner: String2(), severity: Optional(Enum(Severity35)), pattern: Array2(TProblemMatcherPattern35) });
var TProblemPath35 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath8 = Object2({ key: String2(), path: TTemplateString9 });
var TResolvedArtifactPath6 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck8 = Object2({ run: TTemplateString9, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess8 = Object2({
  key: String2(),
  command: TTemplateString9,
  readyCheck: Optional(TExpandedReadyCheck8),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType8 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType8 || {});
var TParallelismValue8 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification8 = Object2({
  cpus: Optional(TTemplateString9),
  memory: Optional(TTemplateString9),
  disk: Object2({ size: Optional(TTemplateString9) }),
  staticIps: Optional(TTemplateString9),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification8 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs8 = Object2({
  values: Optional(Record(String2(), TTemplateString9)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter8 = Object2({
  workspace: Optional(Union([Array2(TTemplateString9), TTemplateString9])),
  artifacts: Optional(Record(TTemplateString9, Union([Array2(TTemplateString9), TTemplateString9])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter8 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel8 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification8),
  type: Optional(Enum(TaskType8)),
  after: Optional(TTemplateString9),
  if: Optional(TTemplateString9),
  source: Optional(TSource8),
  allowCacheHit: Optional(TTemplateString9),
  docker: Optional(TTemplateString9),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString9),
  filter: Optional(TInputFilesystemFilter8),
  backgroundProcesses: Optional(Array2(TBackgroundProcess8)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor8)),
  envMerge: Optional(Array2(TEnvMergeStrategy8)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath35)),
  artifactPaths: Optional(Array2(TArtifactPath8)),
  outputs: Optional(TTaskDefinitionOutputs8),
  problemMatchers: Optional(Array2(TProblemMatcher35)),
  problemPaths: Optional(Array2(TProblemPath35)),
  parallelismType: Optional(Enum(ParallelismType8)),
  parallelismValue: Optional(TParallelismValue8),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString9)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString9),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter8)
});
var TTaskDefinition8 = Composite([
  TTaskDefinitionWithoutParallel8,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel8),
    parallelKey: Optional(TTemplateString9),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString9), TTemplateString9]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString9)), TTemplateString9])),
    parallelismTotal: Optional(TTemplateString9)
  })
]);
var TLayerWithManifest35 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId36,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext8 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret8 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess8 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString9,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString9,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult35 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus35),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus35),
  startedAt: Optional(TDateString36),
  completedAt: Optional(TDateString36),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem35 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity35),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults35 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest25 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact35 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest25, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact8 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration8 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow8 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow8 || {});
var TConcurrencyPool8 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow8) });
var LeaseState8 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState8 || {});
var TTiming27 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps27 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming27)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming27)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming27),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming27),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming27.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming27),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming27),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming27),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming27),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming27),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming27),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming27),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming27)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming27.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic8 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction24 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact35)
});
var TBaseLayerSpecificationTriple = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId = Object2({
  layerId: String2()
});
var TBaseLayerSpecification = Union([TBaseLayerSpecificationTriple, TBaseLayerSpecificationLayerId]);
var TBaseLayerDescriptor = Composite([
  TBaseLayerSpecificationTriple,
  TBaseLayerSpecificationLayerId,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTask8 = Object2({
  schemaVersion: Literal(ThisSchemaVersion8),
  taskId: TTaskOrGroupId36,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId9),
  generatorTaskId: Optional(TTaskOrGroupId36),
  definition: TTaskDefinition8,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus8),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus8),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus8),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus8),
  resultStatus: Enum(TaskResultStatus8),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason8)),
  resolvedAt: Optional(TDateString36),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString36),
  debugReadyAt: Optional(TDateString36),
  debugStartedAt: Optional(TDateString36),
  debugEndedAt: Optional(TDateString36),
  cancellationRequestedAt: Optional(TDateString36),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString36),
  cancelledAt: Optional(TDateString36),
  concurrencyPool: Optional(TConcurrencyPool8),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext8),
  usedSecrets: Optional(Array2(TUsedSecret8)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString9, cacheKey: Enum(EnvironmentVariableCacheKey33) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString9),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess8)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact8)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest35)),
  previousLayers: Optional(Array2(TLayerWithManifest35)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest35)),
  filesystemLayers: Optional(Array2(TLayerWithManifest35)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString9)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration8),
      baseLayer: TBaseLayerDescriptor
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification8),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath6)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult35)),
  whiteoutLayer: Optional(TLayerWithManifest35),
  outputLayers: Optional(Array2(TLayerWithManifest35)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey33) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem35)),
  testResults: Optional(Array2(TTestResults35)),
  artifacts: Optional(Array2(TArtifact35)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps27,
  networkTraffic: TNetworkTraffic8,
  outputRetryActions: Array2(TRetryAction24),
  retryAction: Optional(TRetryAction24),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest35)
});
var TRetryManifestEntry8 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry8 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString36,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString36),
  mostRecentlyAttemptedAt: Optional(TDateString36),
  finishedAt: Optional(TDateString36),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots8 = Object2({ resolution: Array2(TGraphNodeId9), runtime: Array2(TGraphNodeId9) });
var TRunGraph8 = Object2({
  roots: TGraphRoots8,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId9, Array2(TGraphNodeId9)),
    runtime: Record(TGraphNodeId9, Array2(TGraphNodeId9))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId9, Array2(TGraphNodeId9)),
    runtime: Record(TGraphNodeId9, Array2(TGraphNodeId9))
  }),
  subgraphs: Record(TGraphNodeId9, Object2({ roots: TGraphRoots8 })),
  parents: Record(TGraphNodeId9, TGraphNodeId9),
  definitionOrders: Record(TGraphNodeId9, Number2())
});
var TActor8 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState8 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState8)
});
var ApprovalRequestState5 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState5 || {});
var TApprovalRequest5 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState5)
});
var TRun8 = Object2({
  schemaVersion: Literal(ThisSchemaVersion8),
  persistenceExpiresAtSeconds: TEpochSeconds9,
  runId: String2(),
  createdAt: TDateString36,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor8),
  mintDirectoryArtifact: Optional(TArtifact35),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool8),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration8),
  eventNumber: Number2(),
  retries: Array2(TRetry8),
  approvalRequests: Array2(TApprovalRequest5),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph8,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry8)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey9, TConcurrencyPoolState8),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayerDescriptor,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus8),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus8),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus8),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus8),
  resultStatus: Enum(RunResultStatus8),
  waitingForLeaseAt: Optional(TDateString36),
  startedAt: Optional(TDateString36),
  cancellationRequestedAt: Optional(TDateString36),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString36)
});

// packages/schema/persisted/versioned/v46.ts
var ThisSchemaVersion9 = "v46" /* V46 */;
var TTaskOrGroupId37 = TBrandedString();
var TGraphNodeId10 = TBrandedString();
var TTemplateString10 = TBrandedString();
var TEvaluatedString10 = TBrandedString();
var TDateString37 = TBrandedString();
var TEpochSeconds10 = TBrandedNumber();
var TScopedTaskKey10 = TBrandedString();
var TaskType9 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType9 || {});
var TaskResultStatus9 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus9 || {});
var TaskExecutionStatus9 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus9 || {});
var TaskExecutionWaitingSubStatus9 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus9 || {});
var TaskExecutionAbortedSubStatus9 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus9 || {});
var TaskExecutionFinishedSubStatus9 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus9 || {});
var TaskAttemptReason9 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason9 || {});
var BackgroundProcessResultStatus36 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus36 || {});
var BackgroundProcessResultFinishedSubStatus36 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus36 || {});
var RunResultStatus9 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus9 || {});
var RunExecutionStatus9 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus9 || {});
var RunExecutionWaitingSubStatus9 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus9 || {});
var RunExecutionAbortedSubStatus9 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus9 || {});
var RunExecutionFinishedSubStatus9 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus9 || {});
var TSource9 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey34 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey34 || {});
var TExpandedEnvDescriptor9 = Object2({ value: Optional(TTemplateString10), cacheKey: Enum(EnvironmentVariableCacheKey34) });
var TEnvMergeStrategy9 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath36 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern36 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity36 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity36 || {});
var TProblemMatcher36 = Object2({ owner: String2(), severity: Optional(Enum(Severity36)), pattern: Array2(TProblemMatcherPattern36) });
var TProblemPath36 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath9 = Object2({ key: String2(), path: TTemplateString10 });
var TResolvedArtifactPath7 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck9 = Object2({ run: TTemplateString10, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess9 = Object2({
  key: String2(),
  command: TTemplateString10,
  readyCheck: Optional(TExpandedReadyCheck9),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType9 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType9 || {});
var TParallelismValue9 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification9 = Object2({
  cpus: Optional(TTemplateString10),
  memory: Optional(TTemplateString10),
  disk: Object2({ size: Optional(TTemplateString10) }),
  staticIps: Optional(TTemplateString10),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification9 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs9 = Object2({
  values: Optional(Record(String2(), TTemplateString10)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter9 = Object2({
  workspace: Optional(Union([Array2(TTemplateString10), TTemplateString10])),
  artifacts: Optional(Record(TTemplateString10, Union([Array2(TTemplateString10), TTemplateString10])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter9 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration2 = Object2({
  enabled: TTemplateString10,
  ttl: Optional(TTemplateString10)
});
var TTaskDefinitionWithoutParallel9 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification9),
  type: Optional(Enum(TaskType9)),
  after: Optional(TTemplateString10),
  if: Optional(TTemplateString10),
  source: Optional(TSource9),
  cacheConfiguration: TCacheConfiguration2,
  docker: Optional(TTemplateString10),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString10),
  filter: Optional(TInputFilesystemFilter9),
  backgroundProcesses: Optional(Array2(TBackgroundProcess9)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor9)),
  envMerge: Optional(Array2(TEnvMergeStrategy9)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath36)),
  artifactPaths: Optional(Array2(TArtifactPath9)),
  outputs: Optional(TTaskDefinitionOutputs9),
  problemMatchers: Optional(Array2(TProblemMatcher36)),
  problemPaths: Optional(Array2(TProblemPath36)),
  parallelismType: Optional(Enum(ParallelismType9)),
  parallelismValue: Optional(TParallelismValue9),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString10)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString10),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter9)
});
var TTaskDefinition9 = Composite([
  TTaskDefinitionWithoutParallel9,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel9),
    parallelKey: Optional(TTemplateString10),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString10), TTemplateString10]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString10)), TTemplateString10])),
    parallelismTotal: Optional(TTemplateString10)
  })
]);
var TLayerWithManifest36 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId37,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext9 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret9 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess9 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString10,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString10,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult36 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus36),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus36),
  startedAt: Optional(TDateString37),
  completedAt: Optional(TDateString37),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem36 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity36),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults36 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest26 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact36 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest26, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact9 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration9 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow9 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow9 || {});
var TConcurrencyPool9 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow9) });
var LeaseState9 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState9 || {});
var TTiming28 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps28 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming28)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming28)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming28),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming28),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming28.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming28),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming28),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming28),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming28),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming28),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming28),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming28),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming28)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming28.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic9 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction25 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact36)
});
var TBaseLayerSpecificationTriple2 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId2 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification2 = Union([TBaseLayerSpecificationTriple2, TBaseLayerSpecificationLayerId2]);
var TBaseLayerDescriptor2 = Composite([
  TBaseLayerSpecificationTriple2,
  TBaseLayerSpecificationLayerId2,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit2 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit2 || {});
var TTTL2 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit2)
});
var TResolvedCacheConfiguration = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL2)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask9 = Object2({
  schemaVersion: Literal(ThisSchemaVersion9),
  taskId: TTaskOrGroupId37,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId10),
  generatorTaskId: Optional(TTaskOrGroupId37),
  definition: TTaskDefinition9,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus9),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus9),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus9),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus9),
  resultStatus: Enum(TaskResultStatus9),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason9)),
  resolvedAt: Optional(TDateString37),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString37),
  debugReadyAt: Optional(TDateString37),
  debugStartedAt: Optional(TDateString37),
  debugEndedAt: Optional(TDateString37),
  cancellationRequestedAt: Optional(TDateString37),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString37),
  cancelledAt: Optional(TDateString37),
  concurrencyPool: Optional(TConcurrencyPool9),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext9),
  usedSecrets: Optional(Array2(TUsedSecret9)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString10, cacheKey: Enum(EnvironmentVariableCacheKey34) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString10),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess9)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact9)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest36)),
  previousLayers: Optional(Array2(TLayerWithManifest36)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest36)),
  filesystemLayers: Optional(Array2(TLayerWithManifest36)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString10)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration9),
      baseLayer: TBaseLayerDescriptor2
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification9),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath7)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult36)),
  whiteoutLayer: Optional(TLayerWithManifest36),
  outputLayers: Optional(Array2(TLayerWithManifest36)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey34) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem36)),
  testResults: Optional(Array2(TTestResults36)),
  artifacts: Optional(Array2(TArtifact36)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps28,
  networkTraffic: TNetworkTraffic9,
  outputRetryActions: Array2(TRetryAction25),
  retryAction: Optional(TRetryAction25),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest36)
});
var TRetryManifestEntry9 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry9 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString37,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString37),
  mostRecentlyAttemptedAt: Optional(TDateString37),
  finishedAt: Optional(TDateString37),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots9 = Object2({ resolution: Array2(TGraphNodeId10), runtime: Array2(TGraphNodeId10) });
var TRunGraph9 = Object2({
  roots: TGraphRoots9,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId10, Array2(TGraphNodeId10)),
    runtime: Record(TGraphNodeId10, Array2(TGraphNodeId10))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId10, Array2(TGraphNodeId10)),
    runtime: Record(TGraphNodeId10, Array2(TGraphNodeId10))
  }),
  subgraphs: Record(TGraphNodeId10, Object2({ roots: TGraphRoots9 })),
  parents: Record(TGraphNodeId10, TGraphNodeId10),
  definitionOrders: Record(TGraphNodeId10, Number2())
});
var TActor9 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState9 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState9)
});
var ApprovalRequestState6 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState6 || {});
var TApprovalRequest6 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState6)
});
var TRun9 = Object2({
  schemaVersion: Literal(ThisSchemaVersion9),
  persistenceExpiresAtSeconds: TEpochSeconds10,
  runId: String2(),
  createdAt: TDateString37,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor9),
  mintDirectoryArtifact: Optional(TArtifact36),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool9),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration9),
  eventNumber: Number2(),
  retries: Array2(TRetry9),
  approvalRequests: Array2(TApprovalRequest6),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph9,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry9)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey10, TConcurrencyPoolState9),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayerDescriptor2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus9),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus9),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus9),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus9),
  resultStatus: Enum(RunResultStatus9),
  waitingForLeaseAt: Optional(TDateString37),
  startedAt: Optional(TDateString37),
  cancellationRequestedAt: Optional(TDateString37),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString37)
});

// packages/schema/persisted/versioned/v47.ts
var ThisSchemaVersion10 = "v47" /* V47 */;
var TTaskOrGroupId38 = TBrandedString();
var TGraphNodeId11 = TBrandedString();
var TTemplateString11 = TBrandedString();
var TEvaluatedString11 = TBrandedString();
var TDateString38 = TBrandedString();
var TEpochSeconds11 = TBrandedNumber();
var TScopedTaskKey11 = TBrandedString();
var TaskType10 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType10 || {});
var TaskResultStatus10 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus10 || {});
var TaskExecutionStatus10 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus10 || {});
var TaskExecutionWaitingSubStatus10 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus10 || {});
var TaskExecutionAbortedSubStatus10 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus10 || {});
var TaskExecutionFinishedSubStatus10 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus10 || {});
var TaskAttemptReason10 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason10 || {});
var BackgroundProcessResultStatus37 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus37 || {});
var BackgroundProcessResultFinishedSubStatus37 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus37 || {});
var RunResultStatus10 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus10 || {});
var RunExecutionStatus10 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus10 || {});
var RunExecutionWaitingSubStatus10 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus10 || {});
var RunExecutionAbortedSubStatus10 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus10 || {});
var RunExecutionFinishedSubStatus10 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus10 || {});
var TSource10 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey35 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey35 || {});
var TExpandedEnvDescriptor10 = Object2({ value: Optional(TTemplateString11), cacheKey: Enum(EnvironmentVariableCacheKey35) });
var TEnvMergeStrategy10 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath37 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern37 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity37 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity37 || {});
var TProblemMatcher37 = Object2({ owner: String2(), severity: Optional(Enum(Severity37)), pattern: Array2(TProblemMatcherPattern37) });
var TProblemPath37 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath10 = Object2({ key: String2(), path: TTemplateString11 });
var TResolvedArtifactPath8 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck10 = Object2({ run: TTemplateString11, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess10 = Object2({
  key: String2(),
  command: TTemplateString11,
  readyCheck: Optional(TExpandedReadyCheck10),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType10 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType10 || {});
var TParallelismValue10 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification10 = Object2({
  cpus: Optional(TTemplateString11),
  memory: Optional(TTemplateString11),
  disk: Object2({ size: Optional(TTemplateString11) }),
  staticIps: Optional(TTemplateString11),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification10 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs10 = Object2({
  values: Optional(Record(String2(), TTemplateString11)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter10 = Object2({
  workspace: Optional(Union([Array2(TTemplateString11), TTemplateString11])),
  artifacts: Optional(Record(TTemplateString11, Union([Array2(TTemplateString11), TTemplateString11])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter10 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration3 = Object2({
  enabled: TTemplateString11,
  ttl: Optional(TTemplateString11)
});
var TTaskDefinitionWithoutParallel10 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification10),
  type: Optional(Enum(TaskType10)),
  after: Optional(TTemplateString11),
  if: Optional(TTemplateString11),
  source: Optional(TSource10),
  cacheConfiguration: TCacheConfiguration3,
  docker: Optional(TTemplateString11),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString11),
  filter: Optional(TInputFilesystemFilter10),
  backgroundProcesses: Optional(Array2(TBackgroundProcess10)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor10)),
  envMerge: Optional(Array2(TEnvMergeStrategy10)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath37)),
  artifactPaths: Optional(Array2(TArtifactPath10)),
  outputs: Optional(TTaskDefinitionOutputs10),
  problemMatchers: Optional(Array2(TProblemMatcher37)),
  problemPaths: Optional(Array2(TProblemPath37)),
  parallelismType: Optional(Enum(ParallelismType10)),
  parallelismValue: Optional(TParallelismValue10),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString11)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString11),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter10)
});
var TTaskDefinition10 = Composite([
  TTaskDefinitionWithoutParallel10,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel10),
    parallelKey: Optional(TTemplateString11),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString11), TTemplateString11]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString11)), TTemplateString11])),
    parallelismTotal: Optional(TTemplateString11)
  })
]);
var TLayerWithManifest37 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId38,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext10 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret10 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess10 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString11,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString11,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult37 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus37),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus37),
  startedAt: Optional(TDateString38),
  completedAt: Optional(TDateString38),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem37 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity37),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults37 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest27 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact37 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest27, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact10 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration10 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow10 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow10 || {});
var TConcurrencyPool10 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow10) });
var LeaseState10 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState10 || {});
var TTiming29 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps29 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming29)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming29)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming29),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming29),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming29.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming29),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming29),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming29),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming29),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming29),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming29),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming29),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming29)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming29.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic10 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction26 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact37)
});
var TBaseLayerSpecificationTriple3 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId3 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification3 = Union([TBaseLayerSpecificationTriple3, TBaseLayerSpecificationLayerId3]);
var TBaseLayerDescriptor3 = Composite([
  TBaseLayerSpecificationTriple3,
  TBaseLayerSpecificationLayerId3,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit3 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit3 || {});
var TTTL3 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit3)
});
var TResolvedCacheConfiguration2 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL3)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask10 = Object2({
  schemaVersion: Literal(ThisSchemaVersion10),
  taskId: TTaskOrGroupId38,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId11),
  generatorTaskId: Optional(TTaskOrGroupId38),
  definition: TTaskDefinition10,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus10),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus10),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus10),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus10),
  resultStatus: Enum(TaskResultStatus10),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason10)),
  resolvedAt: Optional(TDateString38),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString38),
  debugReadyAt: Optional(TDateString38),
  debugStartedAt: Optional(TDateString38),
  debugEndedAt: Optional(TDateString38),
  cancellationRequestedAt: Optional(TDateString38),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString38),
  cancelledAt: Optional(TDateString38),
  concurrencyPool: Optional(TConcurrencyPool10),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext10),
  usedSecrets: Optional(Array2(TUsedSecret10)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration2),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString11, cacheKey: Enum(EnvironmentVariableCacheKey35) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString11),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess10)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact10)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest37)),
  previousLayers: Optional(Array2(TLayerWithManifest37)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest37)),
  filesystemLayers: Optional(Array2(TLayerWithManifest37)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString11)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration10),
      baseLayer: TBaseLayerDescriptor3
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification10),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath8)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult37)),
  whiteoutLayer: Optional(TLayerWithManifest37),
  outputLayers: Optional(Array2(TLayerWithManifest37)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey35) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem37)),
  testResults: Optional(Array2(TTestResults37)),
  artifacts: Optional(Array2(TArtifact37)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps29,
  networkTraffic: TNetworkTraffic10,
  outputRetryActions: Array2(TRetryAction26),
  retryAction: Optional(TRetryAction26),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest37)
});
var TRetryManifestEntry10 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry10 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString38,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString38),
  mostRecentlyAttemptedAt: Optional(TDateString38),
  finishedAt: Optional(TDateString38),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots10 = Object2({ resolution: Array2(TGraphNodeId11), runtime: Array2(TGraphNodeId11) });
var TRunGraph10 = Object2({
  roots: TGraphRoots10,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId11, Array2(TGraphNodeId11)),
    runtime: Record(TGraphNodeId11, Array2(TGraphNodeId11))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId11, Array2(TGraphNodeId11)),
    runtime: Record(TGraphNodeId11, Array2(TGraphNodeId11))
  }),
  subgraphs: Record(TGraphNodeId11, Object2({ roots: TGraphRoots10 })),
  parents: Record(TGraphNodeId11, TGraphNodeId11),
  definitionOrders: Record(TGraphNodeId11, Number2())
});
var TActor10 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState10 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState10)
});
var ApprovalRequestState7 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState7 || {});
var TApprovalRequest7 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState7)
});
var TRun10 = Object2({
  schemaVersion: Literal(ThisSchemaVersion10),
  persistenceExpiresAtSeconds: TEpochSeconds11,
  runId: String2(),
  createdAt: TDateString38,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor10),
  mintDirectoryArtifact: Optional(TArtifact37),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool10),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration10),
  eventNumber: Number2(),
  retries: Array2(TRetry10),
  approvalRequests: Array2(TApprovalRequest7),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph10,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry10)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey11, TConcurrencyPoolState10),
  baseLayer: TBaseLayerDescriptor3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus10),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus10),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus10),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus10),
  resultStatus: Enum(RunResultStatus10),
  waitingForLeaseAt: Optional(TDateString38),
  startedAt: Optional(TDateString38),
  cancellationRequestedAt: Optional(TDateString38),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString38)
});

// packages/schema/persisted/versioned/v48.ts
var ThisSchemaVersion11 = "v48" /* V48 */;
var TTaskOrGroupId39 = TBrandedString();
var TGraphNodeId12 = TBrandedString();
var TTemplateString12 = TBrandedString();
var TEvaluatedString12 = TBrandedString();
var TDateString39 = TBrandedString();
var TEpochSeconds12 = TBrandedNumber();
var TScopedTaskKey12 = TBrandedString();
var TaskType11 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType11 || {});
var TaskResultStatus11 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus11 || {});
var TaskExecutionStatus11 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus11 || {});
var TaskExecutionWaitingSubStatus11 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus11 || {});
var TaskExecutionAbortedSubStatus11 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus11 || {});
var TaskExecutionFinishedSubStatus11 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus11 || {});
var TaskAttemptReason11 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason11 || {});
var BackgroundProcessResultStatus38 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus38 || {});
var BackgroundProcessResultFinishedSubStatus38 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus38 || {});
var RunResultStatus11 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus11 || {});
var RunExecutionStatus11 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus11 || {});
var RunExecutionWaitingSubStatus11 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus11 || {});
var RunExecutionAbortedSubStatus11 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus11 || {});
var RunExecutionFinishedSubStatus11 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus11 || {});
var TSource11 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey36 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey36 || {});
var TExpandedEnvDescriptor11 = Object2({ value: Optional(TTemplateString12), cacheKey: Enum(EnvironmentVariableCacheKey36) });
var TEnvMergeStrategy11 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath38 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern38 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity38 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity38 || {});
var TProblemMatcher38 = Object2({ owner: String2(), severity: Optional(Enum(Severity38)), pattern: Array2(TProblemMatcherPattern38) });
var TProblemPath38 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath11 = Object2({ key: String2(), path: TTemplateString12 });
var TResolvedArtifactPath9 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck11 = Object2({ run: TTemplateString12, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess11 = Object2({
  key: String2(),
  command: TTemplateString12,
  readyCheck: Optional(TExpandedReadyCheck11),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType11 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType11 || {});
var TParallelismValue11 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification11 = Object2({
  cpus: Optional(TTemplateString12),
  memory: Optional(TTemplateString12),
  disk: Object2({ size: Optional(TTemplateString12) }),
  staticIps: Optional(TTemplateString12),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification11 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs11 = Object2({
  values: Optional(Record(String2(), TTemplateString12)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor2 = Object2({ path: TTemplateString12, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor2 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet2 = Union([TTemplateString12, Array2(Union([TTemplateString12, TFilterDescriptor2]))]);
var TInputFilesystemFilter11 = Object2({
  workspace: Optional(TFilterSet2),
  artifacts: Optional(Record(TTemplateString12, TFilterSet2))
});
var TOutputFilesystemFilter11 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration4 = Object2({
  enabled: TTemplateString12,
  ttl: Optional(TTemplateString12)
});
var TTaskDefinitionWithoutParallel11 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification11),
  type: Optional(Enum(TaskType11)),
  after: Optional(TTemplateString12),
  if: Optional(TTemplateString12),
  source: Optional(TSource11),
  cacheConfiguration: TCacheConfiguration4,
  docker: Optional(TTemplateString12),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString12),
  filter: Optional(TInputFilesystemFilter11),
  backgroundProcesses: Optional(Array2(TBackgroundProcess11)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor11)),
  envMerge: Optional(Array2(TEnvMergeStrategy11)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath38)),
  artifactPaths: Optional(Array2(TArtifactPath11)),
  outputs: Optional(TTaskDefinitionOutputs11),
  problemMatchers: Optional(Array2(TProblemMatcher38)),
  problemPaths: Optional(Array2(TProblemPath38)),
  parallelismType: Optional(Enum(ParallelismType11)),
  parallelismValue: Optional(TParallelismValue11),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString12)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString12),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter11)
});
var TTaskDefinition11 = Composite([
  TTaskDefinitionWithoutParallel11,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel11),
    parallelKey: Optional(TTemplateString12),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString12), TTemplateString12]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString12)), TTemplateString12])),
    parallelismTotal: Optional(TTemplateString12)
  })
]);
var TLayerWithManifest38 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId39,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext11 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret11 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess11 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString12,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString12,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult38 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus38),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus38),
  startedAt: Optional(TDateString39),
  completedAt: Optional(TDateString39),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem38 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity38),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults38 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest28 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact38 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest28, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact11 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor2)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor2))
      })
    )
  )
});
var TRunToolCacheConfiguration11 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow11 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow11 || {});
var TConcurrencyPool11 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow11) });
var LeaseState11 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState11 || {});
var TTiming30 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps30 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming30)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming30)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming30),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming30),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming30.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming30),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming30),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming30),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming30),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming30),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming30),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming30),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming30)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming30.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic11 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction27 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact38)
});
var TBaseLayerSpecificationTriple4 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId4 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification4 = Union([TBaseLayerSpecificationTriple4, TBaseLayerSpecificationLayerId4]);
var TBaseLayerDescriptor4 = Composite([
  TBaseLayerSpecificationTriple4,
  TBaseLayerSpecificationLayerId4,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit4 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit4 || {});
var TTTL4 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit4)
});
var TResolvedCacheConfiguration3 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL4)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask11 = Object2({
  schemaVersion: Literal(ThisSchemaVersion11),
  taskId: TTaskOrGroupId39,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId12),
  generatorTaskId: Optional(TTaskOrGroupId39),
  definition: TTaskDefinition11,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus11),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus11),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus11),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus11),
  resultStatus: Enum(TaskResultStatus11),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason11)),
  resolvedAt: Optional(TDateString39),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString39),
  debugReadyAt: Optional(TDateString39),
  debugStartedAt: Optional(TDateString39),
  debugEndedAt: Optional(TDateString39),
  cancellationRequestedAt: Optional(TDateString39),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString39),
  cancelledAt: Optional(TDateString39),
  concurrencyPool: Optional(TConcurrencyPool11),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext11),
  usedSecrets: Optional(Array2(TUsedSecret11)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration3),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString12, cacheKey: Enum(EnvironmentVariableCacheKey36) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString12),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess11)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact11)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest38)),
  previousLayers: Optional(Array2(TLayerWithManifest38)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest38)),
  filesystemLayers: Optional(Array2(TLayerWithManifest38)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString12)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration11),
      baseLayer: TBaseLayerDescriptor4
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification11),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath9)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult38)),
  whiteoutLayer: Optional(TLayerWithManifest38),
  outputLayers: Optional(Array2(TLayerWithManifest38)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey36) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem38)),
  testResults: Optional(Array2(TTestResults38)),
  artifacts: Optional(Array2(TArtifact38)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps30,
  networkTraffic: TNetworkTraffic11,
  outputRetryActions: Array2(TRetryAction27),
  retryAction: Optional(TRetryAction27),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest38)
});
var TRetryManifestEntry11 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry11 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString39,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString39),
  mostRecentlyAttemptedAt: Optional(TDateString39),
  finishedAt: Optional(TDateString39),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots11 = Object2({ resolution: Array2(TGraphNodeId12), runtime: Array2(TGraphNodeId12) });
var TRunGraph11 = Object2({
  roots: TGraphRoots11,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId12, Array2(TGraphNodeId12)),
    runtime: Record(TGraphNodeId12, Array2(TGraphNodeId12))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId12, Array2(TGraphNodeId12)),
    runtime: Record(TGraphNodeId12, Array2(TGraphNodeId12))
  }),
  subgraphs: Record(TGraphNodeId12, Object2({ roots: TGraphRoots11 })),
  parents: Record(TGraphNodeId12, TGraphNodeId12),
  definitionOrders: Record(TGraphNodeId12, Number2())
});
var TActor11 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState11 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState11)
});
var ApprovalRequestState8 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState8 || {});
var TApprovalRequest8 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState8)
});
var TRun11 = Object2({
  schemaVersion: Literal(ThisSchemaVersion11),
  persistenceExpiresAtSeconds: TEpochSeconds12,
  runId: String2(),
  createdAt: TDateString39,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor11),
  mintDirectoryArtifact: Optional(TArtifact38),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool11),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration11),
  eventNumber: Number2(),
  retries: Array2(TRetry11),
  approvalRequests: Array2(TApprovalRequest8),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph11,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry11)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey12, TConcurrencyPoolState11),
  baseLayer: TBaseLayerDescriptor4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus11),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus11),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus11),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus11),
  resultStatus: Enum(RunResultStatus11),
  waitingForLeaseAt: Optional(TDateString39),
  startedAt: Optional(TDateString39),
  cancellationRequestedAt: Optional(TDateString39),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString39)
});

// packages/schema/persisted/versioned/v49.ts
var ThisSchemaVersion12 = "v49" /* V49 */;
var TTaskOrGroupId40 = TBrandedString();
var TGraphNodeId13 = TBrandedString();
var TTemplateString13 = TBrandedString();
var TEvaluatedString13 = TBrandedString();
var TDateString40 = TBrandedString();
var TEpochSeconds13 = TBrandedNumber();
var TScopedTaskKey13 = TBrandedString();
var TaskType12 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType12 || {});
var TaskResultStatus12 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus12 || {});
var TaskExecutionStatus12 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus12 || {});
var TaskExecutionWaitingSubStatus12 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus12 || {});
var TaskExecutionAbortedSubStatus12 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus12 || {});
var TaskExecutionFinishedSubStatus12 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus12 || {});
var TaskAttemptReason12 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason12 || {});
var BackgroundProcessResultStatus39 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus39 || {});
var BackgroundProcessResultFinishedSubStatus39 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus39 || {});
var RunResultStatus12 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus12 || {});
var RunExecutionStatus12 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus12 || {});
var RunExecutionWaitingSubStatus12 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus12 || {});
var RunExecutionAbortedSubStatus12 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus12 || {});
var RunExecutionFinishedSubStatus12 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus12 || {});
var TSource12 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey37 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey37 || {});
var TExpandedEnvDescriptor12 = Object2({ value: Optional(TTemplateString13), cacheKey: Enum(EnvironmentVariableCacheKey37) });
var TEnvMergeStrategy12 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath39 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern39 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity39 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity39 || {});
var TProblemMatcher39 = Object2({ owner: String2(), severity: Optional(Enum(Severity39)), pattern: Array2(TProblemMatcherPattern39) });
var TProblemPath39 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath12 = Object2({ key: String2(), path: TTemplateString13 });
var TResolvedArtifactPath10 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck12 = Object2({ run: TTemplateString13, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess12 = Object2({
  key: String2(),
  command: TTemplateString13,
  readyCheck: Optional(TExpandedReadyCheck12),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType12 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType12 || {});
var TParallelismValue12 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification12 = Object2({
  cpus: Optional(TTemplateString13),
  memory: Optional(TTemplateString13),
  disk: Object2({ size: Optional(TTemplateString13) }),
  staticIps: Optional(TTemplateString13),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification12 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs12 = Object2({
  values: Optional(Record(String2(), TTemplateString13)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor3 = Object2({ path: TTemplateString13, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor3 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet3 = Union([TTemplateString13, Array2(Union([TTemplateString13, TFilterDescriptor3]))]);
var TInputFilesystemFilter12 = Object2({
  workspace: Optional(TFilterSet3),
  artifacts: Optional(Record(TTemplateString13, TFilterSet3))
});
var TOutputFilesystemFilter12 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration5 = Object2({
  enabled: TTemplateString13,
  ttl: Optional(TTemplateString13)
});
var TTaskDefinitionWithoutParallel12 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification12),
  type: Optional(Enum(TaskType12)),
  after: Optional(TTemplateString13),
  if: Optional(TTemplateString13),
  source: Optional(TSource12),
  cacheConfiguration: TCacheConfiguration5,
  docker: Optional(TTemplateString13),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString13),
  filter: Optional(TInputFilesystemFilter12),
  backgroundProcesses: Optional(Array2(TBackgroundProcess12)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor12)),
  envMerge: Optional(Array2(TEnvMergeStrategy12)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath39)),
  artifactPaths: Optional(Array2(TArtifactPath12)),
  outputs: Optional(TTaskDefinitionOutputs12),
  problemMatchers: Optional(Array2(TProblemMatcher39)),
  problemPaths: Optional(Array2(TProblemPath39)),
  parallelismType: Optional(Enum(ParallelismType12)),
  parallelismValue: Optional(TParallelismValue12),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString13)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString13),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter12)
});
var TCrossRunSource2 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents2 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource2,
  relativeScopedKey: String2()
});
var TTaskDefinition12 = Composite([
  TTaskDefinitionWithoutParallel12,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel12),
    parallelKey: Optional(TTemplateString13),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString13), TTemplateString13]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString13)), TTemplateString13])),
    parallelismTotal: Optional(TTemplateString13)
  })
]);
var TLayerWithManifest39 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId40,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext12 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret12 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess12 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString13,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString13,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult39 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus39),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus39),
  startedAt: Optional(TDateString40),
  completedAt: Optional(TDateString40),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem39 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity39),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults39 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest29 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact39 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest29, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact12 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor3)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor3))
      })
    )
  )
});
var TRunToolCacheConfiguration12 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow12 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow12 || {});
var TConcurrencyPool12 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow12) });
var LeaseState12 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState12 || {});
var TTiming31 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps31 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming31)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming31)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming31),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming31),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming31.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming31),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming31),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming31),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming31),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming31),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming31),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming31),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming31)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming31.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic12 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction28 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact39)
});
var TBaseLayerSpecificationTriple5 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId5 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification5 = Union([TBaseLayerSpecificationTriple5, TBaseLayerSpecificationLayerId5]);
var TBaseLayerDescriptor5 = Composite([
  TBaseLayerSpecificationTriple5,
  TBaseLayerSpecificationLayerId5,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit5 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit5 || {});
var TTTL5 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit5)
});
var TResolvedCacheConfiguration4 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL5)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip16 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask12 = Object2({
  schemaVersion: Literal(ThisSchemaVersion12),
  taskId: TTaskOrGroupId40,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId13),
  generatorTaskId: Optional(TTaskOrGroupId40),
  definition: TTaskDefinition12,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus12),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus12),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus12),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus12),
  resultStatus: Enum(TaskResultStatus12),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason12)),
  resolvedAt: Optional(TDateString40),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString40),
  debugReadyAt: Optional(TDateString40),
  debugStartedAt: Optional(TDateString40),
  debugEndedAt: Optional(TDateString40),
  cancellationRequestedAt: Optional(TDateString40),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString40),
  cancelledAt: Optional(TDateString40),
  concurrencyPool: Optional(TConcurrencyPool12),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext12),
  usedSecrets: Optional(Array2(TUsedSecret12)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration4),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString13, cacheKey: Enum(EnvironmentVariableCacheKey37) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString13),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess12)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact12)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest39)),
  previousLayers: Optional(Array2(TLayerWithManifest39)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest39)),
  filesystemLayers: Optional(Array2(TLayerWithManifest39)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString13)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration12),
      baseLayer: TBaseLayerDescriptor5,
      crossRunSource: Optional(TCrossRunSource2)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification12),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath10)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult39)),
  whiteoutLayer: Optional(TLayerWithManifest39),
  outputLayers: Optional(Array2(TLayerWithManifest39)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey37) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem39)),
  testResults: Optional(Array2(TTestResults39)),
  artifacts: Optional(Array2(TArtifact39)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents2),
  tips: Array2(TTip16),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps31,
  networkTraffic: TNetworkTraffic12,
  outputRetryActions: Array2(TRetryAction28),
  retryAction: Optional(TRetryAction28),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest39)
});
var TRetryManifestEntry12 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry12 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString40,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString40),
  mostRecentlyAttemptedAt: Optional(TDateString40),
  finishedAt: Optional(TDateString40),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots12 = Object2({ resolution: Array2(TGraphNodeId13), runtime: Array2(TGraphNodeId13) });
var TRunGraph12 = Object2({
  roots: TGraphRoots12,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId13, Array2(TGraphNodeId13)),
    runtime: Record(TGraphNodeId13, Array2(TGraphNodeId13))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId13, Array2(TGraphNodeId13)),
    runtime: Record(TGraphNodeId13, Array2(TGraphNodeId13))
  }),
  subgraphs: Record(TGraphNodeId13, Object2({ roots: TGraphRoots12 })),
  parents: Record(TGraphNodeId13, TGraphNodeId13),
  definitionOrders: Record(TGraphNodeId13, Number2())
});
var TActor12 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState12 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState12)
});
var ApprovalRequestState9 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState9 || {});
var TApprovalRequest9 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState9)
});
var TRun12 = Object2({
  schemaVersion: Literal(ThisSchemaVersion12),
  persistenceExpiresAtSeconds: TEpochSeconds13,
  runId: String2(),
  createdAt: TDateString40,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor12),
  mintDirectoryArtifact: Optional(TArtifact39),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool12),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration12),
  eventNumber: Number2(),
  retries: Array2(TRetry12),
  approvalRequests: Array2(TApprovalRequest9),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph12,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry12)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey13, TConcurrencyPoolState12),
  baseLayer: TBaseLayerDescriptor5,
  crossRunSource: TCrossRunSource2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus12),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus12),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus12),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus12),
  resultStatus: Enum(RunResultStatus12),
  waitingForLeaseAt: Optional(TDateString40),
  startedAt: Optional(TDateString40),
  cancellationRequestedAt: Optional(TDateString40),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString40)
});

// packages/schema/persisted/versioned/v50.ts
var ThisSchemaVersion13 = "v50" /* V50 */;
var TTaskOrGroupId41 = TBrandedString();
var TGraphNodeId14 = TBrandedString();
var TTemplateString14 = TBrandedString();
var TEvaluatedString14 = TBrandedString();
var TDateString41 = TBrandedString();
var TEpochSeconds14 = TBrandedNumber();
var TScopedTaskKey14 = TBrandedString();
var TaskType13 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType13 || {});
var TaskResultStatus13 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus13 || {});
var TaskExecutionStatus13 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus13 || {});
var TaskExecutionWaitingSubStatus13 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus13 || {});
var TaskExecutionAbortedSubStatus13 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus13 || {});
var TaskExecutionFinishedSubStatus13 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus13 || {});
var TaskAttemptReason13 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason13 || {});
var BackgroundProcessResultStatus40 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus40 || {});
var BackgroundProcessResultFinishedSubStatus40 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus40 || {});
var RunResultStatus13 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus13 || {});
var RunExecutionStatus13 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus13 || {});
var RunExecutionWaitingSubStatus13 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus13 || {});
var RunExecutionAbortedSubStatus13 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus13 || {});
var RunExecutionFinishedSubStatus13 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus13 || {});
var TSource13 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey38 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey38 || {});
var TExpandedEnvDescriptor13 = Object2({ value: Optional(TTemplateString14), cacheKey: Enum(EnvironmentVariableCacheKey38) });
var TEnvMergeStrategy13 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath40 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern40 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity40 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity40 || {});
var TProblemMatcher40 = Object2({ owner: String2(), severity: Optional(Enum(Severity40)), pattern: Array2(TProblemMatcherPattern40) });
var TProblemPath40 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath13 = Object2({ key: String2(), path: TTemplateString14 });
var TResolvedArtifactPath11 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck13 = Object2({ run: TTemplateString14, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess13 = Object2({
  key: String2(),
  command: TTemplateString14,
  readyCheck: Optional(TExpandedReadyCheck13),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType13 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType13 || {});
var TParallelismValue13 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification13 = Object2({
  cpus: Optional(TTemplateString14),
  memory: Optional(TTemplateString14),
  disk: Object2({ size: Optional(TTemplateString14) }),
  staticIps: Optional(TTemplateString14),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification13 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs13 = Object2({
  values: Optional(Record(String2(), TTemplateString14)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor4 = Object2({ path: TTemplateString14, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor4 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet4 = Union([TTemplateString14, Array2(Union([TTemplateString14, TFilterDescriptor4]))]);
var TInputFilesystemFilter13 = Object2({
  workspace: Optional(TFilterSet4),
  artifacts: Optional(Record(TTemplateString14, TFilterSet4))
});
var TOutputFilesystemFilter13 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration6 = Object2({
  enabled: TTemplateString14,
  ttl: Optional(TTemplateString14)
});
var TTaskDefinitionWithoutParallel13 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification13),
  type: Optional(Enum(TaskType13)),
  after: Optional(TTemplateString14),
  if: Optional(TTemplateString14),
  source: Optional(TSource13),
  cacheConfiguration: TCacheConfiguration6,
  docker: Optional(TTemplateString14),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString14),
  filter: Optional(TInputFilesystemFilter13),
  backgroundProcesses: Optional(Array2(TBackgroundProcess13)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor13)),
  envMerge: Optional(Array2(TEnvMergeStrategy13)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath40)),
  artifactPaths: Optional(Array2(TArtifactPath13)),
  outputs: Optional(TTaskDefinitionOutputs13),
  problemMatchers: Optional(Array2(TProblemMatcher40)),
  problemPaths: Optional(Array2(TProblemPath40)),
  parallelismType: Optional(Enum(ParallelismType13)),
  parallelismValue: Optional(TParallelismValue13),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString14)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString14),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter13)
});
var TCrossRunSource3 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents3 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource3,
  relativeScopedKey: String2()
});
var TTaskDefinition13 = Composite([
  TTaskDefinitionWithoutParallel13,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel13),
    parallelKey: Optional(TTemplateString14),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString14), TTemplateString14]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString14)), TTemplateString14])),
    parallelismTotal: Optional(TTemplateString14)
  })
]);
var TLayerWithManifest40 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId41,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext13 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret13 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess13 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString14,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString14,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult40 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus40),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus40),
  startedAt: Optional(TDateString41),
  completedAt: Optional(TDateString41),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem40 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity40),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults40 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest30 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact40 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest30, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact13 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor4)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor4))
      })
    )
  )
});
var TRunToolCacheConfiguration13 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow13 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow13 || {});
var TConcurrencyPool13 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow13) });
var LeaseState13 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState13 || {});
var TTiming32 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps32 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming32)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming32)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming32),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming32),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming32.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming32),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming32),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming32),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming32),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming32),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming32),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming32),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming32)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming32.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic13 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction29 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact40)
});
var TBaseLayerSpecificationTriple6 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId6 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification6 = Union([TBaseLayerSpecificationTriple6, TBaseLayerSpecificationLayerId6]);
var TBaseLayerDescriptor6 = Composite([
  TBaseLayerSpecificationTriple6,
  TBaseLayerSpecificationLayerId6,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit6 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit6 || {});
var TTTL6 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit6)
});
var TResolvedCacheConfiguration5 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL6)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip17 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask13 = Object2({
  schemaVersion: Literal(ThisSchemaVersion13),
  taskId: TTaskOrGroupId41,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId14),
  generatorTaskId: Optional(TTaskOrGroupId41),
  definition: TTaskDefinition13,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus13),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus13),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus13),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus13),
  resultStatus: Enum(TaskResultStatus13),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason13)),
  resolvedAt: Optional(TDateString41),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString41),
  debugReadyAt: Optional(TDateString41),
  debugStartedAt: Optional(TDateString41),
  debugEndedAt: Optional(TDateString41),
  cancellationRequestedAt: Optional(TDateString41),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString41),
  cancelledAt: Optional(TDateString41),
  concurrencyPool: Optional(TConcurrencyPool13),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext13),
  usedSecrets: Optional(Array2(TUsedSecret13)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration5),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString14, cacheKey: Enum(EnvironmentVariableCacheKey38) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString14),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess13)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact13)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest40)),
  previousLayers: Optional(Array2(TLayerWithManifest40)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest40)),
  filesystemLayers: Optional(Array2(TLayerWithManifest40)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString14)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration13),
      baseLayer: TBaseLayerDescriptor6,
      crossRunSource: Optional(TCrossRunSource3)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification13),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath11)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult40)),
  whiteoutLayer: Optional(TLayerWithManifest40),
  outputLayers: Optional(Array2(TLayerWithManifest40)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey38) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem40)),
  testResults: Optional(Array2(TTestResults40)),
  artifacts: Optional(Array2(TArtifact40)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents3),
  tips: Array2(TTip17),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps32,
  networkTraffic: TNetworkTraffic13,
  outputRetryActions: Array2(TRetryAction29),
  retryAction: Optional(TRetryAction29),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest40)
});
var TRetryManifestEntry13 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry13 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString41,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString41),
  mostRecentlyAttemptedAt: Optional(TDateString41),
  finishedAt: Optional(TDateString41),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots13 = Object2({ resolution: Array2(TGraphNodeId14), runtime: Array2(TGraphNodeId14) });
var TRunGraph13 = Object2({
  roots: TGraphRoots13,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId14, Array2(TGraphNodeId14)),
    runtime: Record(TGraphNodeId14, Array2(TGraphNodeId14))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId14, Array2(TGraphNodeId14)),
    runtime: Record(TGraphNodeId14, Array2(TGraphNodeId14))
  }),
  subgraphs: Record(TGraphNodeId14, Object2({ roots: TGraphRoots13 })),
  parents: Record(TGraphNodeId14, TGraphNodeId14),
  definitionOrders: Record(TGraphNodeId14, Number2())
});
var TActor13 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState13 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState13)
});
var ApprovalRequestState10 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState10 || {});
var TApprovalRequest10 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState10)
});
var TRun13 = Object2({
  schemaVersion: Literal(ThisSchemaVersion13),
  persistenceExpiresAtSeconds: TEpochSeconds14,
  runId: String2(),
  createdAt: TDateString41,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor13),
  mintDirectoryArtifact: Optional(TArtifact40),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool13),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration13),
  eventNumber: Number2(),
  retries: Array2(TRetry13),
  approvalRequests: Array2(TApprovalRequest10),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph13,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry13)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey14, TConcurrencyPoolState13),
  baseLayer: TBaseLayerDescriptor6,
  crossRunSource: TCrossRunSource3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus13),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus13),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus13),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus13),
  resultStatus: Enum(RunResultStatus13),
  waitingForLeaseAt: Optional(TDateString41),
  startedAt: Optional(TDateString41),
  cancellationRequestedAt: Optional(TDateString41),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString41)
});

// packages/schema/persisted/versioned/v51.ts
var ThisSchemaVersion14 = "v51" /* V51 */;
var TTaskOrGroupId42 = TBrandedString();
var TGraphNodeId15 = TBrandedString();
var TTemplateString15 = TBrandedString();
var TEvaluatedString15 = TBrandedString();
var TDateString42 = TBrandedString();
var TEpochSeconds15 = TBrandedNumber();
var TScopedTaskKey15 = TBrandedString();
var TaskType14 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType14 || {});
var TaskResultStatus14 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus14 || {});
var TaskExecutionStatus14 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus14 || {});
var TaskExecutionWaitingSubStatus14 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus14 || {});
var TaskExecutionAbortedSubStatus14 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus14 || {});
var TaskExecutionFinishedSubStatus14 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus14 || {});
var TaskAttemptReason14 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason14 || {});
var BackgroundProcessResultStatus41 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus41 || {});
var BackgroundProcessResultFinishedSubStatus41 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus41 || {});
var RunResultStatus14 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus14 || {});
var RunExecutionStatus14 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus14 || {});
var RunExecutionWaitingSubStatus14 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus14 || {});
var RunExecutionAbortedSubStatus14 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus14 || {});
var RunExecutionFinishedSubStatus14 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus14 || {});
var TSource14 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey39 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey39 || {});
var TExpandedEnvDescriptor14 = Object2({ value: Optional(TTemplateString15), cacheKey: Enum(EnvironmentVariableCacheKey39) });
var TEnvMergeStrategy14 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath41 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern41 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity41 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity41 || {});
var TProblemMatcher41 = Object2({ owner: String2(), severity: Optional(Enum(Severity41)), pattern: Array2(TProblemMatcherPattern41) });
var TProblemPath41 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath14 = Object2({ key: String2(), path: TTemplateString15 });
var TResolvedArtifactPath12 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck14 = Object2({ run: TTemplateString15, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess14 = Object2({
  key: String2(),
  command: TTemplateString15,
  readyCheck: Optional(TExpandedReadyCheck14),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType14 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType14 || {});
var TParallelismValue14 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification14 = Object2({
  cpus: Optional(TTemplateString15),
  memory: Optional(TTemplateString15),
  disk: Object2({ size: Optional(TTemplateString15) }),
  staticIps: Optional(TTemplateString15),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification14 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs14 = Object2({
  values: Optional(Record(String2(), TTemplateString15)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor5 = Object2({ path: TTemplateString15, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor5 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet5 = Union([TTemplateString15, Array2(Union([TTemplateString15, TFilterDescriptor5]))]);
var TInputFilesystemFilter14 = Object2({
  workspace: Optional(TFilterSet5),
  artifacts: Optional(Record(TTemplateString15, TFilterSet5))
});
var TOutputFilesystemFilter14 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration7 = Object2({
  enabled: TTemplateString15,
  ttl: Optional(TTemplateString15)
});
var TTaskDefinitionWithoutParallel14 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification14),
  type: Optional(Enum(TaskType14)),
  after: Optional(TTemplateString15),
  if: Optional(TTemplateString15),
  source: Optional(TSource14),
  cacheConfiguration: TCacheConfiguration7,
  docker: Optional(TTemplateString15),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString15),
  filter: Optional(TInputFilesystemFilter14),
  backgroundProcesses: Optional(Array2(TBackgroundProcess14)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor14)),
  envMerge: Optional(Array2(TEnvMergeStrategy14)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath41)),
  artifactPaths: Optional(Array2(TArtifactPath14)),
  outputs: Optional(TTaskDefinitionOutputs14),
  problemMatchers: Optional(Array2(TProblemMatcher41)),
  problemPaths: Optional(Array2(TProblemPath41)),
  parallelismType: Optional(Enum(ParallelismType14)),
  parallelismValue: Optional(TParallelismValue14),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString15)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString15),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter14)
});
var TCrossRunSource4 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents4 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource4,
  relativeScopedKey: String2()
});
var TTaskDefinition14 = Composite([
  TTaskDefinitionWithoutParallel14,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel14),
    parallelKey: Optional(TTemplateString15),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString15), TTemplateString15]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString15)), TTemplateString15])),
    parallelismTotal: Optional(TTemplateString15)
  })
]);
var TLayerWithManifest41 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId42,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext14 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret14 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess14 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString15,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString15,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult41 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus41),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus41),
  startedAt: Optional(TDateString42),
  completedAt: Optional(TDateString42),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem41 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity41),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults41 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest31 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact41 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest31, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact14 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor5)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor5))
      })
    )
  )
});
var TRunToolCacheConfiguration14 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow14 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow14 || {});
var TConcurrencyPool14 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow14) });
var LeaseState14 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState14 || {});
var TTiming33 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps33 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming33)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming33)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming33),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming33),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming33.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming33),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming33),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming33),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming33),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming33),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming33),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming33),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming33)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming33.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic14 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction30 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact41)
});
var TBaseLayerSpecificationTriple7 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId7 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification7 = Union([TBaseLayerSpecificationTriple7, TBaseLayerSpecificationLayerId7]);
var TBaseLayerDescriptor7 = Composite([
  TBaseLayerSpecificationTriple7,
  TBaseLayerSpecificationLayerId7,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit7 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit7 || {});
var TTTL7 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit7)
});
var TResolvedCacheConfiguration6 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL7)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip18 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask14 = Object2({
  schemaVersion: Literal(ThisSchemaVersion14),
  taskId: TTaskOrGroupId42,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId15),
  generatorTaskId: Optional(TTaskOrGroupId42),
  definition: TTaskDefinition14,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus14),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus14),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus14),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus14),
  resultStatus: Enum(TaskResultStatus14),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason14)),
  resolvedAt: Optional(TDateString42),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString42),
  debugReadyAt: Optional(TDateString42),
  debugStartedAt: Optional(TDateString42),
  debugEndedAt: Optional(TDateString42),
  cancellationRequestedAt: Optional(TDateString42),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString42),
  cancelledAt: Optional(TDateString42),
  concurrencyPool: Optional(TConcurrencyPool14),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext14),
  usedSecrets: Optional(Array2(TUsedSecret14)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration6),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString15, cacheKey: Enum(EnvironmentVariableCacheKey39) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString15),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess14)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact14)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest41)),
  previousLayers: Optional(Array2(TLayerWithManifest41)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest41)),
  filesystemLayers: Optional(Array2(TLayerWithManifest41)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString15)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration14),
      baseLayer: TBaseLayerDescriptor7,
      crossRunSource: Optional(TCrossRunSource4)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification14),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath12)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult41)),
  whiteoutLayer: Optional(TLayerWithManifest41),
  outputLayers: Optional(Array2(TLayerWithManifest41)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey39) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem41)),
  testResults: Optional(Array2(TTestResults41)),
  artifacts: Optional(Array2(TArtifact41)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents4),
  tips: Array2(TTip18),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps33,
  networkTraffic: TNetworkTraffic14,
  outputRetryActions: Array2(TRetryAction30),
  retryAction: Optional(TRetryAction30),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest41)
});
var TRetryManifestEntry14 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry14 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString42,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString42),
  mostRecentlyAttemptedAt: Optional(TDateString42),
  finishedAt: Optional(TDateString42),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots14 = Object2({ resolution: Array2(TGraphNodeId15), runtime: Array2(TGraphNodeId15) });
var TRunGraph14 = Object2({
  roots: TGraphRoots14,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId15, Array2(TGraphNodeId15)),
    runtime: Record(TGraphNodeId15, Array2(TGraphNodeId15))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId15, Array2(TGraphNodeId15)),
    runtime: Record(TGraphNodeId15, Array2(TGraphNodeId15))
  }),
  subgraphs: Record(TGraphNodeId15, Object2({ roots: TGraphRoots14 })),
  parents: Record(TGraphNodeId15, TGraphNodeId15),
  definitionOrders: Record(TGraphNodeId15, Number2())
});
var TActor14 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState14 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState14)
});
var ApprovalRequestState11 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState11 || {});
var TApprovalRequest11 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState11)
});
var TRun14 = Object2({
  schemaVersion: Literal(ThisSchemaVersion14),
  persistenceExpiresAtSeconds: TEpochSeconds15,
  runId: String2(),
  createdAt: TDateString42,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor14),
  mintDirectoryArtifact: Optional(TArtifact41),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool14),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration14),
  eventNumber: Number2(),
  retries: Array2(TRetry14),
  approvalRequests: Array2(TApprovalRequest11),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph14,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry14)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey15, TConcurrencyPoolState14),
  baseLayer: TBaseLayerDescriptor7,
  crossRunSource: TCrossRunSource4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus14),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus14),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus14),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus14),
  resultStatus: Enum(RunResultStatus14),
  waitingForLeaseAt: Optional(TDateString42),
  startedAt: Optional(TDateString42),
  cancellationRequestedAt: Optional(TDateString42),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString42)
});

// packages/schema/persisted/versioned/v52.ts
var ThisSchemaVersion15 = "v52" /* V52 */;
var TTaskOrGroupId43 = TBrandedString();
var TGraphNodeId16 = TBrandedString();
var TTemplateString16 = TBrandedString();
var TEvaluatedString16 = TBrandedString();
var TDateString43 = TBrandedString();
var TEpochSeconds16 = TBrandedNumber();
var TScopedTaskKey16 = TBrandedString();
var TaskType15 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType15 || {});
var TaskResultStatus15 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus15 || {});
var TaskExecutionStatus15 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus15 || {});
var TaskExecutionWaitingSubStatus15 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus15 || {});
var TaskExecutionAbortedSubStatus15 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus15 || {});
var TaskExecutionFinishedSubStatus15 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus15 || {});
var TaskAttemptReason15 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason15 || {});
var BackgroundProcessResultStatus42 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus42 || {});
var BackgroundProcessResultFinishedSubStatus42 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus42 || {});
var RunResultStatus15 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus15 || {});
var RunExecutionStatus15 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus15 || {});
var RunExecutionWaitingSubStatus15 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus15 || {});
var RunExecutionAbortedSubStatus15 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus15 || {});
var RunExecutionFinishedSubStatus15 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus15 || {});
var TSource15 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey40 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey40 || {});
var TExpandedEnvDescriptor15 = Object2({ value: Optional(TTemplateString16), cacheKey: Enum(EnvironmentVariableCacheKey40) });
var TEnvMergeStrategy15 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath42 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern42 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity42 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity42 || {});
var TProblemMatcher42 = Object2({ owner: String2(), severity: Optional(Enum(Severity42)), pattern: Array2(TProblemMatcherPattern42) });
var TProblemPath42 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath15 = Object2({ key: String2(), path: TTemplateString16 });
var TResolvedArtifactPath13 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck15 = Object2({ run: TTemplateString16, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess15 = Object2({
  key: String2(),
  command: TTemplateString16,
  readyCheck: Optional(TExpandedReadyCheck15),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType15 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType15 || {});
var TParallelismValue15 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification15 = Object2({
  cpus: Optional(TTemplateString16),
  memory: Optional(TTemplateString16),
  disk: Object2({ size: Optional(TTemplateString16) }),
  staticIps: Optional(TTemplateString16),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification15 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs15 = Object2({
  values: Optional(Record(String2(), TTemplateString16)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor6 = Object2({ path: TTemplateString16, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor6 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet6 = Union([TTemplateString16, Array2(Union([TTemplateString16, TFilterDescriptor6]))]);
var TInputFilesystemFilter15 = Object2({
  workspace: Optional(TFilterSet6),
  artifacts: Optional(Record(TTemplateString16, TFilterSet6))
});
var TOutputFilesystemFilter15 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration8 = Object2({
  enabled: TTemplateString16,
  ttl: Optional(TTemplateString16)
});
var TTaskDefinitionWithoutParallel15 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification15),
  type: Optional(Enum(TaskType15)),
  after: Optional(TTemplateString16),
  if: Optional(TTemplateString16),
  source: Optional(TSource15),
  cacheConfiguration: TCacheConfiguration8,
  docker: Optional(TTemplateString16),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString16),
  filter: Optional(TInputFilesystemFilter15),
  backgroundProcesses: Optional(Array2(TBackgroundProcess15)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor15)),
  envMerge: Optional(Array2(TEnvMergeStrategy15)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath42)),
  artifactPaths: Optional(Array2(TArtifactPath15)),
  outputs: Optional(TTaskDefinitionOutputs15),
  problemMatchers: Optional(Array2(TProblemMatcher42)),
  problemPaths: Optional(Array2(TProblemPath42)),
  parallelismType: Optional(Enum(ParallelismType15)),
  parallelismValue: Optional(TParallelismValue15),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString16)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString16),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter15)
});
var TCrossRunSource5 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents5 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource5,
  relativeScopedKey: String2()
});
var TTaskDefinition15 = Composite([
  TTaskDefinitionWithoutParallel15,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel15),
    parallelKey: Optional(TTemplateString16),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString16), TTemplateString16]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString16)), TTemplateString16])),
    parallelismTotal: Optional(TTemplateString16)
  })
]);
var TLayerWithManifest42 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId43,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext15 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret15 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess15 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString16,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString16,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult42 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus42),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus42),
  startedAt: Optional(TDateString43),
  completedAt: Optional(TDateString43),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem42 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity42),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults42 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest32 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact42 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest32, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact15 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor6)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor6))
      })
    )
  )
});
var TGithubStatusCheck = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration15 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow15 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow15 || {});
var TConcurrencyPool15 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow15) });
var LeaseState15 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState15 || {});
var TTiming34 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps34 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming34)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming34)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming34),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming34),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming34.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming34),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming34),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming34),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming34),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming34),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming34),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming34),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming34)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming34.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic15 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction31 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact42)
});
var TBaseLayerSpecificationTriple8 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId8 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification8 = Union([TBaseLayerSpecificationTriple8, TBaseLayerSpecificationLayerId8]);
var TBaseLayerDescriptor8 = Composite([
  TBaseLayerSpecificationTriple8,
  TBaseLayerSpecificationLayerId8,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit8 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit8 || {});
var TTTL8 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit8)
});
var TResolvedCacheConfiguration7 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL8)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip19 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask15 = Object2({
  schemaVersion: Literal(ThisSchemaVersion15),
  taskId: TTaskOrGroupId43,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId16),
  generatorTaskId: Optional(TTaskOrGroupId43),
  definition: TTaskDefinition15,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus15),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus15),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus15),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus15),
  resultStatus: Enum(TaskResultStatus15),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason15)),
  resolvedAt: Optional(TDateString43),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString43),
  debugReadyAt: Optional(TDateString43),
  debugStartedAt: Optional(TDateString43),
  debugEndedAt: Optional(TDateString43),
  cancellationRequestedAt: Optional(TDateString43),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString43),
  cancelledAt: Optional(TDateString43),
  concurrencyPool: Optional(TConcurrencyPool15),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext15),
  usedSecrets: Optional(Array2(TUsedSecret15)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration7),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString16, cacheKey: Enum(EnvironmentVariableCacheKey40) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString16),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess15)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact15)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest42)),
  previousLayers: Optional(Array2(TLayerWithManifest42)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest42)),
  filesystemLayers: Optional(Array2(TLayerWithManifest42)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString16)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration15),
      baseLayer: TBaseLayerDescriptor8,
      crossRunSource: Optional(TCrossRunSource5)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification15),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath13)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult42)),
  whiteoutLayer: Optional(TLayerWithManifest42),
  outputLayers: Optional(Array2(TLayerWithManifest42)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey40) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem42)),
  testResults: Optional(Array2(TTestResults42)),
  artifacts: Optional(Array2(TArtifact42)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents5),
  tips: Array2(TTip19),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps34,
  networkTraffic: TNetworkTraffic15,
  outputRetryActions: Array2(TRetryAction31),
  retryAction: Optional(TRetryAction31),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest42)
});
var TRetryManifestEntry15 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry15 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString43,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString43),
  mostRecentlyAttemptedAt: Optional(TDateString43),
  finishedAt: Optional(TDateString43),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots15 = Object2({ resolution: Array2(TGraphNodeId16), runtime: Array2(TGraphNodeId16) });
var TRunGraph15 = Object2({
  roots: TGraphRoots15,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId16, Array2(TGraphNodeId16)),
    runtime: Record(TGraphNodeId16, Array2(TGraphNodeId16))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId16, Array2(TGraphNodeId16)),
    runtime: Record(TGraphNodeId16, Array2(TGraphNodeId16))
  }),
  subgraphs: Record(TGraphNodeId16, Object2({ roots: TGraphRoots15 })),
  parents: Record(TGraphNodeId16, TGraphNodeId16),
  definitionOrders: Record(TGraphNodeId16, Number2())
});
var TActor15 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState15 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState15)
});
var ApprovalRequestState12 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState12 || {});
var TApprovalRequest12 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState12)
});
var TRun15 = Object2({
  schemaVersion: Literal(ThisSchemaVersion15),
  persistenceExpiresAtSeconds: TEpochSeconds16,
  runId: String2(),
  createdAt: TDateString43,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor15),
  mintDirectoryArtifact: Optional(TArtifact42),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool15),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration15),
  eventNumber: Number2(),
  retries: Array2(TRetry15),
  approvalRequests: Array2(TApprovalRequest12),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph15,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry15)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey16, TConcurrencyPoolState15),
  baseLayer: TBaseLayerDescriptor8,
  crossRunSource: TCrossRunSource5,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus15),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus15),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus15),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus15),
  resultStatus: Enum(RunResultStatus15),
  waitingForLeaseAt: Optional(TDateString43),
  startedAt: Optional(TDateString43),
  cancellationRequestedAt: Optional(TDateString43),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString43)
});

// packages/schema/persisted/versioned/v53.ts
var ThisSchemaVersion16 = "v53" /* V53 */;
var TTaskOrGroupId44 = TBrandedString();
var TGraphNodeId17 = TBrandedString();
var TTemplateString17 = TBrandedString();
var TEvaluatedString17 = TBrandedString();
var TDateString44 = TBrandedString();
var TEpochSeconds17 = TBrandedNumber();
var TScopedTaskKey17 = TBrandedString();
var TaskType16 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType16 || {});
var TaskResultStatus16 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus16 || {});
var TaskExecutionStatus16 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus16 || {});
var TaskExecutionWaitingSubStatus16 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus16 || {});
var TaskExecutionAbortedSubStatus16 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus16 || {});
var TaskExecutionFinishedSubStatus16 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus16 || {});
var TaskAttemptReason16 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason16 || {});
var BackgroundProcessResultStatus43 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus43 || {});
var BackgroundProcessResultFinishedSubStatus43 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus43 || {});
var RunResultStatus16 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus16 || {});
var RunExecutionStatus16 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus16 || {});
var RunExecutionWaitingSubStatus16 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus16 || {});
var RunExecutionAbortedSubStatus16 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus16 || {});
var RunExecutionFinishedSubStatus16 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus16 || {});
var TSource16 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey41 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey41 || {});
var TExpandedEnvDescriptor16 = Object2({ value: Optional(TTemplateString17), cacheKey: Enum(EnvironmentVariableCacheKey41) });
var TEnvMergeStrategy16 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath43 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern43 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity43 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity43 || {});
var TProblemMatcher43 = Object2({ owner: String2(), severity: Optional(Enum(Severity43)), pattern: Array2(TProblemMatcherPattern43) });
var TProblemPath43 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath16 = Object2({ key: String2(), path: TTemplateString17 });
var TResolvedArtifactPath14 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck16 = Object2({ run: TTemplateString17, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess16 = Object2({
  key: String2(),
  command: TTemplateString17,
  readyCheck: Optional(TExpandedReadyCheck16),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType16 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType16 || {});
var TParallelismValue16 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification16 = Object2({
  cpus: Optional(TTemplateString17),
  memory: Optional(TTemplateString17),
  disk: Object2({ size: Optional(TTemplateString17) }),
  staticIps: Optional(TTemplateString17),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification16 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs16 = Object2({
  values: Optional(Record(String2(), TTemplateString17)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor7 = Object2({ path: TTemplateString17, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor7 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet7 = Union([TTemplateString17, Array2(Union([TTemplateString17, TFilterDescriptor7]))]);
var TInputFilesystemFilter16 = Object2({
  workspace: Optional(TFilterSet7),
  artifacts: Optional(Record(TTemplateString17, TFilterSet7))
});
var TOutputFilesystemFilter16 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration9 = Object2({
  enabled: TTemplateString17,
  ttl: Optional(TTemplateString17)
});
var TTaskDefinitionWithoutParallel16 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification16),
  type: Optional(Enum(TaskType16)),
  after: Optional(TTemplateString17),
  if: Optional(TTemplateString17),
  source: Optional(TSource16),
  cacheConfiguration: TCacheConfiguration9,
  docker: Optional(TTemplateString17),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString17),
  filter: Optional(TInputFilesystemFilter16),
  backgroundProcesses: Optional(Array2(TBackgroundProcess16)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor16)),
  envMerge: Optional(Array2(TEnvMergeStrategy16)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath43)),
  artifactPaths: Optional(Array2(TArtifactPath16)),
  outputs: Optional(TTaskDefinitionOutputs16),
  problemMatchers: Optional(Array2(TProblemMatcher43)),
  problemPaths: Optional(Array2(TProblemPath43)),
  parallelismType: Optional(Enum(ParallelismType16)),
  parallelismValue: Optional(TParallelismValue16),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString17)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString17),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter16)
});
var TCrossRunSource6 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents6 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource6,
  relativeScopedKey: String2()
});
var TTaskDefinition16 = Composite([
  TTaskDefinitionWithoutParallel16,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel16),
    parallelKey: Optional(TTemplateString17),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString17), TTemplateString17]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString17)), TTemplateString17])),
    parallelismTotal: Optional(TTemplateString17)
  })
]);
var TLayerWithManifest43 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId44,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext16 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret16 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess16 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString17,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString17,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult43 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus43),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus43),
  startedAt: Optional(TDateString44),
  completedAt: Optional(TDateString44),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem43 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity43),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults43 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest33 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact43 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest33, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact16 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor7)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor7))
      })
    )
  )
});
var TGithubStatusCheck2 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration16 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow16 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow16 || {});
var TConcurrencyPool16 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow16) });
var LeaseState16 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState16 || {});
var TTiming35 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps35 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming35)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming35)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming35),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming35),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming35.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming35),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming35),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming35),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming35),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming35),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming35),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming35),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming35)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming35.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic16 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction32 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact43)
});
var TBaseLayerSpecificationTriple9 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId9 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification9 = Union([TBaseLayerSpecificationTriple9, TBaseLayerSpecificationLayerId9]);
var TBaseLayerDescriptor9 = Composite([
  TBaseLayerSpecificationTriple9,
  TBaseLayerSpecificationLayerId9,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit9 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit9 || {});
var TTTL9 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit9)
});
var TResolvedCacheConfiguration8 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL9)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip20 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask16 = Object2({
  schemaVersion: Literal(ThisSchemaVersion16),
  taskId: TTaskOrGroupId44,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId17),
  generatorTaskId: Optional(TTaskOrGroupId44),
  definition: TTaskDefinition16,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus16),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus16),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus16),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus16),
  resultStatus: Enum(TaskResultStatus16),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason16)),
  resolvedAt: Optional(TDateString44),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString44),
  debugReadyAt: Optional(TDateString44),
  debugStartedAt: Optional(TDateString44),
  debugEndedAt: Optional(TDateString44),
  cancellationRequestedAt: Optional(TDateString44),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString44),
  cancelledAt: Optional(TDateString44),
  concurrencyPool: Optional(TConcurrencyPool16),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext16),
  usedSecrets: Optional(Array2(TUsedSecret16)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration8),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString17, cacheKey: Enum(EnvironmentVariableCacheKey41) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString17),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess16)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact16)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest43)),
  previousLayers: Optional(Array2(TLayerWithManifest43)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest43)),
  filesystemLayers: Optional(Array2(TLayerWithManifest43)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString17)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration16),
      baseLayer: TBaseLayerDescriptor9,
      crossRunSource: Optional(TCrossRunSource6)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification16),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath14)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult43)),
  whiteoutLayer: Optional(TLayerWithManifest43),
  outputLayers: Optional(Array2(TLayerWithManifest43)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey41) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem43)),
  testResults: Optional(Array2(TTestResults43)),
  artifacts: Optional(Array2(TArtifact43)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents6),
  tips: Array2(TTip20),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps35,
  networkTraffic: TNetworkTraffic16,
  outputRetryActions: Array2(TRetryAction32),
  retryAction: Optional(TRetryAction32),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest43)
});
var TRetryManifestEntry16 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry16 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString44,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString44),
  mostRecentlyAttemptedAt: Optional(TDateString44),
  finishedAt: Optional(TDateString44),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots16 = Object2({ resolution: Array2(TGraphNodeId17), runtime: Array2(TGraphNodeId17) });
var TRunGraph16 = Object2({
  roots: TGraphRoots16,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId17, Array2(TGraphNodeId17)),
    runtime: Record(TGraphNodeId17, Array2(TGraphNodeId17))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId17, Array2(TGraphNodeId17)),
    runtime: Record(TGraphNodeId17, Array2(TGraphNodeId17))
  }),
  subgraphs: Record(TGraphNodeId17, Object2({ roots: TGraphRoots16 })),
  parents: Record(TGraphNodeId17, TGraphNodeId17),
  definitionOrders: Record(TGraphNodeId17, Number2())
});
var TActor16 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState16 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState16)
});
var ApprovalRequestState13 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState13 || {});
var TApprovalRequest13 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState13)
});
var TRun16 = Object2({
  schemaVersion: Literal(ThisSchemaVersion16),
  persistenceExpiresAtSeconds: TEpochSeconds17,
  runId: String2(),
  createdAt: TDateString44,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor16),
  mintDirectoryArtifact: Optional(TArtifact43),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck2),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool16),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration16),
  eventNumber: Number2(),
  retries: Array2(TRetry16),
  approvalRequests: Array2(TApprovalRequest13),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph16,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry16)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey17, TConcurrencyPoolState16),
  baseLayer: TBaseLayerDescriptor9,
  crossRunSource: TCrossRunSource6,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus16),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus16),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus16),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus16),
  resultStatus: Enum(RunResultStatus16),
  waitingForLeaseAt: Optional(TDateString44),
  startedAt: Optional(TDateString44),
  cancellationRequestedAt: Optional(TDateString44),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString44),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v54.ts
var ThisSchemaVersion17 = "v54" /* V54 */;
var TTaskOrGroupId45 = TBrandedString();
var TGraphNodeId18 = TBrandedString();
var TTemplateString18 = TBrandedString();
var TEvaluatedString18 = TBrandedString();
var TDateString45 = TBrandedString();
var TEpochSeconds18 = TBrandedNumber();
var TScopedTaskKey18 = TBrandedString();
var TaskType17 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType17 || {});
var TaskResultStatus17 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus17 || {});
var TaskExecutionStatus17 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus17 || {});
var TaskExecutionWaitingSubStatus17 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus17 || {});
var TaskExecutionAbortedSubStatus17 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus17 || {});
var TaskExecutionFinishedSubStatus17 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus17 || {});
var TaskAttemptReason17 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason17 || {});
var BackgroundProcessResultStatus44 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus44 || {});
var BackgroundProcessResultFinishedSubStatus44 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus44 || {});
var RunResultStatus17 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus17 || {});
var RunExecutionStatus17 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus17 || {});
var RunExecutionWaitingSubStatus17 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus17 || {});
var RunExecutionAbortedSubStatus17 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus17 || {});
var RunExecutionFinishedSubStatus17 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus17 || {});
var TSource17 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey42 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey42 || {});
var TExpandedEnvDescriptor17 = Object2({ value: Optional(TTemplateString18), cacheKey: Enum(EnvironmentVariableCacheKey42) });
var TEnvMergeStrategy17 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath44 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern44 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity44 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity44 || {});
var TProblemMatcher44 = Object2({ owner: String2(), severity: Optional(Enum(Severity44)), pattern: Array2(TProblemMatcherPattern44) });
var TProblemPath44 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath17 = Object2({ key: String2(), path: TTemplateString18 });
var TResolvedArtifactPath15 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck17 = Object2({ run: TTemplateString18, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess17 = Object2({
  key: String2(),
  command: TTemplateString18,
  readyCheck: Optional(TExpandedReadyCheck17),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType17 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType17 || {});
var TParallelismValue17 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification17 = Object2({
  cpus: Optional(TTemplateString18),
  memory: Optional(TTemplateString18),
  disk: Object2({ size: Optional(TTemplateString18) }),
  staticIps: Optional(TTemplateString18),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification17 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs17 = Object2({
  values: Optional(Record(String2(), TTemplateString18)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor8 = Object2({ path: TTemplateString18, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor8 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet8 = Union([TTemplateString18, Array2(Union([TTemplateString18, TFilterDescriptor8]))]);
var TInputFilesystemFilter17 = Object2({
  workspace: Optional(TFilterSet8),
  artifacts: Optional(Record(TTemplateString18, TFilterSet8))
});
var TOutputFilesystemFilter17 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration10 = Object2({
  enabled: TTemplateString18,
  ttl: Optional(TTemplateString18)
});
var TTaskDefinitionWithoutParallel17 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification17),
  type: Optional(Enum(TaskType17)),
  after: Optional(TTemplateString18),
  if: Optional(TTemplateString18),
  source: Optional(TSource17),
  cacheConfiguration: TCacheConfiguration10,
  docker: Optional(TTemplateString18),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString18),
  filter: Optional(TInputFilesystemFilter17),
  backgroundProcesses: Optional(Array2(TBackgroundProcess17)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor17)),
  envMerge: Optional(Array2(TEnvMergeStrategy17)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath44)),
  artifactPaths: Optional(Array2(TArtifactPath17)),
  outputs: Optional(TTaskDefinitionOutputs17),
  problemMatchers: Optional(Array2(TProblemMatcher44)),
  problemPaths: Optional(Array2(TProblemPath44)),
  parallelismType: Optional(Enum(ParallelismType17)),
  parallelismValue: Optional(TParallelismValue17),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString18)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString18),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter17)
});
var TCrossRunSource7 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents7 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource7,
  relativeScopedKey: String2()
});
var TTaskDefinition17 = Composite([
  TTaskDefinitionWithoutParallel17,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel17),
    parallelKey: Optional(TTemplateString18),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString18), TTemplateString18]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString18)), TTemplateString18])),
    parallelismTotal: Optional(TTemplateString18)
  })
]);
var TLayerWithManifest44 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId45,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext17 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret17 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess17 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString18,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString18,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult44 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus44),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus44),
  startedAt: Optional(TDateString45),
  completedAt: Optional(TDateString45),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem44 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity44),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults44 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest34 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact44 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest34, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact17 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor8)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor8))
      })
    )
  )
});
var TGithubStatusCheck3 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration17 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow17 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow17 || {});
var TConcurrencyPool17 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow17) });
var LeaseState17 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState17 || {});
var TTiming36 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps36 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming36)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming36),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming36),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming36.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming36),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming36),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming36),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming36),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming36),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming36),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming36),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming36)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming36.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic17 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction33 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact44)
});
var TBaseLayerSpecificationTriple10 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId10 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification10 = Union([TBaseLayerSpecificationTriple10, TBaseLayerSpecificationLayerId10]);
var TBaseLayerDescriptor10 = Composite([
  TBaseLayerSpecificationTriple10,
  TBaseLayerSpecificationLayerId10,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit10 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit10 || {});
var TTTL10 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit10)
});
var TResolvedCacheConfiguration9 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL10)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip21 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask17 = Object2({
  schemaVersion: Literal(ThisSchemaVersion17),
  taskId: TTaskOrGroupId45,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId18),
  generatorTaskId: Optional(TTaskOrGroupId45),
  definition: TTaskDefinition17,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus17),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus17),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus17),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus17),
  resultStatus: Enum(TaskResultStatus17),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason17)),
  resolvedAt: Optional(TDateString45),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString45),
  debugReadyAt: Optional(TDateString45),
  debugStartedAt: Optional(TDateString45),
  debugEndedAt: Optional(TDateString45),
  cancellationRequestedAt: Optional(TDateString45),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString45),
  cancelledAt: Optional(TDateString45),
  concurrencyPool: Optional(TConcurrencyPool17),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext17),
  usedSecrets: Optional(Array2(TUsedSecret17)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration9),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString18, cacheKey: Enum(EnvironmentVariableCacheKey42) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString18),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess17)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact17)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest44)),
  previousLayers: Optional(Array2(TLayerWithManifest44)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest44)),
  filesystemLayers: Optional(Array2(TLayerWithManifest44)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString18)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration17),
      baseLayer: TBaseLayerDescriptor10,
      crossRunSource: Optional(TCrossRunSource7)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification17),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath15)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult44)),
  whiteoutLayer: Optional(TLayerWithManifest44),
  outputLayers: Optional(Array2(TLayerWithManifest44)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey42) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem44)),
  testResults: Optional(Array2(TTestResults44)),
  artifacts: Optional(Array2(TArtifact44)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents7),
  tips: Array2(TTip21),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps36,
  networkTraffic: TNetworkTraffic17,
  outputRetryActions: Array2(TRetryAction33),
  retryAction: Optional(TRetryAction33),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest44)
});
var TRetryManifestEntry17 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry17 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString45,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString45),
  mostRecentlyAttemptedAt: Optional(TDateString45),
  finishedAt: Optional(TDateString45),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots17 = Object2({ resolution: Array2(TGraphNodeId18), runtime: Array2(TGraphNodeId18) });
var TRunGraph17 = Object2({
  roots: TGraphRoots17,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId18, Array2(TGraphNodeId18)),
    runtime: Record(TGraphNodeId18, Array2(TGraphNodeId18))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId18, Array2(TGraphNodeId18)),
    runtime: Record(TGraphNodeId18, Array2(TGraphNodeId18))
  }),
  subgraphs: Record(TGraphNodeId18, Object2({ roots: TGraphRoots17 })),
  parents: Record(TGraphNodeId18, TGraphNodeId18),
  definitionOrders: Record(TGraphNodeId18, Number2())
});
var TActor17 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState17 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState17)
});
var ApprovalRequestState14 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState14 || {});
var TApprovalRequest14 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState14)
});
var TRun17 = Object2({
  schemaVersion: Literal(ThisSchemaVersion17),
  persistenceExpiresAtSeconds: TEpochSeconds18,
  runId: String2(),
  createdAt: TDateString45,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor17),
  mintDirectoryArtifact: Optional(TArtifact44),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck3),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool17),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration17),
  eventNumber: Number2(),
  retries: Array2(TRetry17),
  approvalRequests: Array2(TApprovalRequest14),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph17,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry17)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey18, TConcurrencyPoolState17),
  baseLayer: TBaseLayerDescriptor10,
  crossRunSource: TCrossRunSource7,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus17),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus17),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus17),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus17),
  resultStatus: Enum(RunResultStatus17),
  waitingForLeaseAt: Optional(TDateString45),
  startedAt: Optional(TDateString45),
  cancellationRequestedAt: Optional(TDateString45),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString45),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v55.ts
var ThisSchemaVersion18 = "v55" /* V55 */;
var TTaskOrGroupId46 = TBrandedString();
var TGraphNodeId19 = TBrandedString();
var TTemplateString19 = TBrandedString();
var TEvaluatedString19 = TBrandedString();
var TDateString46 = TBrandedString();
var TEpochSeconds19 = TBrandedNumber();
var TScopedTaskKey19 = TBrandedString();
var TaskType18 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType18 || {});
var TaskResultStatus18 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus18 || {});
var TaskExecutionStatus18 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus18 || {});
var TaskExecutionWaitingSubStatus18 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus18 || {});
var TaskExecutionAbortedSubStatus18 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus18 || {});
var TaskExecutionFinishedSubStatus18 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus18 || {});
var TaskAttemptReason18 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason18 || {});
var BackgroundProcessResultStatus45 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus45 || {});
var BackgroundProcessResultFinishedSubStatus45 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus45 || {});
var RunResultStatus18 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus18 || {});
var RunExecutionStatus18 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus18 || {});
var RunExecutionWaitingSubStatus18 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus18 || {});
var RunExecutionAbortedSubStatus18 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus18 || {});
var RunExecutionFinishedSubStatus18 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus18 || {});
var TSource18 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey43 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey43 || {});
var TExpandedEnvDescriptor18 = Object2({ value: Optional(TTemplateString19), cacheKey: Enum(EnvironmentVariableCacheKey43) });
var TEnvMergeStrategy18 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath45 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern45 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity45 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity45 || {});
var TProblemMatcher45 = Object2({ owner: String2(), severity: Optional(Enum(Severity45)), pattern: Array2(TProblemMatcherPattern45) });
var TProblemPath45 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath18 = Object2({ key: String2(), path: TTemplateString19 });
var TResolvedArtifactPath16 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck18 = Object2({ run: TTemplateString19, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess18 = Object2({
  key: String2(),
  command: TTemplateString19,
  readyCheck: Optional(TExpandedReadyCheck18),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType18 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType18 || {});
var TParallelismValue18 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification18 = Object2({
  cpus: Optional(TTemplateString19),
  memory: Optional(TTemplateString19),
  disk: Object2({ size: Optional(TTemplateString19) }),
  staticIps: Optional(TTemplateString19),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification18 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs18 = Object2({
  values: Optional(Record(String2(), TTemplateString19)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor9 = Object2({ path: TTemplateString19, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor9 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet9 = Union([TTemplateString19, Array2(Union([TTemplateString19, TFilterDescriptor9]))]);
var TInputFilesystemFilter18 = Object2({
  workspace: Optional(TFilterSet9),
  artifacts: Optional(Record(TTemplateString19, TFilterSet9))
});
var TOutputFilesystemFilter18 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration11 = Object2({
  enabled: TTemplateString19,
  ttl: Optional(TTemplateString19)
});
var TTaskDefinitionWithoutParallel18 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification18),
  type: Optional(Enum(TaskType18)),
  after: Optional(TTemplateString19),
  if: Optional(TTemplateString19),
  source: Optional(TSource18),
  cacheConfiguration: TCacheConfiguration11,
  docker: Optional(TTemplateString19),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString19),
  filter: Optional(TInputFilesystemFilter18),
  backgroundProcesses: Optional(Array2(TBackgroundProcess18)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor18)),
  envMerge: Optional(Array2(TEnvMergeStrategy18)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath45)),
  artifactPaths: Optional(Array2(TArtifactPath18)),
  outputs: Optional(TTaskDefinitionOutputs18),
  problemMatchers: Optional(Array2(TProblemMatcher45)),
  problemPaths: Optional(Array2(TProblemPath45)),
  parallelismType: Optional(Enum(ParallelismType18)),
  parallelismValue: Optional(TParallelismValue18),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString19)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString19),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter18)
});
var TCrossRunSource8 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents8 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource8,
  relativeScopedKey: String2()
});
var TTaskDefinition18 = Composite([
  TTaskDefinitionWithoutParallel18,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel18),
    parallelKey: Optional(TTemplateString19),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString19), TTemplateString19]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString19)), TTemplateString19])),
    parallelismTotal: Optional(TTemplateString19)
  })
]);
var TLayerWithManifest45 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId46,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext18 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret18 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess18 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString19,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString19,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult45 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus45),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus45),
  startedAt: Optional(TDateString46),
  completedAt: Optional(TDateString46),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem45 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity45),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults45 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest35 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact45 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest35, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact18 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor9)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor9))
      })
    )
  )
});
var TGithubStatusCheck4 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration18 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow18 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow18 || {});
var TConcurrencyPool18 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow18) });
var LeaseState18 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState18 || {});
var TTiming37 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps37 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming37)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming37),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming37),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming37.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming37),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming37),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming37),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming37),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming37),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming37),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming37),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming37)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming37.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic18 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction34 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact45)
});
var TBaseLayerSpecificationTriple11 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId11 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification11 = Union([TBaseLayerSpecificationTriple11, TBaseLayerSpecificationLayerId11]);
var TBaseLayerDescriptor11 = Composite([
  TBaseLayerSpecificationTriple11,
  TBaseLayerSpecificationLayerId11,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit11 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit11 || {});
var TTTL11 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit11)
});
var TResolvedCacheConfiguration10 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL11)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip22 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask18 = Object2({
  schemaVersion: Literal(ThisSchemaVersion18),
  taskId: TTaskOrGroupId46,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId19),
  generatorTaskId: Optional(TTaskOrGroupId46),
  definition: TTaskDefinition18,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus18),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus18),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus18),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus18),
  resultStatus: Enum(TaskResultStatus18),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason18)),
  resolvedAt: Optional(TDateString46),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString46),
  debugReadyAt: Optional(TDateString46),
  debugStartedAt: Optional(TDateString46),
  debugEndedAt: Optional(TDateString46),
  cancellationRequestedAt: Optional(TDateString46),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString46),
  cancelledAt: Optional(TDateString46),
  concurrencyPool: Optional(TConcurrencyPool18),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext18),
  usedSecrets: Optional(Array2(TUsedSecret18)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration10),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString19, cacheKey: Enum(EnvironmentVariableCacheKey43) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString19),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess18)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact18)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest45)),
  previousLayers: Optional(Array2(TLayerWithManifest45)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest45)),
  filesystemLayers: Optional(Array2(TLayerWithManifest45)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString19)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration18),
      baseLayer: TBaseLayerDescriptor11,
      crossRunSource: Optional(TCrossRunSource8)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification18),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath16)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult45)),
  whiteoutLayer: Optional(TLayerWithManifest45),
  outputLayers: Optional(Array2(TLayerWithManifest45)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey43) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem45)),
  testResults: Optional(Array2(TTestResults45)),
  artifacts: Optional(Array2(TArtifact45)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents8),
  tips: Array2(TTip22),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps37,
  networkTraffic: TNetworkTraffic18,
  outputRetryActions: Array2(TRetryAction34),
  retryAction: Optional(TRetryAction34),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest45)
});
var TRetryManifestEntry18 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry18 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString46,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString46),
  mostRecentlyAttemptedAt: Optional(TDateString46),
  finishedAt: Optional(TDateString46),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots18 = Object2({ resolution: Array2(TGraphNodeId19), runtime: Array2(TGraphNodeId19) });
var TRunGraph18 = Object2({
  roots: TGraphRoots18,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId19, Array2(TGraphNodeId19)),
    runtime: Record(TGraphNodeId19, Array2(TGraphNodeId19))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId19, Array2(TGraphNodeId19)),
    runtime: Record(TGraphNodeId19, Array2(TGraphNodeId19))
  }),
  subgraphs: Record(TGraphNodeId19, Object2({ roots: TGraphRoots18 })),
  parents: Record(TGraphNodeId19, TGraphNodeId19),
  definitionOrders: Record(TGraphNodeId19, Number2())
});
var TActor18 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState18 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState18)
});
var ApprovalRequestState15 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState15 || {});
var TApprovalRequest15 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState15)
});
var TRun18 = Object2({
  schemaVersion: Literal(ThisSchemaVersion18),
  persistenceExpiresAtSeconds: TEpochSeconds19,
  runId: String2(),
  createdAt: TDateString46,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor18),
  mintDirectoryArtifact: Optional(TArtifact45),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck4),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool18),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration18),
  eventNumber: Number2(),
  retries: Array2(TRetry18),
  approvalRequests: Array2(TApprovalRequest15),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph18,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry18)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey19, TConcurrencyPoolState18),
  baseLayer: TBaseLayerDescriptor11,
  crossRunSource: TCrossRunSource8,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus18),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus18),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus18),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus18),
  resultStatus: Enum(RunResultStatus18),
  waitingForLeaseAt: Optional(TDateString46),
  startedAt: Optional(TDateString46),
  cancellationRequestedAt: Optional(TDateString46),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString46),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v56.ts
var ThisSchemaVersion19 = "v56" /* V56 */;
var TTaskOrGroupId47 = TBrandedString();
var TGraphNodeId20 = TBrandedString();
var TTemplateString20 = TBrandedString();
var TEvaluatedString20 = TBrandedString();
var TDateString47 = TBrandedString();
var TEpochSeconds20 = TBrandedNumber();
var TScopedTaskKey20 = TBrandedString();
var TaskType19 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType19 || {});
var TaskResultStatus19 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus19 || {});
var TaskExecutionStatus19 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus19 || {});
var TaskExecutionWaitingSubStatus19 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus19 || {});
var TaskExecutionAbortedSubStatus19 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus19 || {});
var TaskExecutionFinishedSubStatus19 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus19 || {});
var TaskAttemptReason19 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason19 || {});
var BackgroundProcessResultStatus46 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus46 || {});
var BackgroundProcessResultFinishedSubStatus46 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus46 || {});
var RunResultStatus19 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus19 || {});
var RunExecutionStatus19 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus19 || {});
var RunExecutionWaitingSubStatus19 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus19 || {});
var RunExecutionAbortedSubStatus19 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus19 || {});
var RunExecutionFinishedSubStatus19 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus19 || {});
var TSource19 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey44 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey44 || {});
var TExpandedEnvDescriptor19 = Object2({ value: Optional(TTemplateString20), cacheKey: Enum(EnvironmentVariableCacheKey44) });
var TEnvMergeStrategy19 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath46 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern46 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity46 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity46 || {});
var TProblemMatcher46 = Object2({ owner: String2(), severity: Optional(Enum(Severity46)), pattern: Array2(TProblemMatcherPattern46) });
var TProblemPath46 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath19 = Object2({ key: String2(), path: TTemplateString20 });
var TResolvedArtifactPath17 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck19 = Object2({ run: TTemplateString20, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess19 = Object2({
  key: String2(),
  command: TTemplateString20,
  readyCheck: Optional(TExpandedReadyCheck19),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType19 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType19 || {});
var TParallelismValue19 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification19 = Object2({
  cpus: Optional(TTemplateString20),
  memory: Optional(TTemplateString20),
  disk: Object2({ size: Optional(TTemplateString20) }),
  staticIps: Optional(TTemplateString20),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification19 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs19 = Object2({
  values: Optional(Record(String2(), TTemplateString20)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor10 = Object2({ path: TTemplateString20, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor10 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet10 = Union([TTemplateString20, Array2(Union([TTemplateString20, TFilterDescriptor10]))]);
var TInputFilesystemFilter19 = Object2({
  workspace: Optional(TFilterSet10),
  artifacts: Optional(Record(TTemplateString20, TFilterSet10))
});
var TOutputFilesystemFilter19 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration12 = Object2({
  enabled: TTemplateString20,
  ttl: Optional(TTemplateString20)
});
var TTaskDefinitionWithoutParallel19 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification19),
  type: Optional(Enum(TaskType19)),
  after: Optional(TTemplateString20),
  if: Optional(TTemplateString20),
  source: Optional(TSource19),
  cacheConfiguration: TCacheConfiguration12,
  docker: Optional(TTemplateString20),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString20),
  filter: Optional(TInputFilesystemFilter19),
  backgroundProcesses: Optional(Array2(TBackgroundProcess19)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor19)),
  envMerge: Optional(Array2(TEnvMergeStrategy19)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath46)),
  artifactPaths: Optional(Array2(TArtifactPath19)),
  outputs: Optional(TTaskDefinitionOutputs19),
  problemMatchers: Optional(Array2(TProblemMatcher46)),
  problemPaths: Optional(Array2(TProblemPath46)),
  parallelismType: Optional(Enum(ParallelismType19)),
  parallelismValue: Optional(TParallelismValue19),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString20)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString20),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter19),
  automaticRetries: Optional(
    Union([
      TTemplateString20,
      Object2({
        count: TTemplateString20,
        action: Optional(TTemplateString20)
      })
    ])
  )
});
var TCrossRunSource9 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents9 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource9,
  relativeScopedKey: String2()
});
var TTaskDefinition19 = Composite([
  TTaskDefinitionWithoutParallel19,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel19),
    parallelKey: Optional(TTemplateString20),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString20), TTemplateString20]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString20)), TTemplateString20])),
    parallelismTotal: Optional(TTemplateString20)
  })
]);
var TLayerWithManifest46 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId47,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext19 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret19 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess19 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString20,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString20,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult46 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus46),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus46),
  startedAt: Optional(TDateString47),
  completedAt: Optional(TDateString47),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem46 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity46),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults46 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest36 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact46 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest36, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact19 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor10)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor10))
      })
    )
  )
});
var TGithubStatusCheck5 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration19 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow19 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow19 || {});
var TConcurrencyPool19 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow19) });
var LeaseState19 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState19 || {});
var TTiming38 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps38 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming38)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming38),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming38),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming38.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming38),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming38),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming38),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming38),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming38),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming38),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming38),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming38)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming38.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic19 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction35 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact46)
});
var TBaseLayerSpecificationTriple12 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId12 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification12 = Union([TBaseLayerSpecificationTriple12, TBaseLayerSpecificationLayerId12]);
var TBaseLayerDescriptor12 = Composite([
  TBaseLayerSpecificationTriple12,
  TBaseLayerSpecificationLayerId12,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit12 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit12 || {});
var TTTL12 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit12)
});
var TResolvedCacheConfiguration11 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL12)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip23 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask19 = Object2({
  schemaVersion: Literal(ThisSchemaVersion19),
  taskId: TTaskOrGroupId47,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId20),
  generatorTaskId: Optional(TTaskOrGroupId47),
  definition: TTaskDefinition19,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus19),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus19),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus19),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus19),
  resultStatus: Enum(TaskResultStatus19),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason19)),
  resolvedAt: Optional(TDateString47),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString47),
  debugReadyAt: Optional(TDateString47),
  debugStartedAt: Optional(TDateString47),
  debugEndedAt: Optional(TDateString47),
  cancellationRequestedAt: Optional(TDateString47),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString47),
  cancelledAt: Optional(TDateString47),
  concurrencyPool: Optional(TConcurrencyPool19),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext19),
  usedSecrets: Optional(Array2(TUsedSecret19)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration11),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString20, cacheKey: Enum(EnvironmentVariableCacheKey44) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString20),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess19)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact19)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest46)),
  previousLayers: Optional(Array2(TLayerWithManifest46)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest46)),
  filesystemLayers: Optional(Array2(TLayerWithManifest46)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString20)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration19),
      baseLayer: TBaseLayerDescriptor12,
      crossRunSource: Optional(TCrossRunSource9)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification19),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath17)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult46)),
  whiteoutLayer: Optional(TLayerWithManifest46),
  outputLayers: Optional(Array2(TLayerWithManifest46)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey44) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem46)),
  testResults: Optional(Array2(TTestResults46)),
  artifacts: Optional(Array2(TArtifact46)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents9),
  tips: Array2(TTip23),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps38,
  networkTraffic: TNetworkTraffic19,
  outputRetryActions: Array2(TRetryAction35),
  retryAction: Optional(TRetryAction35),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest46)
});
var TRetryManifestEntry19 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry19 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString47,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString47),
  mostRecentlyAttemptedAt: Optional(TDateString47),
  finishedAt: Optional(TDateString47),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots19 = Object2({ resolution: Array2(TGraphNodeId20), runtime: Array2(TGraphNodeId20) });
var TRunGraph19 = Object2({
  roots: TGraphRoots19,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId20, Array2(TGraphNodeId20)),
    runtime: Record(TGraphNodeId20, Array2(TGraphNodeId20))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId20, Array2(TGraphNodeId20)),
    runtime: Record(TGraphNodeId20, Array2(TGraphNodeId20))
  }),
  subgraphs: Record(TGraphNodeId20, Object2({ roots: TGraphRoots19 })),
  parents: Record(TGraphNodeId20, TGraphNodeId20),
  definitionOrders: Record(TGraphNodeId20, Number2())
});
var TActor19 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState19 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState19)
});
var ApprovalRequestState16 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState16 || {});
var TApprovalRequest16 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState16)
});
var TRun19 = Object2({
  schemaVersion: Literal(ThisSchemaVersion19),
  persistenceExpiresAtSeconds: TEpochSeconds20,
  runId: String2(),
  createdAt: TDateString47,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor19),
  mintDirectoryArtifact: Optional(TArtifact46),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck5),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool19),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration19),
  eventNumber: Number2(),
  retries: Array2(TRetry19),
  approvalRequests: Array2(TApprovalRequest16),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph19,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry19)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey20, TConcurrencyPoolState19),
  baseLayer: TBaseLayerDescriptor12,
  crossRunSource: TCrossRunSource9,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus19),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus19),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus19),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus19),
  resultStatus: Enum(RunResultStatus19),
  waitingForLeaseAt: Optional(TDateString47),
  startedAt: Optional(TDateString47),
  cancellationRequestedAt: Optional(TDateString47),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString47),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v57.ts
var ThisSchemaVersion20 = "v57" /* V57 */;
var TTaskOrGroupId48 = TBrandedString();
var TGraphNodeId21 = TBrandedString();
var TTemplateString21 = TBrandedString();
var TEvaluatedString21 = TBrandedString();
var TDateString48 = TBrandedString();
var TEpochSeconds21 = TBrandedNumber();
var TScopedTaskKey21 = TBrandedString();
var TaskType20 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType20 || {});
var TaskResultStatus20 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus20 || {});
var TaskExecutionStatus20 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus20 || {});
var TaskExecutionWaitingSubStatus20 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus20 || {});
var TaskExecutionAbortedSubStatus20 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus20 || {});
var TaskExecutionFinishedSubStatus20 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus20 || {});
var TaskAttemptReason20 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason20 || {});
var BackgroundProcessResultStatus47 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus47 || {});
var BackgroundProcessResultFinishedSubStatus47 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus47 || {});
var RunResultStatus20 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus20 || {});
var RunExecutionStatus20 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus20 || {});
var RunExecutionWaitingSubStatus20 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus20 || {});
var RunExecutionAbortedSubStatus20 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus20 || {});
var RunExecutionFinishedSubStatus20 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus20 || {});
var TSource20 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey45 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey45 || {});
var TExpandedEnvDescriptor20 = Object2({ value: Optional(TTemplateString21), cacheKey: Enum(EnvironmentVariableCacheKey45) });
var TEnvMergeStrategy20 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath47 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern47 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity47 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity47 || {});
var TProblemMatcher47 = Object2({ owner: String2(), severity: Optional(Enum(Severity47)), pattern: Array2(TProblemMatcherPattern47) });
var TProblemPath47 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath20 = Object2({ key: String2(), path: TTemplateString21 });
var TResolvedArtifactPath18 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck20 = Object2({ run: TTemplateString21, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess20 = Object2({
  key: String2(),
  command: TTemplateString21,
  readyCheck: Optional(TExpandedReadyCheck20),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType20 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType20 || {});
var TParallelismValue20 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification20 = Object2({
  cpus: Optional(TTemplateString21),
  memory: Optional(TTemplateString21),
  disk: Object2({ size: Optional(TTemplateString21) }),
  staticIps: Optional(TTemplateString21),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification20 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs20 = Object2({
  values: Optional(Record(String2(), TTemplateString21)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor11 = Object2({ path: TTemplateString21, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor11 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet11 = Union([TTemplateString21, Array2(Union([TTemplateString21, TFilterDescriptor11]))]);
var TInputFilesystemFilter20 = Object2({
  workspace: Optional(TFilterSet11),
  artifacts: Optional(Record(TTemplateString21, TFilterSet11))
});
var TOutputFilesystemFilter20 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration13 = Object2({
  enabled: TTemplateString21,
  ttl: Optional(TTemplateString21)
});
var TTaskDefinitionWithoutParallel20 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification20),
  type: Optional(Enum(TaskType20)),
  after: Optional(TTemplateString21),
  if: Optional(TTemplateString21),
  source: Optional(TSource20),
  cacheConfiguration: TCacheConfiguration13,
  docker: Optional(TTemplateString21),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString21),
  filter: Optional(TInputFilesystemFilter20),
  backgroundProcesses: Optional(Array2(TBackgroundProcess20)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor20)),
  envMerge: Optional(Array2(TEnvMergeStrategy20)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath47)),
  artifactPaths: Optional(Array2(TArtifactPath20)),
  outputs: Optional(TTaskDefinitionOutputs20),
  problemMatchers: Optional(Array2(TProblemMatcher47)),
  problemPaths: Optional(Array2(TProblemPath47)),
  parallelismType: Optional(Enum(ParallelismType20)),
  parallelismValue: Optional(TParallelismValue20),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString21)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString21),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter20),
  automaticRetries: Optional(
    Union([
      TTemplateString21,
      Object2({
        count: TTemplateString21,
        if: Optional(TTemplateString21),
        action: Optional(TTemplateString21)
      })
    ])
  )
});
var TCrossRunSource10 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents10 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource10,
  relativeScopedKey: String2()
});
var TTaskDefinition20 = Composite([
  TTaskDefinitionWithoutParallel20,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel20),
    parallelKey: Optional(TTemplateString21),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString21), TTemplateString21]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString21)), TTemplateString21])),
    parallelismTotal: Optional(TTemplateString21)
  })
]);
var TLayerWithManifest47 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId48,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext20 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret20 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess20 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString21,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString21,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult47 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus47),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus47),
  startedAt: Optional(TDateString48),
  completedAt: Optional(TDateString48),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem47 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity47),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary14 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults47 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary14),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest37 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact47 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest37, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact20 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor11)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor11))
      })
    )
  )
});
var TGithubStatusCheck6 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration20 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow20 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow20 || {});
var TConcurrencyPool20 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow20) });
var LeaseState20 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState20 || {});
var TTiming39 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps39 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming39)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming39),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming39),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming39.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming39),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming39),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming39),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming39),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming39),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming39),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming39),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming39)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming39.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic20 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction36 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact47)
});
var TBaseLayerSpecificationTriple13 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId13 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification13 = Union([TBaseLayerSpecificationTriple13, TBaseLayerSpecificationLayerId13]);
var TBaseLayerDescriptor13 = Composite([
  TBaseLayerSpecificationTriple13,
  TBaseLayerSpecificationLayerId13,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit13 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit13 || {});
var TTTL13 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit13)
});
var TResolvedCacheConfiguration12 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL13)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip24 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask20 = Object2({
  schemaVersion: Literal(ThisSchemaVersion20),
  taskId: TTaskOrGroupId48,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId21),
  generatorTaskId: Optional(TTaskOrGroupId48),
  definition: TTaskDefinition20,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus20),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus20),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus20),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus20),
  resultStatus: Enum(TaskResultStatus20),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason20)),
  resolvedAt: Optional(TDateString48),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString48),
  debugReadyAt: Optional(TDateString48),
  debugStartedAt: Optional(TDateString48),
  debugEndedAt: Optional(TDateString48),
  cancellationRequestedAt: Optional(TDateString48),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString48),
  cancelledAt: Optional(TDateString48),
  concurrencyPool: Optional(TConcurrencyPool20),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext20),
  usedSecrets: Optional(Array2(TUsedSecret20)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration12),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString21, cacheKey: Enum(EnvironmentVariableCacheKey45) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString21),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess20)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact20)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest47)),
  previousLayers: Optional(Array2(TLayerWithManifest47)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest47)),
  filesystemLayers: Optional(Array2(TLayerWithManifest47)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString21)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration20),
      baseLayer: TBaseLayerDescriptor13,
      crossRunSource: Optional(TCrossRunSource10)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification20),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath18)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult47)),
  whiteoutLayer: Optional(TLayerWithManifest47),
  outputLayers: Optional(Array2(TLayerWithManifest47)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey45) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem47)),
  testResults: Optional(Array2(TTestResults47)),
  artifacts: Optional(Array2(TArtifact47)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents10),
  tips: Array2(TTip24),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps39,
  networkTraffic: TNetworkTraffic20,
  outputRetryActions: Array2(TRetryAction36),
  retryAction: Optional(TRetryAction36),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest47)
});
var TRetryManifestEntry20 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry20 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString48,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString48),
  mostRecentlyAttemptedAt: Optional(TDateString48),
  finishedAt: Optional(TDateString48),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots20 = Object2({ resolution: Array2(TGraphNodeId21), runtime: Array2(TGraphNodeId21) });
var TRunGraph20 = Object2({
  roots: TGraphRoots20,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId21, Array2(TGraphNodeId21)),
    runtime: Record(TGraphNodeId21, Array2(TGraphNodeId21))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId21, Array2(TGraphNodeId21)),
    runtime: Record(TGraphNodeId21, Array2(TGraphNodeId21))
  }),
  subgraphs: Record(TGraphNodeId21, Object2({ roots: TGraphRoots20 })),
  parents: Record(TGraphNodeId21, TGraphNodeId21),
  definitionOrders: Record(TGraphNodeId21, Number2())
});
var TActor20 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState20 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState20)
});
var ApprovalRequestState17 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState17 || {});
var TApprovalRequest17 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState17)
});
var TRun20 = Object2({
  schemaVersion: Literal(ThisSchemaVersion20),
  persistenceExpiresAtSeconds: TEpochSeconds21,
  runId: String2(),
  createdAt: TDateString48,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor20),
  mintDirectoryArtifact: Optional(TArtifact47),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck6),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool20),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration20),
  eventNumber: Number2(),
  retries: Array2(TRetry20),
  approvalRequests: Array2(TApprovalRequest17),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph20,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry20)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey21, TConcurrencyPoolState20),
  baseLayer: TBaseLayerDescriptor13,
  crossRunSource: TCrossRunSource10,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus20),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus20),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus20),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus20),
  resultStatus: Enum(RunResultStatus20),
  waitingForLeaseAt: Optional(TDateString48),
  startedAt: Optional(TDateString48),
  cancellationRequestedAt: Optional(TDateString48),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString48),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v58.ts
var ThisSchemaVersion21 = "v58" /* V58 */;
var TTaskOrGroupId49 = TBrandedString();
var TGraphNodeId22 = TBrandedString();
var TTemplateString22 = TBrandedString();
var TEvaluatedString22 = TBrandedString();
var TDateString49 = TBrandedString();
var TEpochSeconds22 = TBrandedNumber();
var TScopedTaskKey22 = TBrandedString();
var TaskType21 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType21 || {});
var TaskResultStatus21 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus21 || {});
var TaskExecutionStatus21 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus21 || {});
var TaskExecutionWaitingSubStatus21 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus21 || {});
var TaskExecutionAbortedSubStatus21 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus21 || {});
var TaskExecutionFinishedSubStatus21 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus21 || {});
var TaskAttemptReason21 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason21 || {});
var BackgroundProcessResultStatus48 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus48 || {});
var BackgroundProcessResultFinishedSubStatus48 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus48 || {});
var RunResultStatus21 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus21 || {});
var RunExecutionStatus21 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus21 || {});
var RunExecutionWaitingSubStatus21 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus21 || {});
var RunExecutionAbortedSubStatus21 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus21 || {});
var RunExecutionFinishedSubStatus21 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus21 || {});
var TSource21 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey46 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey46 || {});
var TExpandedEnvDescriptor21 = Object2({ value: Optional(TTemplateString22), cacheKey: Enum(EnvironmentVariableCacheKey46) });
var TEnvMergeStrategy21 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath48 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern48 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity48 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity48 || {});
var TProblemMatcher48 = Object2({ owner: String2(), severity: Optional(Enum(Severity48)), pattern: Array2(TProblemMatcherPattern48) });
var TProblemPath48 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath21 = Object2({ key: String2(), path: TTemplateString22 });
var TResolvedArtifactPath19 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck21 = Object2({ run: TTemplateString22, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess21 = Object2({
  key: String2(),
  command: TTemplateString22,
  readyCheck: Optional(TExpandedReadyCheck21),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType21 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType21 || {});
var TParallelismValue21 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification21 = Object2({
  cpus: Optional(TTemplateString22),
  memory: Optional(TTemplateString22),
  disk: Object2({ size: Optional(TTemplateString22) }),
  staticIps: Optional(TTemplateString22),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification21 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs21 = Object2({
  values: Optional(Record(String2(), TTemplateString22)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor12 = Object2({ path: TTemplateString22, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor12 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet12 = Union([TTemplateString22, Array2(Union([TTemplateString22, TFilterDescriptor12]))]);
var TInputFilesystemFilter21 = Object2({
  workspace: Optional(TFilterSet12),
  artifacts: Optional(Record(TTemplateString22, TFilterSet12))
});
var TOutputFilesystemFilter21 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration14 = Object2({
  enabled: TTemplateString22,
  ttl: Optional(TTemplateString22)
});
var TTaskDefinitionWithoutParallel21 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification21),
  type: Optional(Enum(TaskType21)),
  after: Optional(TTemplateString22),
  if: Optional(TTemplateString22),
  source: Optional(TSource21),
  cacheConfiguration: TCacheConfiguration14,
  docker: Optional(TTemplateString22),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString22),
  filter: Optional(TInputFilesystemFilter21),
  backgroundProcesses: Optional(Array2(TBackgroundProcess21)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor21)),
  envMerge: Optional(Array2(TEnvMergeStrategy21)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath48)),
  artifactPaths: Optional(Array2(TArtifactPath21)),
  outputs: Optional(TTaskDefinitionOutputs21),
  problemMatchers: Optional(Array2(TProblemMatcher48)),
  problemPaths: Optional(Array2(TProblemPath48)),
  parallelismType: Optional(Enum(ParallelismType21)),
  parallelismValue: Optional(TParallelismValue21),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString22)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString22),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter21),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString22,
      if: Optional(TTemplateString22),
      action: Optional(TTemplateString22)
    })
  )
});
var TCrossRunSource11 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents11 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource11,
  relativeScopedKey: String2()
});
var TTaskDefinition21 = Composite([
  TTaskDefinitionWithoutParallel21,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel21),
    parallelKey: Optional(TTemplateString22),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString22), TTemplateString22]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString22)), TTemplateString22])),
    parallelismTotal: Optional(TTemplateString22)
  })
]);
var TLayerWithManifest48 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId49,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext21 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret21 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess21 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString22,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString22,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult48 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus48),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus48),
  startedAt: Optional(TDateString49),
  completedAt: Optional(TDateString49),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem48 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity48),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary15 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults48 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary15),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest38 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact48 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest38, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact21 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor12)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor12))
      })
    )
  )
});
var TGithubStatusCheck7 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration21 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow21 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow21 || {});
var TConcurrencyPool21 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow21) });
var LeaseState21 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState21 || {});
var TTiming40 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps40 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming40)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming40),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming40),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming40.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming40),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming40),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming40),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming40),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming40),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming40),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming40),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming40)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming40.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic21 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction37 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact48)
});
var TBaseLayerSpecificationTriple14 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId14 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification14 = Union([TBaseLayerSpecificationTriple14, TBaseLayerSpecificationLayerId14]);
var TBaseLayerDescriptor14 = Composite([
  TBaseLayerSpecificationTriple14,
  TBaseLayerSpecificationLayerId14,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit14 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit14 || {});
var TTTL14 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit14)
});
var TResolvedCacheConfiguration13 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL14)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip25 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask21 = Object2({
  schemaVersion: Literal(ThisSchemaVersion21),
  taskId: TTaskOrGroupId49,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId22),
  generatorTaskId: Optional(TTaskOrGroupId49),
  definition: TTaskDefinition21,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus21),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus21),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus21),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus21),
  resultStatus: Enum(TaskResultStatus21),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason21)),
  resolvedAt: Optional(TDateString49),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString49),
  debugReadyAt: Optional(TDateString49),
  debugStartedAt: Optional(TDateString49),
  debugEndedAt: Optional(TDateString49),
  cancellationRequestedAt: Optional(TDateString49),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString49),
  cancelledAt: Optional(TDateString49),
  concurrencyPool: Optional(TConcurrencyPool21),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext21),
  usedSecrets: Optional(Array2(TUsedSecret21)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration13),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString22, cacheKey: Enum(EnvironmentVariableCacheKey46) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString22),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess21)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact21)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest48)),
  previousLayers: Optional(Array2(TLayerWithManifest48)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest48)),
  filesystemLayers: Optional(Array2(TLayerWithManifest48)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString22)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration21),
      baseLayer: TBaseLayerDescriptor14,
      crossRunSource: Optional(TCrossRunSource11)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification21),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath19)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult48)),
  whiteoutLayer: Optional(TLayerWithManifest48),
  outputLayers: Optional(Array2(TLayerWithManifest48)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey46) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem48)),
  testResults: Optional(Array2(TTestResults48)),
  artifacts: Optional(Array2(TArtifact48)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents11),
  tips: Array2(TTip25),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps40,
  networkTraffic: TNetworkTraffic21,
  outputRetryActions: Array2(TRetryAction37),
  retryAction: Optional(TRetryAction37),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest48)
});
var TRetryManifestEntry21 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry21 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString49,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString49),
  mostRecentlyAttemptedAt: Optional(TDateString49),
  finishedAt: Optional(TDateString49),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots21 = Object2({ resolution: Array2(TGraphNodeId22), runtime: Array2(TGraphNodeId22) });
var TRunGraph21 = Object2({
  roots: TGraphRoots21,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId22, Array2(TGraphNodeId22)),
    runtime: Record(TGraphNodeId22, Array2(TGraphNodeId22))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId22, Array2(TGraphNodeId22)),
    runtime: Record(TGraphNodeId22, Array2(TGraphNodeId22))
  }),
  subgraphs: Record(TGraphNodeId22, Object2({ roots: TGraphRoots21 })),
  parents: Record(TGraphNodeId22, TGraphNodeId22),
  definitionOrders: Record(TGraphNodeId22, Number2())
});
var TActor21 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState21 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState21)
});
var ApprovalRequestState18 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState18 || {});
var TApprovalRequest18 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState18)
});
var TRun21 = Object2({
  schemaVersion: Literal(ThisSchemaVersion21),
  persistenceExpiresAtSeconds: TEpochSeconds22,
  runId: String2(),
  createdAt: TDateString49,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor21),
  mintDirectoryArtifact: Optional(TArtifact48),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck7),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool21),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration21),
  eventNumber: Number2(),
  retries: Array2(TRetry21),
  approvalRequests: Array2(TApprovalRequest18),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph21,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry21)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey22, TConcurrencyPoolState21),
  baseLayer: TBaseLayerDescriptor14,
  crossRunSource: TCrossRunSource11,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus21),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus21),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus21),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus21),
  resultStatus: Enum(RunResultStatus21),
  waitingForLeaseAt: Optional(TDateString49),
  startedAt: Optional(TDateString49),
  cancellationRequestedAt: Optional(TDateString49),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString49),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v59.ts
var ThisSchemaVersion22 = "v59" /* V59 */;
var TTaskOrGroupId50 = TBrandedString();
var TGraphNodeId23 = TBrandedString();
var TTemplateString23 = TBrandedString();
var TEvaluatedString23 = TBrandedString();
var TDateString50 = TBrandedString();
var TEpochSeconds23 = TBrandedNumber();
var TScopedTaskKey23 = TBrandedString();
var TaskType22 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType22 || {});
var TaskResultStatus22 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus22 || {});
var TaskExecutionStatus22 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus22 || {});
var TaskExecutionWaitingSubStatus22 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus22 || {});
var TaskExecutionAbortedSubStatus22 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus22 || {});
var TaskExecutionFinishedSubStatus22 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus22 || {});
var TaskAttemptReason22 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason22 || {});
var BackgroundProcessResultStatus49 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus49 || {});
var BackgroundProcessResultFinishedSubStatus49 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus49 || {});
var RunResultStatus22 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus22 || {});
var RunExecutionStatus22 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus22 || {});
var RunExecutionWaitingSubStatus22 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus22 || {});
var RunExecutionAbortedSubStatus22 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus22 || {});
var RunExecutionFinishedSubStatus22 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus22 || {});
var TSource22 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey47 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey47 || {});
var TExpandedEnvDescriptor22 = Object2({ value: Optional(TTemplateString23), cacheKey: Enum(EnvironmentVariableCacheKey47) });
var TEnvMergeStrategy22 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath49 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern49 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity49 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity49 || {});
var TProblemMatcher49 = Object2({ owner: String2(), severity: Optional(Enum(Severity49)), pattern: Array2(TProblemMatcherPattern49) });
var TProblemPath49 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath22 = Object2({ key: String2(), path: TTemplateString23 });
var TResolvedArtifactPath20 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck22 = Object2({ run: TTemplateString23, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess22 = Object2({
  key: String2(),
  command: TTemplateString23,
  readyCheck: Optional(TExpandedReadyCheck22),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType22 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType22 || {});
var TParallelismValue22 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification22 = Object2({
  cpus: Optional(TTemplateString23),
  memory: Optional(TTemplateString23),
  disk: Object2({ size: Optional(TTemplateString23) }),
  staticIps: Optional(TTemplateString23),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification22 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TTaskDefinitionOutputs22 = Object2({
  values: Optional(Record(String2(), TTemplateString23)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor13 = Object2({ path: TTemplateString23, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor13 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet13 = Union([TTemplateString23, Array2(Union([TTemplateString23, TFilterDescriptor13]))]);
var TInputFilesystemFilter22 = Object2({
  workspace: Optional(TFilterSet13),
  artifacts: Optional(Record(TTemplateString23, TFilterSet13))
});
var TOutputFilesystemFilter22 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration15 = Object2({
  enabled: TTemplateString23,
  ttl: Optional(TTemplateString23)
});
var TTaskDefinitionWithoutParallel22 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification22),
  type: Optional(Enum(TaskType22)),
  after: Optional(TTemplateString23),
  if: Optional(TTemplateString23),
  source: Optional(TSource22),
  cacheConfiguration: TCacheConfiguration15,
  docker: Optional(TTemplateString23),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString23),
  filter: Optional(TInputFilesystemFilter22),
  backgroundProcesses: Optional(Array2(TBackgroundProcess22)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor22)),
  envMerge: Optional(Array2(TEnvMergeStrategy22)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath49)),
  artifactPaths: Optional(Array2(TArtifactPath22)),
  outputs: Optional(TTaskDefinitionOutputs22),
  problemMatchers: Optional(Array2(TProblemMatcher49)),
  problemPaths: Optional(Array2(TProblemPath49)),
  parallelismType: Optional(Enum(ParallelismType22)),
  parallelismValue: Optional(TParallelismValue22),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString23)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString23),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter22),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString23,
      if: Optional(TTemplateString23),
      action: Optional(TTemplateString23)
    })
  )
});
var TCrossRunSource12 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents12 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource12,
  relativeScopedKey: String2()
});
var TTaskDefinition22 = Composite([
  TTaskDefinitionWithoutParallel22,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel22),
    parallelKey: Optional(TTemplateString23),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString23), TTemplateString23]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString23)), TTemplateString23])),
    parallelismTotal: Optional(TTemplateString23)
  })
]);
var TLayerWithManifest49 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId50,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext22 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret22 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess22 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString23,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString23,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult49 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus49),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus49),
  startedAt: Optional(TDateString50),
  completedAt: Optional(TDateString50),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem49 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity49),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary16 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2()
});
var TTestResults49 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary16),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest39 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact49 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest39, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact22 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor13)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor13))
      })
    )
  )
});
var TGithubStatusCheck8 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration22 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow22 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow22 || {});
var TConcurrencyPool22 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow22) });
var LeaseState22 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState22 || {});
var TTiming41 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps41 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming41)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming41),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming41),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming41.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming41),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming41),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming41),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming41),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming41),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming41),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming41),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming41)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming41.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic22 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction38 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact49)
});
var TBaseLayerSpecificationTriple15 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId15 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification15 = Union([TBaseLayerSpecificationTriple15, TBaseLayerSpecificationLayerId15]);
var TBaseLayerDescriptor15 = Composite([
  TBaseLayerSpecificationTriple15,
  TBaseLayerSpecificationLayerId15,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit15 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit15 || {});
var TTTL15 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit15)
});
var TResolvedCacheConfiguration14 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL15)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip26 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask22 = Object2({
  schemaVersion: Literal(ThisSchemaVersion22),
  taskId: TTaskOrGroupId50,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId23),
  generatorTaskId: Optional(TTaskOrGroupId50),
  definition: TTaskDefinition22,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus22),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus22),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus22),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus22),
  resultStatus: Enum(TaskResultStatus22),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason22)),
  resolvedAt: Optional(TDateString50),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString50),
  debugReadyAt: Optional(TDateString50),
  debugStartedAt: Optional(TDateString50),
  debugEndedAt: Optional(TDateString50),
  cancellationRequestedAt: Optional(TDateString50),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString50),
  cancelledAt: Optional(TDateString50),
  concurrencyPool: Optional(TConcurrencyPool22),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext22),
  usedSecrets: Optional(Array2(TUsedSecret22)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration14),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString23, cacheKey: Enum(EnvironmentVariableCacheKey47) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString23),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess22)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact22)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest49)),
  previousLayers: Optional(Array2(TLayerWithManifest49)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest49)),
  filesystemLayers: Optional(Array2(TLayerWithManifest49)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString23)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration22),
      baseLayer: TBaseLayerDescriptor15,
      crossRunSource: Optional(TCrossRunSource12)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification22),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath20)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult49)),
  whiteoutLayer: Optional(TLayerWithManifest49),
  outputLayers: Optional(Array2(TLayerWithManifest49)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey47) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem49)),
  testResults: Optional(Array2(TTestResults49)),
  artifacts: Optional(Array2(TArtifact49)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents12),
  tips: Array2(TTip26),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps41,
  networkTraffic: TNetworkTraffic22,
  outputRetryActions: Array2(TRetryAction38),
  retryAction: Optional(TRetryAction38),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest49)
});
var TRetryManifestEntry22 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry22 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString50,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString50),
  mostRecentlyAttemptedAt: Optional(TDateString50),
  finishedAt: Optional(TDateString50),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots22 = Object2({ resolution: Array2(TGraphNodeId23), runtime: Array2(TGraphNodeId23) });
var TRunGraph22 = Object2({
  roots: TGraphRoots22,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId23, Array2(TGraphNodeId23)),
    runtime: Record(TGraphNodeId23, Array2(TGraphNodeId23))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId23, Array2(TGraphNodeId23)),
    runtime: Record(TGraphNodeId23, Array2(TGraphNodeId23))
  }),
  subgraphs: Record(TGraphNodeId23, Object2({ roots: TGraphRoots22 })),
  parents: Record(TGraphNodeId23, TGraphNodeId23),
  definitionOrders: Record(TGraphNodeId23, Number2())
});
var TActor22 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState22 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState22)
});
var ApprovalRequestState19 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState19 || {});
var TApprovalRequest19 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState19)
});
var TRun22 = Object2({
  schemaVersion: Literal(ThisSchemaVersion22),
  persistenceExpiresAtSeconds: TEpochSeconds23,
  runId: String2(),
  createdAt: TDateString50,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor22),
  mintDirectoryArtifact: Optional(TArtifact49),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck8),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool22),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration22),
  eventNumber: Number2(),
  retries: Array2(TRetry22),
  approvalRequests: Array2(TApprovalRequest19),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph22,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry22)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey23, TConcurrencyPoolState22),
  baseLayer: TBaseLayerDescriptor15,
  crossRunSource: TCrossRunSource12,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus22),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus22),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus22),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus22),
  resultStatus: Enum(RunResultStatus22),
  waitingForLeaseAt: Optional(TDateString50),
  waitingForManualStartAt: Optional(TDateString50),
  startedAt: Optional(TDateString50),
  cancellationRequestedAt: Optional(TDateString50),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString50),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v60.ts
var ThisSchemaVersion23 = "v60" /* V60 */;
var TTaskOrGroupId51 = TBrandedString();
var TGraphNodeId24 = TBrandedString();
var TTemplateString24 = TBrandedString();
var TEvaluatedString24 = TBrandedString();
var TDateString51 = TBrandedString();
var TEpochSeconds24 = TBrandedNumber();
var TScopedTaskKey24 = TBrandedString();
var TaskType23 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType23 || {});
var TaskResultStatus23 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus23 || {});
var TaskExecutionStatus23 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus23 || {});
var TaskExecutionWaitingSubStatus23 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus23 || {});
var TaskExecutionAbortedSubStatus23 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus23 || {});
var TaskExecutionFinishedSubStatus23 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus23 || {});
var TaskAttemptReason23 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason23 || {});
var BackgroundProcessResultStatus50 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus50 || {});
var BackgroundProcessResultFinishedSubStatus50 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus50 || {});
var RunResultStatus23 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus23 || {});
var RunExecutionStatus23 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus23 || {});
var RunExecutionWaitingSubStatus23 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus23 || {});
var RunExecutionAbortedSubStatus23 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus23 || {});
var RunExecutionFinishedSubStatus23 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus23 || {});
var TSource23 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey48 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey48 || {});
var TExpandedEnvDescriptor23 = Object2({ value: Optional(TTemplateString24), cacheKey: Enum(EnvironmentVariableCacheKey48) });
var TEnvMergeStrategy23 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath50 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern50 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity50 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity50 || {});
var TProblemMatcher50 = Object2({ owner: String2(), severity: Optional(Enum(Severity50)), pattern: Array2(TProblemMatcherPattern50) });
var TProblemPath50 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath23 = Object2({ key: String2(), path: TTemplateString24 });
var TResolvedArtifactPath21 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck23 = Object2({ run: TTemplateString24, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess23 = Object2({
  key: String2(),
  command: TTemplateString24,
  readyCheck: Optional(TExpandedReadyCheck23),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType23 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType23 || {});
var TParallelismValue23 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification23 = Object2({
  cpus: Optional(TTemplateString24),
  memory: Optional(TTemplateString24),
  disk: Object2({ size: Optional(TTemplateString24) }),
  staticIps: Optional(TTemplateString24),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification23 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TTaskDefinitionOutputs23 = Object2({
  values: Optional(Record(String2(), TTemplateString24)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor14 = Object2({ path: TTemplateString24, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor14 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet14 = Union([TTemplateString24, Array2(Union([TTemplateString24, TFilterDescriptor14]))]);
var TInputFilesystemFilter23 = Object2({
  workspace: Optional(TFilterSet14),
  artifacts: Optional(Record(TTemplateString24, TFilterSet14))
});
var TOutputFilesystemFilter23 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration16 = Object2({
  enabled: TTemplateString24,
  ttl: Optional(TTemplateString24)
});
var TTaskDefinitionWithoutParallel23 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification23),
  type: Optional(Enum(TaskType23)),
  after: Optional(TTemplateString24),
  if: Optional(TTemplateString24),
  source: Optional(TSource23),
  cacheConfiguration: TCacheConfiguration16,
  docker: Optional(TTemplateString24),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString24),
  filter: Optional(TInputFilesystemFilter23),
  backgroundProcesses: Optional(Array2(TBackgroundProcess23)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor23)),
  envMerge: Optional(Array2(TEnvMergeStrategy23)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath50)),
  artifactPaths: Optional(Array2(TArtifactPath23)),
  outputs: Optional(TTaskDefinitionOutputs23),
  problemMatchers: Optional(Array2(TProblemMatcher50)),
  problemPaths: Optional(Array2(TProblemPath50)),
  parallelismType: Optional(Enum(ParallelismType23)),
  parallelismValue: Optional(TParallelismValue23),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString24)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString24),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter23),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString24,
      if: Optional(TTemplateString24),
      action: Optional(TTemplateString24)
    })
  )
});
var TCrossRunSource13 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents13 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource13,
  relativeScopedKey: String2()
});
var TTaskDefinition23 = Composite([
  TTaskDefinitionWithoutParallel23,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel23),
    parallelKey: Optional(TTemplateString24),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString24), TTemplateString24]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString24)), TTemplateString24])),
    parallelismTotal: Optional(TTemplateString24)
  })
]);
var TLayerWithManifest50 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId51,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext23 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret23 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess23 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString24,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString24,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult50 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus50),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus50),
  startedAt: Optional(TDateString51),
  completedAt: Optional(TDateString51),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem50 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity50),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary17 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults50 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary17),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest40 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact50 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest40, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact23 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor14)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor14))
      })
    )
  )
});
var TGithubStatusCheck9 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration23 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow23 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow23 || {});
var TConcurrencyPool23 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow23) });
var LeaseState23 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState23 || {});
var TTiming42 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps42 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming42)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming42),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming42),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming42.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming42),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming42),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming42),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming42),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming42),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming42),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming42),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming42)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming42.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic23 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction39 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact50)
});
var TBaseLayerSpecificationTriple16 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId16 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification16 = Union([TBaseLayerSpecificationTriple16, TBaseLayerSpecificationLayerId16]);
var TBaseLayerDescriptor16 = Composite([
  TBaseLayerSpecificationTriple16,
  TBaseLayerSpecificationLayerId16,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit16 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit16 || {});
var TTTL16 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit16)
});
var TResolvedCacheConfiguration15 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL16)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip27 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask23 = Object2({
  schemaVersion: Literal(ThisSchemaVersion23),
  taskId: TTaskOrGroupId51,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId24),
  generatorTaskId: Optional(TTaskOrGroupId51),
  definition: TTaskDefinition23,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus23),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus23),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus23),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus23),
  resultStatus: Enum(TaskResultStatus23),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason23)),
  resolvedAt: Optional(TDateString51),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString51),
  debugReadyAt: Optional(TDateString51),
  debugStartedAt: Optional(TDateString51),
  debugEndedAt: Optional(TDateString51),
  cancellationRequestedAt: Optional(TDateString51),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString51),
  cancelledAt: Optional(TDateString51),
  concurrencyPool: Optional(TConcurrencyPool23),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext23),
  usedSecrets: Optional(Array2(TUsedSecret23)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration15),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString24, cacheKey: Enum(EnvironmentVariableCacheKey48) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString24),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess23)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact23)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest50)),
  previousLayers: Optional(Array2(TLayerWithManifest50)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest50)),
  filesystemLayers: Optional(Array2(TLayerWithManifest50)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString24)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration23),
      baseLayer: TBaseLayerDescriptor16,
      crossRunSource: Optional(TCrossRunSource13)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification23),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath21)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult50)),
  whiteoutLayer: Optional(TLayerWithManifest50),
  outputLayers: Optional(Array2(TLayerWithManifest50)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey48) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem50)),
  testResults: Optional(Array2(TTestResults50)),
  artifacts: Optional(Array2(TArtifact50)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents13),
  tips: Array2(TTip27),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps42,
  networkTraffic: TNetworkTraffic23,
  outputRetryActions: Array2(TRetryAction39),
  retryAction: Optional(TRetryAction39),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest50)
});
var TRetryManifestEntry23 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry23 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString51,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString51),
  mostRecentlyAttemptedAt: Optional(TDateString51),
  finishedAt: Optional(TDateString51),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots23 = Object2({ resolution: Array2(TGraphNodeId24), runtime: Array2(TGraphNodeId24) });
var TRunGraph23 = Object2({
  roots: TGraphRoots23,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId24, Array2(TGraphNodeId24)),
    runtime: Record(TGraphNodeId24, Array2(TGraphNodeId24))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId24, Array2(TGraphNodeId24)),
    runtime: Record(TGraphNodeId24, Array2(TGraphNodeId24))
  }),
  subgraphs: Record(TGraphNodeId24, Object2({ roots: TGraphRoots23 })),
  parents: Record(TGraphNodeId24, TGraphNodeId24),
  definitionOrders: Record(TGraphNodeId24, Number2())
});
var TActor23 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState23 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState23)
});
var ApprovalRequestState20 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState20 || {});
var TApprovalRequest20 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState20)
});
var TRun23 = Object2({
  schemaVersion: Literal(ThisSchemaVersion23),
  persistenceExpiresAtSeconds: TEpochSeconds24,
  runId: String2(),
  createdAt: TDateString51,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor23),
  mintDirectoryArtifact: Optional(TArtifact50),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck9),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool23),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration23),
  eventNumber: Number2(),
  retries: Array2(TRetry23),
  approvalRequests: Array2(TApprovalRequest20),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph23,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry23)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey24, TConcurrencyPoolState23),
  baseLayer: TBaseLayerDescriptor16,
  crossRunSource: TCrossRunSource13,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus23),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus23),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus23),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus23),
  resultStatus: Enum(RunResultStatus23),
  waitingForLeaseAt: Optional(TDateString51),
  waitingForManualStartAt: Optional(TDateString51),
  startedAt: Optional(TDateString51),
  cancellationRequestedAt: Optional(TDateString51),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString51),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v61.ts
var ThisSchemaVersion24 = "v61" /* V61 */;
var TTaskOrGroupId52 = TBrandedString();
var TGraphNodeId25 = TBrandedString();
var TTemplateString25 = TBrandedString();
var TEvaluatedString25 = TBrandedString();
var TDateString52 = TBrandedString();
var TEpochSeconds25 = TBrandedNumber();
var TScopedTaskKey25 = TBrandedString();
var TaskType24 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType24 || {});
var TaskResultStatus24 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus24 || {});
var TaskExecutionStatus24 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus24 || {});
var TaskExecutionWaitingSubStatus24 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus24 || {});
var TaskExecutionAbortedSubStatus24 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus24 || {});
var TaskExecutionFinishedSubStatus24 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus24 || {});
var TaskAttemptReason24 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason24 || {});
var BackgroundProcessResultStatus51 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus51 || {});
var BackgroundProcessResultFinishedSubStatus51 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus51 || {});
var RunResultStatus24 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus24 || {});
var RunExecutionStatus24 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus24 || {});
var RunExecutionWaitingSubStatus24 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus24 || {});
var RunExecutionAbortedSubStatus24 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus24 || {});
var RunExecutionFinishedSubStatus24 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus24 || {});
var TSource24 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey49 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey49 || {});
var TExpandedEnvDescriptor24 = Object2({ value: Optional(TTemplateString25), cacheKey: Enum(EnvironmentVariableCacheKey49) });
var TEnvMergeStrategy24 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath51 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern51 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity51 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity51 || {});
var TProblemMatcher51 = Object2({ owner: String2(), severity: Optional(Enum(Severity51)), pattern: Array2(TProblemMatcherPattern51) });
var TProblemPath51 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath24 = Object2({ key: String2(), path: TTemplateString25 });
var TResolvedArtifactPath22 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck24 = Object2({ run: TTemplateString25, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess24 = Object2({
  key: String2(),
  command: TTemplateString25,
  readyCheck: Optional(TExpandedReadyCheck24),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType24 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType24 || {});
var TParallelismValue24 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification24 = Object2({
  cpus: Optional(TTemplateString25),
  memory: Optional(TTemplateString25),
  disk: Object2({ size: Optional(TTemplateString25) }),
  staticIps: Optional(TTemplateString25),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification24 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TTaskDefinitionOutputs24 = Object2({
  values: Optional(Record(String2(), TTemplateString25)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor15 = Object2({ path: TTemplateString25, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor15 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet15 = Union([TTemplateString25, Array2(Union([TTemplateString25, TFilterDescriptor15]))]);
var TInputFilesystemFilter24 = Object2({
  workspace: Optional(TFilterSet15),
  artifacts: Optional(Record(TTemplateString25, TFilterSet15))
});
var TOutputFilesystemFilter24 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration17 = Object2({
  enabled: TTemplateString25,
  ttl: Optional(TTemplateString25)
});
var TTaskDefinitionWithoutParallel24 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification24),
  type: Optional(Enum(TaskType24)),
  after: Optional(TTemplateString25),
  if: Optional(TTemplateString25),
  source: Optional(TSource24),
  cacheConfiguration: TCacheConfiguration17,
  docker: Optional(TTemplateString25),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString25),
  filter: Optional(TInputFilesystemFilter24),
  backgroundProcesses: Optional(Array2(TBackgroundProcess24)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor24)),
  envMerge: Optional(Array2(TEnvMergeStrategy24)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath51)),
  artifactPaths: Optional(Array2(TArtifactPath24)),
  outputs: Optional(TTaskDefinitionOutputs24),
  problemMatchers: Optional(Array2(TProblemMatcher51)),
  problemPaths: Optional(Array2(TProblemPath51)),
  parallelismType: Optional(Enum(ParallelismType24)),
  parallelismValue: Optional(TParallelismValue24),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString25)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString25),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter24),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString25,
      if: Optional(TTemplateString25),
      action: Optional(TTemplateString25)
    })
  )
});
var TCrossRunSource14 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents14 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource14,
  relativeScopedKey: String2()
});
var TTaskDefinition24 = Composite([
  TTaskDefinitionWithoutParallel24,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel24),
    parallelKey: Optional(TTemplateString25),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString25), TTemplateString25]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString25)), TTemplateString25])),
    parallelismTotal: Optional(TTemplateString25)
  })
]);
var TLayerWithManifest51 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId52,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext24 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret24 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess24 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString25,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString25,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult51 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus51),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus51),
  startedAt: Optional(TDateString52),
  completedAt: Optional(TDateString52),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem51 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity51),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary18 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults51 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary18),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest41 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact51 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest41, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact24 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor15)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor15))
      })
    )
  )
});
var TGithubStatusCheck10 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration24 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow24 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow24 || {});
var TConcurrencyPool24 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow24) });
var LeaseState24 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState24 || {});
var TTiming43 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps43 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming43)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming43),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming43),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming43.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming43),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming43),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming43),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming43),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming43),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming43),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming43),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming43)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming43.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic24 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction40 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact51)
});
var TBaseLayerSpecificationTriple17 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId17 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification17 = Union([TBaseLayerSpecificationTriple17, TBaseLayerSpecificationLayerId17]);
var TBaseLayerDescriptor17 = Composite([
  TBaseLayerSpecificationTriple17,
  TBaseLayerSpecificationLayerId17,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit17 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit17 || {});
var TTTL17 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit17)
});
var TResolvedWriteCacheConfiguration2 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL17, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration2 = Object2({
  enabled: Boolean2()
});
var TTip28 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask24 = Object2({
  schemaVersion: Literal(ThisSchemaVersion24),
  taskId: TTaskOrGroupId52,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId25),
  generatorTaskId: Optional(TTaskOrGroupId52),
  definition: TTaskDefinition24,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus24),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus24),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus24),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus24),
  resultStatus: Enum(TaskResultStatus24),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason24)),
  resolvedAt: Optional(TDateString52),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString52),
  debugReadyAt: Optional(TDateString52),
  debugStartedAt: Optional(TDateString52),
  debugEndedAt: Optional(TDateString52),
  cancellationRequestedAt: Optional(TDateString52),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString52),
  cancelledAt: Optional(TDateString52),
  concurrencyPool: Optional(TConcurrencyPool24),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext24),
  usedSecrets: Optional(Array2(TUsedSecret24)),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration2),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration2),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString25, cacheKey: Enum(EnvironmentVariableCacheKey49) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString25),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess24)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact24)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest51)),
  previousLayers: Optional(Array2(TLayerWithManifest51)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest51)),
  filesystemLayers: Optional(Array2(TLayerWithManifest51)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString25)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration24),
      baseLayer: TBaseLayerDescriptor17,
      crossRunSource: Optional(TCrossRunSource14)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification24),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath22)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult51)),
  whiteoutLayer: Optional(TLayerWithManifest51),
  outputLayers: Optional(Array2(TLayerWithManifest51)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey49) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem51)),
  testResults: Optional(Array2(TTestResults51)),
  artifacts: Optional(Array2(TArtifact51)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents14),
  tips: Array2(TTip28),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps43,
  networkTraffic: TNetworkTraffic24,
  outputRetryActions: Array2(TRetryAction40),
  retryAction: Optional(TRetryAction40),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest51)
});
var TRetryManifestEntry24 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry24 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString52,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString52),
  mostRecentlyAttemptedAt: Optional(TDateString52),
  finishedAt: Optional(TDateString52),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots24 = Object2({ resolution: Array2(TGraphNodeId25), runtime: Array2(TGraphNodeId25) });
var TRunGraph24 = Object2({
  roots: TGraphRoots24,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId25, Array2(TGraphNodeId25)),
    runtime: Record(TGraphNodeId25, Array2(TGraphNodeId25))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId25, Array2(TGraphNodeId25)),
    runtime: Record(TGraphNodeId25, Array2(TGraphNodeId25))
  }),
  subgraphs: Record(TGraphNodeId25, Object2({ roots: TGraphRoots24 })),
  parents: Record(TGraphNodeId25, TGraphNodeId25),
  definitionOrders: Record(TGraphNodeId25, Number2())
});
var TActor24 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState24 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState24)
});
var ApprovalRequestState21 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState21 || {});
var TApprovalRequest21 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState21)
});
var TRun24 = Object2({
  schemaVersion: Literal(ThisSchemaVersion24),
  persistenceExpiresAtSeconds: TEpochSeconds25,
  runId: String2(),
  createdAt: TDateString52,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor24),
  mintDirectoryArtifact: Optional(TArtifact51),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck10),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool24),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration24),
  eventNumber: Number2(),
  retries: Array2(TRetry24),
  approvalRequests: Array2(TApprovalRequest21),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph24,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry24)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey25, TConcurrencyPoolState24),
  baseLayer: TBaseLayerDescriptor17,
  crossRunSource: TCrossRunSource14,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus24),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus24),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus24),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus24),
  resultStatus: Enum(RunResultStatus24),
  waitingForLeaseAt: Optional(TDateString52),
  waitingForManualStartAt: Optional(TDateString52),
  startedAt: Optional(TDateString52),
  cancellationRequestedAt: Optional(TDateString52),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString52),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v62.ts
var ThisSchemaVersion25 = "v62" /* V62 */;
var TTaskOrGroupId53 = TBrandedString();
var TGraphNodeId26 = TBrandedString();
var TTemplateString26 = TBrandedString();
var TEvaluatedString26 = TBrandedString();
var TDateString53 = TBrandedString();
var TEpochSeconds26 = TBrandedNumber();
var TScopedTaskKey26 = TBrandedString();
var TaskType25 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType25 || {});
var TaskResultStatus25 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus25 || {});
var TaskExecutionStatus25 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus25 || {});
var TaskExecutionWaitingSubStatus25 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus25 || {});
var TaskExecutionAbortedSubStatus25 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus25 || {});
var TaskExecutionFinishedSubStatus25 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus25 || {});
var TaskAttemptReason25 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason25 || {});
var BackgroundProcessResultStatus52 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus52 || {});
var BackgroundProcessResultFinishedSubStatus52 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus52 || {});
var RunResultStatus25 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus25 || {});
var RunExecutionStatus25 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus25 || {});
var RunExecutionWaitingSubStatus25 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus25 || {});
var RunExecutionAbortedSubStatus25 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus25 || {});
var RunExecutionFinishedSubStatus25 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus25 || {});
var TSource25 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey50 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey50 || {});
var TExpandedEnvDescriptor25 = Object2({ value: Optional(TTemplateString26), cacheKey: Enum(EnvironmentVariableCacheKey50) });
var TEnvMergeStrategy25 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath52 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern52 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity52 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity52 || {});
var TProblemMatcher52 = Object2({ owner: String2(), severity: Optional(Enum(Severity52)), pattern: Array2(TProblemMatcherPattern52) });
var TProblemPath52 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath25 = Object2({ key: String2(), path: TTemplateString26 });
var TResolvedArtifactPath23 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck25 = Object2({ run: TTemplateString26, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess25 = Object2({
  key: String2(),
  command: TTemplateString26,
  readyCheck: Optional(TExpandedReadyCheck25),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType25 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType25 || {});
var TParallelismValue25 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification25 = Object2({
  cpus: Optional(TTemplateString26),
  memory: Optional(TTemplateString26),
  disk: Object2({ size: Optional(TTemplateString26) }),
  staticIps: Optional(TTemplateString26),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification25 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs25 = Object2({
  values: Optional(Record(String2(), TTemplateString26)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor16 = Object2({ path: TTemplateString26, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor16 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet16 = Union([TTemplateString26, Array2(Union([TTemplateString26, TFilterDescriptor16]))]);
var TInputFilesystemFilter25 = Object2({
  workspace: Optional(TFilterSet16),
  artifacts: Optional(Record(TTemplateString26, TFilterSet16))
});
var TOutputFilesystemFilter25 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration18 = Object2({
  enabled: TTemplateString26,
  ttl: Optional(TTemplateString26)
});
var TTaskDefinitionWithoutParallel25 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification25),
  type: Optional(Enum(TaskType25)),
  after: Optional(TTemplateString26),
  if: Optional(TTemplateString26),
  source: Optional(TSource25),
  cacheConfiguration: TCacheConfiguration18,
  docker: Optional(TTemplateString26),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString26),
  filter: Optional(TInputFilesystemFilter25),
  backgroundProcesses: Optional(Array2(TBackgroundProcess25)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor25)),
  envMerge: Optional(Array2(TEnvMergeStrategy25)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath52)),
  artifactPaths: Optional(Array2(TArtifactPath25)),
  outputs: Optional(TTaskDefinitionOutputs25),
  problemMatchers: Optional(Array2(TProblemMatcher52)),
  problemPaths: Optional(Array2(TProblemPath52)),
  parallelismType: Optional(Enum(ParallelismType25)),
  parallelismValue: Optional(TParallelismValue25),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString26)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString26),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter25),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString26,
      if: Optional(TTemplateString26),
      action: Optional(TTemplateString26)
    })
  )
});
var TCrossRunSource15 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents15 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource15,
  relativeScopedKey: String2()
});
var TTaskDefinition25 = Composite([
  TTaskDefinitionWithoutParallel25,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel25),
    parallelKey: Optional(TTemplateString26),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString26), TTemplateString26]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString26)), TTemplateString26])),
    parallelismTotal: Optional(TTemplateString26)
  })
]);
var TLayerWithManifest52 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId53,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext25 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret25 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess25 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString26,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString26,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult52 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus52),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus52),
  startedAt: Optional(TDateString53),
  completedAt: Optional(TDateString53),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem52 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity52),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary19 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults52 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary19),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest42 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact52 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest42, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact25 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor16)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor16))
      })
    )
  )
});
var TGithubStatusCheck11 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration25 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow25 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow25 || {});
var TConcurrencyPool25 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow25) });
var LeaseState25 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState25 || {});
var TTiming44 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps44 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming44)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming44),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming44),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming44.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming44),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming44),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming44),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming44),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming44),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming44),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming44),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming44)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming44.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic25 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction41 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact52)
});
var TBaseLayerSpecificationTriple18 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId18 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification18 = Union([TBaseLayerSpecificationTriple18, TBaseLayerSpecificationLayerId18]);
var TBaseLayerDescriptor18 = Composite([
  TBaseLayerSpecificationTriple18,
  TBaseLayerSpecificationLayerId18,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit18 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit18 || {});
var TTTL18 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit18)
});
var TResolvedWriteCacheConfiguration3 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL18, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration3 = Object2({
  enabled: Boolean2()
});
var TTip29 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask25 = Object2({
  schemaVersion: Literal(ThisSchemaVersion25),
  taskId: TTaskOrGroupId53,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId26),
  generatorTaskId: Optional(TTaskOrGroupId53),
  definition: TTaskDefinition25,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus25),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus25),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus25),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus25),
  resultStatus: Enum(TaskResultStatus25),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason25)),
  resolvedAt: Optional(TDateString53),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString53),
  debugReadyAt: Optional(TDateString53),
  debugStartedAt: Optional(TDateString53),
  debugEndedAt: Optional(TDateString53),
  cancellationRequestedAt: Optional(TDateString53),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString53),
  cancelledAt: Optional(TDateString53),
  concurrencyPool: Optional(TConcurrencyPool25),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext25),
  usedSecrets: Optional(Array2(TUsedSecret25)),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration3),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration3),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString26, cacheKey: Enum(EnvironmentVariableCacheKey50) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString26),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess25)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact25)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest52)),
  previousLayers: Optional(Array2(TLayerWithManifest52)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest52)),
  filesystemLayers: Optional(Array2(TLayerWithManifest52)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString26)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration25),
      baseLayer: TBaseLayerDescriptor18,
      crossRunSource: Optional(TCrossRunSource15)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification25),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath23)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult52)),
  whiteoutLayer: Optional(TLayerWithManifest52),
  outputLayers: Optional(Array2(TLayerWithManifest52)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey50) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem52)),
  testResults: Optional(Array2(TTestResults52)),
  artifacts: Optional(Array2(TArtifact52)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents15),
  tips: Array2(TTip29),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps44,
  networkTraffic: TNetworkTraffic25,
  outputRetryActions: Array2(TRetryAction41),
  retryAction: Optional(TRetryAction41),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest52)
});
var TRetryManifestEntry25 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry25 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString53,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString53),
  mostRecentlyAttemptedAt: Optional(TDateString53),
  finishedAt: Optional(TDateString53),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots25 = Object2({ resolution: Array2(TGraphNodeId26), runtime: Array2(TGraphNodeId26) });
var TRunGraph25 = Object2({
  roots: TGraphRoots25,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId26, Array2(TGraphNodeId26)),
    runtime: Record(TGraphNodeId26, Array2(TGraphNodeId26))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId26, Array2(TGraphNodeId26)),
    runtime: Record(TGraphNodeId26, Array2(TGraphNodeId26))
  }),
  subgraphs: Record(TGraphNodeId26, Object2({ roots: TGraphRoots25 })),
  parents: Record(TGraphNodeId26, TGraphNodeId26),
  definitionOrders: Record(TGraphNodeId26, Number2())
});
var TActor25 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState25 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState25)
});
var ApprovalRequestState22 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState22 || {});
var TApprovalRequest22 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState22)
});
var TRun25 = Object2({
  schemaVersion: Literal(ThisSchemaVersion25),
  persistenceExpiresAtSeconds: TEpochSeconds26,
  runId: String2(),
  createdAt: TDateString53,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor25),
  mintDirectoryArtifact: Optional(TArtifact52),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck11),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool25),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration25),
  eventNumber: Number2(),
  retries: Array2(TRetry25),
  approvalRequests: Array2(TApprovalRequest22),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph25,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry25)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey26, TConcurrencyPoolState25),
  baseLayer: TBaseLayerDescriptor18,
  crossRunSource: TCrossRunSource15,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus25),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus25),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus25),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus25),
  resultStatus: Enum(RunResultStatus25),
  waitingForLeaseAt: Optional(TDateString53),
  waitingForManualStartAt: Optional(TDateString53),
  startedAt: Optional(TDateString53),
  cancellationRequestedAt: Optional(TDateString53),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString53),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v63.ts
var ThisSchemaVersion26 = "v63" /* V63 */;
var TTaskOrGroupId54 = TBrandedString();
var TGraphNodeId27 = TBrandedString();
var TTemplateString27 = TBrandedString();
var TEvaluatedString27 = TBrandedString();
var TDateString54 = TBrandedString();
var TEpochSeconds27 = TBrandedNumber();
var TScopedTaskKey27 = TBrandedString();
var TaskType26 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType26 || {});
var TaskResultStatus26 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus26 || {});
var TaskExecutionStatus26 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus26 || {});
var TaskExecutionWaitingSubStatus26 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus26 || {});
var TaskExecutionAbortedSubStatus26 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus26 || {});
var TaskExecutionFinishedSubStatus26 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus26 || {});
var TaskAttemptReason26 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason26 || {});
var BackgroundProcessResultStatus53 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus53 || {});
var BackgroundProcessResultFinishedSubStatus53 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus53 || {});
var RunResultStatus26 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus26 || {});
var RunExecutionStatus26 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus26 || {});
var RunExecutionWaitingSubStatus26 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus26 || {});
var RunExecutionAbortedSubStatus26 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus26 || {});
var RunExecutionFinishedSubStatus26 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus26 || {});
var TSource26 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey51 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey51 || {});
var TExpandedEnvDescriptor26 = Object2({ value: Optional(TTemplateString27), cacheKey: Enum(EnvironmentVariableCacheKey51) });
var TEnvMergeStrategy26 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath53 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern53 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity53 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity53 || {});
var TProblemMatcher53 = Object2({ owner: String2(), severity: Optional(Enum(Severity53)), pattern: Array2(TProblemMatcherPattern53) });
var TProblemPath53 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath26 = Object2({ key: String2(), path: TTemplateString27 });
var TResolvedArtifactPath24 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck26 = Object2({ run: TTemplateString27, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess26 = Object2({
  key: String2(),
  command: TTemplateString27,
  readyCheck: Optional(TExpandedReadyCheck26),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType26 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType26 || {});
var TParallelismValue26 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification26 = Object2({
  cpus: Optional(TTemplateString27),
  memory: Optional(TTemplateString27),
  disk: Object2({ size: Optional(TTemplateString27) }),
  staticIps: Optional(TTemplateString27),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification26 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs26 = Object2({
  values: Optional(Record(String2(), TTemplateString27)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor17 = Object2({ path: TTemplateString27, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor17 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet17 = Union([TTemplateString27, Array2(Union([TTemplateString27, TFilterDescriptor17]))]);
var TInputFilesystemFilter26 = Object2({
  workspace: Optional(TFilterSet17),
  artifacts: Optional(Record(TTemplateString27, TFilterSet17))
});
var TOutputFilesystemFilter26 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration19 = Object2({
  enabled: TTemplateString27,
  ttl: Optional(TTemplateString27)
});
var TTaskDefinitionWithoutParallel26 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification26),
  type: Optional(Enum(TaskType26)),
  after: Optional(TTemplateString27),
  if: Optional(TTemplateString27),
  source: Optional(TSource26),
  cacheConfiguration: TCacheConfiguration19,
  docker: Optional(TTemplateString27),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString27),
  filter: Optional(TInputFilesystemFilter26),
  backgroundProcesses: Optional(Array2(TBackgroundProcess26)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor26)),
  envMerge: Optional(Array2(TEnvMergeStrategy26)),
  timeout: Optional(TTemplateString27),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath53)),
  artifactPaths: Optional(Array2(TArtifactPath26)),
  outputs: Optional(TTaskDefinitionOutputs26),
  problemMatchers: Optional(Array2(TProblemMatcher53)),
  problemPaths: Optional(Array2(TProblemPath53)),
  parallelismType: Optional(Enum(ParallelismType26)),
  parallelismValue: Optional(TParallelismValue26),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString27)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString27),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter26),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString27,
      if: Optional(TTemplateString27),
      action: Optional(TTemplateString27)
    })
  )
});
var TCrossRunSource16 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents16 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource16,
  relativeScopedKey: String2()
});
var TTaskDefinition26 = Composite([
  TTaskDefinitionWithoutParallel26,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel26),
    parallelKey: Optional(TTemplateString27),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString27), TTemplateString27]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString27)), TTemplateString27])),
    parallelismTotal: Optional(TTemplateString27)
  })
]);
var TLayerWithManifest53 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId54,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext26 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret26 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess26 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString27,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString27,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult53 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus53),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus53),
  startedAt: Optional(TDateString54),
  completedAt: Optional(TDateString54),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem53 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity53),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary20 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults53 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary20),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest43 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact53 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest43, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact26 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor17)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor17))
      })
    )
  )
});
var TGithubStatusCheck12 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration26 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow26 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow26 || {});
var TConcurrencyPool26 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow26) });
var LeaseState26 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState26 || {});
var TTiming45 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps45 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming45)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming45),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming45),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming45.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming45),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming45),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming45),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming45),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming45),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming45),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming45),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming45)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming45.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic26 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction42 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact53)
});
var TBaseLayerSpecificationTriple19 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId19 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification19 = Union([TBaseLayerSpecificationTriple19, TBaseLayerSpecificationLayerId19]);
var TBaseLayerDescriptor19 = Composite([
  TBaseLayerSpecificationTriple19,
  TBaseLayerSpecificationLayerId19,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit19 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit19 || {});
var TTTL19 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit19)
});
var TResolvedWriteCacheConfiguration4 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL19, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration4 = Object2({
  enabled: Boolean2()
});
var TTip30 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask26 = Object2({
  schemaVersion: Literal(ThisSchemaVersion26),
  taskId: TTaskOrGroupId54,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId27),
  generatorTaskId: Optional(TTaskOrGroupId54),
  definition: TTaskDefinition26,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus26),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus26),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus26),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus26),
  resultStatus: Enum(TaskResultStatus26),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason26)),
  resolvedAt: Optional(TDateString54),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString54),
  debugReadyAt: Optional(TDateString54),
  debugStartedAt: Optional(TDateString54),
  debugEndedAt: Optional(TDateString54),
  cancellationRequestedAt: Optional(TDateString54),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString54),
  cancelledAt: Optional(TDateString54),
  concurrencyPool: Optional(TConcurrencyPool26),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext26),
  usedSecrets: Optional(Array2(TUsedSecret26)),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration4),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration4),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString27, cacheKey: Enum(EnvironmentVariableCacheKey51) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString27),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess26)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact26)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest53)),
  previousLayers: Optional(Array2(TLayerWithManifest53)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest53)),
  filesystemLayers: Optional(Array2(TLayerWithManifest53)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString27)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration26),
      baseLayer: TBaseLayerDescriptor19,
      crossRunSource: Optional(TCrossRunSource16)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification26),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath24)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult53)),
  whiteoutLayer: Optional(TLayerWithManifest53),
  outputLayers: Optional(Array2(TLayerWithManifest53)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey51) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem53)),
  testResults: Optional(Array2(TTestResults53)),
  artifacts: Optional(Array2(TArtifact53)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents16),
  tips: Array2(TTip30),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps45,
  networkTraffic: TNetworkTraffic26,
  outputRetryActions: Array2(TRetryAction42),
  retryAction: Optional(TRetryAction42),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest53),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2())
});
var TRetryManifestEntry26 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry26 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString54,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString54),
  mostRecentlyAttemptedAt: Optional(TDateString54),
  finishedAt: Optional(TDateString54),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots26 = Object2({ resolution: Array2(TGraphNodeId27), runtime: Array2(TGraphNodeId27) });
var TRunGraph26 = Object2({
  roots: TGraphRoots26,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId27, Array2(TGraphNodeId27)),
    runtime: Record(TGraphNodeId27, Array2(TGraphNodeId27))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId27, Array2(TGraphNodeId27)),
    runtime: Record(TGraphNodeId27, Array2(TGraphNodeId27))
  }),
  subgraphs: Record(TGraphNodeId27, Object2({ roots: TGraphRoots26 })),
  parents: Record(TGraphNodeId27, TGraphNodeId27),
  definitionOrders: Record(TGraphNodeId27, Number2())
});
var TActor26 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState26 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState26)
});
var ApprovalRequestState23 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState23 || {});
var TApprovalRequest23 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState23)
});
var TRun26 = Object2({
  schemaVersion: Literal(ThisSchemaVersion26),
  persistenceExpiresAtSeconds: TEpochSeconds27,
  runId: String2(),
  createdAt: TDateString54,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor26),
  mintDirectoryArtifact: Optional(TArtifact53),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck12),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool26),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration26),
  eventNumber: Number2(),
  retries: Array2(TRetry26),
  approvalRequests: Array2(TApprovalRequest23),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph26,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry26)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey27, TConcurrencyPoolState26),
  baseLayer: TBaseLayerDescriptor19,
  crossRunSource: TCrossRunSource16,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus26),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus26),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus26),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus26),
  resultStatus: Enum(RunResultStatus26),
  waitingForLeaseAt: Optional(TDateString54),
  waitingForManualStartAt: Optional(TDateString54),
  startedAt: Optional(TDateString54),
  cancellationRequestedAt: Optional(TDateString54),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString54),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v64.ts
var ThisSchemaVersion27 = "v64" /* V64 */;
var TTaskOrGroupId55 = TBrandedString();
var TGraphNodeId28 = TBrandedString();
var TTemplateString28 = TBrandedString();
var TEvaluatedString28 = TBrandedString();
var TDateString55 = TBrandedString();
var TEpochSeconds28 = TBrandedNumber();
var TScopedTaskKey28 = TBrandedString();
var TaskType27 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType27 || {});
var TaskResultStatus27 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus27 || {});
var TaskExecutionStatus27 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus27 || {});
var TaskExecutionWaitingSubStatus27 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus27 || {});
var TaskExecutionAbortedSubStatus27 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus27 || {});
var TaskExecutionFinishedSubStatus27 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus27 || {});
var TaskAttemptReason27 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason27 || {});
var BackgroundProcessResultStatus54 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus54 || {});
var BackgroundProcessResultFinishedSubStatus54 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus54 || {});
var RunResultStatus27 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus27 || {});
var RunExecutionStatus27 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus27 || {});
var RunExecutionWaitingSubStatus27 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus27 || {});
var RunExecutionAbortedSubStatus27 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus27 || {});
var RunExecutionFinishedSubStatus27 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus27 || {});
var TSource27 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey52 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey52 || {});
var TExpandedEnvDescriptor27 = Object2({ value: Optional(TTemplateString28), cacheKey: Enum(EnvironmentVariableCacheKey52) });
var TEnvMergeStrategy27 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath54 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern54 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity54 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity54 || {});
var TProblemMatcher54 = Object2({ owner: String2(), severity: Optional(Enum(Severity54)), pattern: Array2(TProblemMatcherPattern54) });
var TProblemPath54 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath27 = Object2({ key: String2(), path: TTemplateString28 });
var TResolvedArtifactPath25 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck27 = Object2({ run: TTemplateString28, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess27 = Object2({
  key: String2(),
  command: TTemplateString28,
  readyCheck: Optional(TExpandedReadyCheck27),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType27 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType27 || {});
var TParallelismValue27 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification27 = Object2({
  cpus: Optional(TTemplateString28),
  memory: Optional(TTemplateString28),
  disk: Object2({ size: Optional(TTemplateString28) }),
  staticIps: Optional(TTemplateString28),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification27 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs27 = Object2({
  values: Optional(Record(String2(), TTemplateString28)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor18 = Object2({ path: TTemplateString28, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor18 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet18 = Union([TTemplateString28, Array2(Union([TTemplateString28, TFilterDescriptor18]))]);
var TInputFilesystemFilter27 = Object2({
  workspace: Optional(TFilterSet18),
  artifacts: Optional(Record(TTemplateString28, TFilterSet18))
});
var TOutputFilesystemFilter27 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration20 = Object2({
  enabled: TTemplateString28,
  ttl: Optional(TTemplateString28)
});
var TTaskDefinitionWithoutParallel27 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification27),
  type: Optional(Enum(TaskType27)),
  after: Optional(TTemplateString28),
  if: Optional(TTemplateString28),
  source: Optional(TSource27),
  cacheConfiguration: TCacheConfiguration20,
  docker: Optional(TTemplateString28),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString28),
  filter: Optional(TInputFilesystemFilter27),
  backgroundProcesses: Optional(Array2(TBackgroundProcess27)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor27)),
  envMerge: Optional(Array2(TEnvMergeStrategy27)),
  timeout: Optional(TTemplateString28),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath54)),
  artifactPaths: Optional(Array2(TArtifactPath27)),
  outputs: Optional(TTaskDefinitionOutputs27),
  problemMatchers: Optional(Array2(TProblemMatcher54)),
  problemPaths: Optional(Array2(TProblemPath54)),
  parallelismType: Optional(Enum(ParallelismType27)),
  parallelismValue: Optional(TParallelismValue27),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString28)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString28),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter27),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString28,
      if: Optional(TTemplateString28),
      action: Optional(TTemplateString28)
    })
  )
});
var TCrossRunSource17 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents17 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource17,
  relativeScopedKey: String2()
});
var TTaskDefinition27 = Composite([
  TTaskDefinitionWithoutParallel27,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel27),
    parallelKey: Optional(TTemplateString28),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString28), TTemplateString28]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString28)), TTemplateString28])),
    parallelismTotal: Optional(TTemplateString28)
  })
]);
var TLayerWithManifest54 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId55,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext27 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret27 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess27 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString28,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString28,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult54 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus54),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus54),
  startedAt: Optional(TDateString55),
  completedAt: Optional(TDateString55),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem54 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity54),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary21 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults54 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary21),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest44 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact54 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest44, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact27 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor18)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor18))
      })
    )
  )
});
var TGithubStatusCheck13 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration27 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow27 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow27 || {});
var TConcurrencyPool27 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow27) });
var LeaseState27 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState27 || {});
var TTiming46 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps46 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming46)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming46),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming46),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming46.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming46),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming46),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming46),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming46),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming46),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming46),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming46),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming46)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming46.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic27 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction43 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact54)
});
var TBaseLayerSpecificationTriple20 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId20 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification20 = Union([TBaseLayerSpecificationTriple20, TBaseLayerSpecificationLayerId20]);
var TBaseLayerDescriptor20 = Composite([
  TBaseLayerSpecificationTriple20,
  TBaseLayerSpecificationLayerId20,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit20 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit20 || {});
var TTTL20 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit20)
});
var TResolvedWriteCacheConfiguration5 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL20, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration5 = Object2({
  enabled: Boolean2()
});
var TTip31 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask27 = Object2({
  schemaVersion: Literal(ThisSchemaVersion27),
  taskId: TTaskOrGroupId55,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId28),
  generatorTaskId: Optional(TTaskOrGroupId55),
  definition: TTaskDefinition27,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus27),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus27),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus27),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus27),
  resultStatus: Enum(TaskResultStatus27),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason27)),
  resolvedAt: Optional(TDateString55),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString55),
  debugReadyAt: Optional(TDateString55),
  debugStartedAt: Optional(TDateString55),
  debugEndedAt: Optional(TDateString55),
  cancellationRequestedAt: Optional(TDateString55),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString55),
  cancelledAt: Optional(TDateString55),
  concurrencyPool: Optional(TConcurrencyPool27),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext27),
  usedSecrets: Optional(Array2(TUsedSecret27)),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration5),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration5),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString28, cacheKey: Enum(EnvironmentVariableCacheKey52) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString28),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess27)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact27)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest54)),
  previousLayers: Optional(Array2(TLayerWithManifest54)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest54)),
  filesystemLayers: Optional(Array2(TLayerWithManifest54)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString28)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration27),
      baseLayer: TBaseLayerDescriptor20,
      crossRunSource: Optional(TCrossRunSource17)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification27),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath25)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult54)),
  whiteoutLayer: Optional(TLayerWithManifest54),
  outputLayers: Optional(Array2(TLayerWithManifest54)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey52) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem54)),
  testResults: Optional(Array2(TTestResults54)),
  artifacts: Optional(Array2(TArtifact54)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents17),
  tips: Array2(TTip31),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps46,
  networkTraffic: TNetworkTraffic27,
  outputRetryActions: Array2(TRetryAction43),
  retryAction: Optional(TRetryAction43),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest54),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2())
});
var TRetryManifestEntry27 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry27 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString55,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString55),
  mostRecentlyAttemptedAt: Optional(TDateString55),
  finishedAt: Optional(TDateString55),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots27 = Object2({ resolution: Array2(TGraphNodeId28), runtime: Array2(TGraphNodeId28) });
var TRunGraph27 = Object2({
  roots: TGraphRoots27,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId28, Array2(TGraphNodeId28)),
    runtime: Record(TGraphNodeId28, Array2(TGraphNodeId28))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId28, Array2(TGraphNodeId28)),
    runtime: Record(TGraphNodeId28, Array2(TGraphNodeId28))
  }),
  subgraphs: Record(TGraphNodeId28, Object2({ roots: TGraphRoots27 })),
  parents: Record(TGraphNodeId28, TGraphNodeId28),
  definitionOrders: Record(TGraphNodeId28, Number2())
});
var TActor27 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState27 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState27)
});
var ApprovalRequestState24 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState24 || {});
var TApprovalRequest24 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState24)
});
var TRun27 = Object2({
  schemaVersion: Literal(ThisSchemaVersion27),
  persistenceExpiresAtSeconds: TEpochSeconds28,
  runId: String2(),
  createdAt: TDateString55,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor27),
  mintDirectoryArtifact: Optional(TArtifact54),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck13),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool27),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration27),
  eventNumber: Number2(),
  retries: Array2(TRetry27),
  approvalRequests: Array2(TApprovalRequest24),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph27,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry27)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey28, TConcurrencyPoolState27),
  baseLayer: Optional(TBaseLayerDescriptor20),
  crossRunSource: TCrossRunSource17,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus27),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus27),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus27),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus27),
  resultStatus: Enum(RunResultStatus27),
  waitingForLeaseAt: Optional(TDateString55),
  waitingForManualStartAt: Optional(TDateString55),
  startedAt: Optional(TDateString55),
  cancellationRequestedAt: Optional(TDateString55),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString55),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v65.ts
var ThisSchemaVersion28 = "v65" /* V65 */;
var TTaskOrGroupId56 = TBrandedString();
var TGraphNodeId29 = TBrandedString();
var TTemplateString29 = TBrandedString();
var TEvaluatedString29 = TBrandedString();
var TDateString56 = TBrandedString();
var TEpochSeconds29 = TBrandedNumber();
var TScopedTaskKey29 = TBrandedString();
var TaskType28 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType28 || {});
var TaskResultStatus28 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus28 || {});
var TaskExecutionStatus28 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus28 || {});
var TaskExecutionWaitingSubStatus28 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus28 || {});
var TaskExecutionAbortedSubStatus28 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus28 || {});
var TaskExecutionFinishedSubStatus28 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus28 || {});
var TaskAttemptReason28 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason28 || {});
var BackgroundProcessResultStatus55 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus55 || {});
var BackgroundProcessResultFinishedSubStatus55 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus55 || {});
var RunResultStatus28 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus28 || {});
var RunExecutionStatus28 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus28 || {});
var RunExecutionWaitingSubStatus28 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus28 || {});
var RunExecutionAbortedSubStatus28 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus28 || {});
var RunExecutionFinishedSubStatus28 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus28 || {});
var TSource28 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey53 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey53 || {});
var TExpandedEnvDescriptor28 = Object2({ value: Optional(TTemplateString29), cacheKey: Enum(EnvironmentVariableCacheKey53) });
var TEnvMergeStrategy28 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath55 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern55 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity55 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity55 || {});
var TProblemMatcher55 = Object2({ owner: String2(), severity: Optional(Enum(Severity55)), pattern: Array2(TProblemMatcherPattern55) });
var TProblemPath55 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath28 = Object2({ key: String2(), path: TTemplateString29 });
var TResolvedArtifactPath26 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck28 = Object2({ run: TTemplateString29, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess28 = Object2({
  key: String2(),
  command: TTemplateString29,
  readyCheck: Optional(TExpandedReadyCheck28),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType28 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType28 || {});
var TParallelismValue28 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification28 = Object2({
  cpus: Optional(TTemplateString29),
  memory: Optional(TTemplateString29),
  disk: Object2({ size: Optional(TTemplateString29) }),
  staticIps: Optional(TTemplateString29),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification28 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs28 = Object2({
  values: Optional(Record(String2(), TTemplateString29)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor19 = Object2({ path: TTemplateString29, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor19 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet19 = Union([TTemplateString29, Array2(Union([TTemplateString29, TFilterDescriptor19]))]);
var TInputFilesystemFilter28 = Object2({
  workspace: Optional(TFilterSet19),
  artifacts: Optional(Record(TTemplateString29, TFilterSet19))
});
var TOutputFilesystemFilter28 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration21 = Object2({
  enabled: TTemplateString29,
  ttl: Optional(TTemplateString29)
});
var TTaskDefinitionWithoutParallel28 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification28),
  type: Optional(Enum(TaskType28)),
  after: Optional(TTemplateString29),
  if: Optional(TTemplateString29),
  source: Optional(TSource28),
  cacheConfiguration: TCacheConfiguration21,
  docker: Optional(TTemplateString29),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString29),
  filter: Optional(TInputFilesystemFilter28),
  backgroundProcesses: Optional(Array2(TBackgroundProcess28)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor28)),
  envMerge: Optional(Array2(TEnvMergeStrategy28)),
  timeout: Optional(TTemplateString29),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath55)),
  artifactPaths: Optional(Array2(TArtifactPath28)),
  outputs: Optional(TTaskDefinitionOutputs28),
  problemMatchers: Optional(Array2(TProblemMatcher55)),
  problemPaths: Optional(Array2(TProblemPath55)),
  parallelismType: Optional(Enum(ParallelismType28)),
  parallelismValue: Optional(TParallelismValue28),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString29)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString29),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter28),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString29,
      if: Optional(TTemplateString29),
      action: Optional(TTemplateString29)
    })
  )
});
var TCrossRunSource18 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents18 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource18,
  relativeScopedKey: String2()
});
var TTaskDefinition28 = Composite([
  TTaskDefinitionWithoutParallel28,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel28),
    parallelKey: Optional(TTemplateString29),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString29), TTemplateString29]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString29)), TTemplateString29])),
    parallelismTotal: Optional(TTemplateString29)
  })
]);
var TLayerWithManifest55 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId56,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext28 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret28 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess28 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString29,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString29,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult55 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus55),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus55),
  startedAt: Optional(TDateString56),
  completedAt: Optional(TDateString56),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem55 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity55),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary22 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults55 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary22),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest45 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact55 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest45, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact28 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor19)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor19))
      })
    )
  )
});
var TGithubStatusCheck14 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration28 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow28 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow28 || {});
var TConcurrencyPool28 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow28) });
var LeaseState28 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState28 || {});
var TTiming47 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps47 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming47)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming47),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming47),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming47.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming47),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming47),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming47),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming47),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming47),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming47),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming47),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming47)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming47.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic28 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction44 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact55)
});
var TBaseLayerSpecificationTriple21 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId21 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification21 = Union([TBaseLayerSpecificationTriple21, TBaseLayerSpecificationLayerId21]);
var TBaseLayerDescriptor21 = Composite([
  TBaseLayerSpecificationTriple21,
  TBaseLayerSpecificationLayerId21,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit21 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit21 || {});
var TTTL21 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit21)
});
var TResolvedWriteCacheConfiguration6 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL21, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration6 = Object2({
  enabled: Boolean2()
});
var TTip32 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory2 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask28 = Object2({
  schemaVersion: Literal(ThisSchemaVersion28),
  taskId: TTaskOrGroupId56,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId29),
  generatorTaskId: Optional(TTaskOrGroupId56),
  definition: TTaskDefinition28,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus28),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus28),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus28),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus28),
  resultStatus: Enum(TaskResultStatus28),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason28)),
  attemptCounts: Record(TRetryCategory2, Number2()),
  resolvedAt: Optional(TDateString56),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString56),
  debugReadyAt: Optional(TDateString56),
  debugStartedAt: Optional(TDateString56),
  debugEndedAt: Optional(TDateString56),
  cancellationRequestedAt: Optional(TDateString56),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString56),
  cancelledAt: Optional(TDateString56),
  concurrencyPool: Optional(TConcurrencyPool28),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext28),
  usedSecrets: Optional(Array2(TUsedSecret28)),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration6),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration6),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString29, cacheKey: Enum(EnvironmentVariableCacheKey53) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString29),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess28)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact28)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest55)),
  previousLayers: Optional(Array2(TLayerWithManifest55)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest55)),
  filesystemLayers: Optional(Array2(TLayerWithManifest55)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString29)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration28),
      baseLayer: TBaseLayerDescriptor21,
      crossRunSource: Optional(TCrossRunSource18)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification28),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath26)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult55)),
  whiteoutLayer: Optional(TLayerWithManifest55),
  outputLayers: Optional(Array2(TLayerWithManifest55)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey53) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem55)),
  testResults: Optional(Array2(TTestResults55)),
  artifacts: Optional(Array2(TArtifact55)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents18),
  tips: Array2(TTip32),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps47,
  networkTraffic: TNetworkTraffic28,
  outputRetryActions: Array2(TRetryAction44),
  retryAction: Optional(TRetryAction44),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest55),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2())
});
var TRetryManifestEntry28 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry28 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString56,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString56),
  mostRecentlyAttemptedAt: Optional(TDateString56),
  finishedAt: Optional(TDateString56),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory2
});
var TGraphRoots28 = Object2({ resolution: Array2(TGraphNodeId29), runtime: Array2(TGraphNodeId29) });
var TRunGraph28 = Object2({
  roots: TGraphRoots28,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId29, Array2(TGraphNodeId29)),
    runtime: Record(TGraphNodeId29, Array2(TGraphNodeId29))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId29, Array2(TGraphNodeId29)),
    runtime: Record(TGraphNodeId29, Array2(TGraphNodeId29))
  }),
  subgraphs: Record(TGraphNodeId29, Object2({ roots: TGraphRoots28 })),
  parents: Record(TGraphNodeId29, TGraphNodeId29),
  definitionOrders: Record(TGraphNodeId29, Number2())
});
var TActor28 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState28 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState28)
});
var ApprovalRequestState25 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState25 || {});
var TApprovalRequest25 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState25)
});
var TRun28 = Object2({
  schemaVersion: Literal(ThisSchemaVersion28),
  persistenceExpiresAtSeconds: TEpochSeconds29,
  runId: String2(),
  createdAt: TDateString56,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor28),
  mintDirectoryArtifact: Optional(TArtifact55),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck14),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool28),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration28),
  eventNumber: Number2(),
  retries: Array2(TRetry28),
  approvalRequests: Array2(TApprovalRequest25),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph28,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry28)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey29, TConcurrencyPoolState28),
  baseLayer: Optional(TBaseLayerDescriptor21),
  crossRunSource: TCrossRunSource18,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus28),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus28),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus28),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus28),
  resultStatus: Enum(RunResultStatus28),
  waitingForLeaseAt: Optional(TDateString56),
  waitingForManualStartAt: Optional(TDateString56),
  startedAt: Optional(TDateString56),
  cancellationRequestedAt: Optional(TDateString56),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString56),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v66.ts
var ThisSchemaVersion29 = "v66" /* V66 */;
var TTaskOrGroupId57 = TBrandedString();
var TGraphNodeId30 = TBrandedString();
var TTemplateString30 = TBrandedString();
var TEvaluatedString30 = TBrandedString();
var TDateString57 = TBrandedString();
var TEpochSeconds30 = TBrandedNumber();
var TScopedTaskKey30 = TBrandedString();
var TaskType29 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType29 || {});
var TaskResultStatus29 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus29 || {});
var TaskExecutionStatus29 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus29 || {});
var TaskExecutionWaitingSubStatus29 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus29 || {});
var TaskExecutionAbortedSubStatus29 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus29 || {});
var TaskExecutionFinishedSubStatus29 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus29 || {});
var TaskAttemptReason29 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason29 || {});
var BackgroundProcessResultStatus56 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus56 || {});
var BackgroundProcessResultFinishedSubStatus56 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus56 || {});
var RunResultStatus29 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus29 || {});
var RunExecutionStatus29 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus29 || {});
var RunExecutionWaitingSubStatus29 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus29 || {});
var RunExecutionAbortedSubStatus29 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus29 || {});
var RunExecutionFinishedSubStatus29 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus29 || {});
var TSource29 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey54 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey54 || {});
var TExpandedEnvDescriptor29 = Object2({ value: Optional(TTemplateString30), cacheKey: Enum(EnvironmentVariableCacheKey54) });
var TEnvMergeStrategy29 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath56 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern56 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity56 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity56 || {});
var TProblemMatcher56 = Object2({ owner: String2(), severity: Optional(Enum(Severity56)), pattern: Array2(TProblemMatcherPattern56) });
var TProblemPath56 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath29 = Object2({ key: String2(), path: TTemplateString30 });
var TResolvedArtifactPath27 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck29 = Object2({ run: TTemplateString30, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess29 = Object2({
  key: String2(),
  command: TTemplateString30,
  readyCheck: Optional(TExpandedReadyCheck29),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType29 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType29 || {});
var TParallelismValue29 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification29 = Object2({
  cpus: Optional(TTemplateString30),
  memory: Optional(TTemplateString30),
  disk: Object2({ size: Optional(TTemplateString30) }),
  staticIps: Optional(TTemplateString30),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification29 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs29 = Object2({
  values: Optional(Record(String2(), TTemplateString30)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor20 = Object2({ path: TTemplateString30, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor20 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet20 = Union([TTemplateString30, Array2(Union([TTemplateString30, TFilterDescriptor20]))]);
var TInputFilesystemFilter29 = Object2({
  workspace: Optional(TFilterSet20),
  artifacts: Optional(Record(TTemplateString30, TFilterSet20))
});
var TOutputFilesystemFilter29 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration22 = Object2({
  enabled: TTemplateString30,
  ttl: Optional(TTemplateString30)
});
var TTaskDefinitionWithoutParallel29 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification29),
  type: Optional(Enum(TaskType29)),
  after: Optional(TTemplateString30),
  if: Optional(TTemplateString30),
  source: Optional(TSource29),
  cacheConfiguration: TCacheConfiguration22,
  docker: Optional(TTemplateString30),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString30),
  filter: Optional(TInputFilesystemFilter29),
  backgroundProcesses: Optional(Array2(TBackgroundProcess29)),
  toolCache: Optional(TTemplateString30),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor29)),
  envMerge: Optional(Array2(TEnvMergeStrategy29)),
  timeout: Optional(TTemplateString30),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath56)),
  artifactPaths: Optional(Array2(TArtifactPath29)),
  outputs: Optional(TTaskDefinitionOutputs29),
  problemMatchers: Optional(Array2(TProblemMatcher56)),
  problemPaths: Optional(Array2(TProblemPath56)),
  parallelismType: Optional(Enum(ParallelismType29)),
  parallelismValue: Optional(TParallelismValue29),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString30)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString30),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter29),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString30,
      if: Optional(TTemplateString30),
      action: Optional(TTemplateString30)
    })
  )
});
var TCrossRunSource19 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents19 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource19,
  relativeScopedKey: String2()
});
var TTaskDefinition29 = Composite([
  TTaskDefinitionWithoutParallel29,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel29),
    parallelKey: Optional(TTemplateString30),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString30), TTemplateString30]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString30)), TTemplateString30])),
    parallelismTotal: Optional(TTemplateString30)
  })
]);
var TLayerWithManifest56 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId57,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext29 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret29 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess29 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString30,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString30,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult56 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus56),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus56),
  startedAt: Optional(TDateString57),
  completedAt: Optional(TDateString57),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem56 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity56),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary23 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults56 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary23),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest46 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact56 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest46, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact29 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor20)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor20))
      })
    )
  )
});
var TGithubStatusCheck15 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration29 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow29 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow29 || {});
var TConcurrencyPool29 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow29) });
var LeaseState29 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState29 || {});
var TTiming48 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps48 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming48)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming48),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming48),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming48.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming48),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming48),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming48),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming48),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming48),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming48),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming48),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming48)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming48.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic29 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction45 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact56)
});
var TBaseLayerSpecificationTriple22 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId22 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification22 = Union([TBaseLayerSpecificationTriple22, TBaseLayerSpecificationLayerId22]);
var TBaseLayerDescriptor22 = Composite([
  TBaseLayerSpecificationTriple22,
  TBaseLayerSpecificationLayerId22,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit22 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit22 || {});
var TTTL22 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit22)
});
var TResolvedWriteCacheConfiguration7 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL22, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration7 = Object2({
  enabled: Boolean2()
});
var TTip33 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory3 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask29 = Object2({
  schemaVersion: Literal(ThisSchemaVersion29),
  taskId: TTaskOrGroupId57,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId30),
  generatorTaskId: Optional(TTaskOrGroupId57),
  definition: TTaskDefinition29,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus29),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus29),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus29),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus29),
  resultStatus: Enum(TaskResultStatus29),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason29)),
  attemptCounts: Record(TRetryCategory3, Number2()),
  resolvedAt: Optional(TDateString57),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString57),
  debugReadyAt: Optional(TDateString57),
  debugStartedAt: Optional(TDateString57),
  debugEndedAt: Optional(TDateString57),
  cancellationRequestedAt: Optional(TDateString57),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString57),
  cancelledAt: Optional(TDateString57),
  concurrencyPool: Optional(TConcurrencyPool29),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext29),
  usedSecrets: Optional(Array2(TUsedSecret29)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration7),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration7),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString30, cacheKey: Enum(EnvironmentVariableCacheKey54) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString30),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess29)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact29)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest56)),
  previousLayers: Optional(Array2(TLayerWithManifest56)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest56)),
  filesystemLayers: Optional(Array2(TLayerWithManifest56)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString30)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration29),
      baseLayer: TBaseLayerDescriptor22,
      crossRunSource: Optional(TCrossRunSource19)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification29),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath27)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult56)),
  whiteoutLayer: Optional(TLayerWithManifest56),
  outputLayers: Optional(Array2(TLayerWithManifest56)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey54) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem56)),
  testResults: Optional(Array2(TTestResults56)),
  artifacts: Optional(Array2(TArtifact56)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents19),
  tips: Array2(TTip33),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps48,
  networkTraffic: TNetworkTraffic29,
  outputRetryActions: Array2(TRetryAction45),
  retryAction: Optional(TRetryAction45),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest56),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2())
});
var TRetryManifestEntry29 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry29 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString57,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString57),
  mostRecentlyAttemptedAt: Optional(TDateString57),
  finishedAt: Optional(TDateString57),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory3
});
var TGraphRoots29 = Object2({ resolution: Array2(TGraphNodeId30), runtime: Array2(TGraphNodeId30) });
var TRunGraph29 = Object2({
  roots: TGraphRoots29,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId30, Array2(TGraphNodeId30)),
    runtime: Record(TGraphNodeId30, Array2(TGraphNodeId30))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId30, Array2(TGraphNodeId30)),
    runtime: Record(TGraphNodeId30, Array2(TGraphNodeId30))
  }),
  subgraphs: Record(TGraphNodeId30, Object2({ roots: TGraphRoots29 })),
  parents: Record(TGraphNodeId30, TGraphNodeId30),
  definitionOrders: Record(TGraphNodeId30, Number2())
});
var TActor29 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState29 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState29)
});
var ApprovalRequestState26 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState26 || {});
var TApprovalRequest26 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState26)
});
var TRun29 = Object2({
  schemaVersion: Literal(ThisSchemaVersion29),
  persistenceExpiresAtSeconds: TEpochSeconds30,
  runId: String2(),
  createdAt: TDateString57,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor29),
  mintDirectoryArtifact: Optional(TArtifact56),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck15),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool29),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration29),
  eventNumber: Number2(),
  retries: Array2(TRetry29),
  approvalRequests: Array2(TApprovalRequest26),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph29,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry29)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey30, TConcurrencyPoolState29),
  baseLayer: Optional(TBaseLayerDescriptor22),
  crossRunSource: TCrossRunSource19,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus29),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus29),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus29),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus29),
  resultStatus: Enum(RunResultStatus29),
  waitingForLeaseAt: Optional(TDateString57),
  waitingForManualStartAt: Optional(TDateString57),
  startedAt: Optional(TDateString57),
  cancellationRequestedAt: Optional(TDateString57),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString57),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v67.ts
var ThisSchemaVersion30 = "v67" /* V67 */;
var TTaskOrGroupId58 = TBrandedString();
var TGraphNodeId31 = TBrandedString();
var TTemplateString31 = TBrandedString();
var TEvaluatedString31 = TBrandedString();
var TDateString58 = TBrandedString();
var TEpochSeconds31 = TBrandedNumber();
var TScopedTaskKey31 = TBrandedString();
var TaskType30 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType30 || {});
var TaskResultStatus30 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus30 || {});
var TaskExecutionStatus30 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus30 || {});
var TaskExecutionWaitingSubStatus30 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus30 || {});
var TaskExecutionAbortedSubStatus30 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus30 || {});
var TaskExecutionFinishedSubStatus30 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus30 || {});
var TaskAttemptReason30 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason30 || {});
var BackgroundProcessResultStatus57 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus57 || {});
var BackgroundProcessResultFinishedSubStatus57 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus57 || {});
var RunResultStatus30 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus30 || {});
var RunExecutionStatus30 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus30 || {});
var RunExecutionWaitingSubStatus30 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus30 || {});
var RunExecutionAbortedSubStatus30 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus30 || {});
var RunExecutionFinishedSubStatus30 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus30 || {});
var TSource30 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey55 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey55 || {});
var TExpandedEnvDescriptor30 = Object2({ value: Optional(TTemplateString31), cacheKey: Enum(EnvironmentVariableCacheKey55) });
var TEnvMergeStrategy30 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath57 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern57 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity57 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity57 || {});
var TProblemMatcher57 = Object2({ owner: String2(), severity: Optional(Enum(Severity57)), pattern: Array2(TProblemMatcherPattern57) });
var TProblemPath57 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath30 = Object2({ key: String2(), path: TTemplateString31 });
var TResolvedArtifactPath28 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck30 = Object2({ run: TTemplateString31, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess30 = Object2({
  key: String2(),
  command: TTemplateString31,
  readyCheck: Optional(TExpandedReadyCheck30),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType30 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType30 || {});
var TParallelismValue30 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification30 = Object2({
  cpus: Optional(TTemplateString31),
  memory: Optional(TTemplateString31),
  disk: Object2({ size: Optional(TTemplateString31) }),
  staticIps: Optional(TTemplateString31),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification30 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs30 = Object2({
  values: Optional(Record(String2(), TTemplateString31)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor21 = Object2({ path: TTemplateString31, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor21 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet21 = Union([TTemplateString31, Array2(Union([TTemplateString31, TFilterDescriptor21]))]);
var TInputFilesystemFilter30 = Object2({
  workspace: Optional(TFilterSet21),
  artifacts: Optional(Record(TTemplateString31, TFilterSet21))
});
var TOutputFilesystemFilter30 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration23 = Object2({
  enabled: TTemplateString31,
  ttl: Optional(TTemplateString31)
});
var TTaskDefinitionWithoutParallel30 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification30),
  type: Optional(Enum(TaskType30)),
  after: Optional(TTemplateString31),
  if: Optional(TTemplateString31),
  source: Optional(TSource30),
  cacheConfiguration: TCacheConfiguration23,
  docker: Optional(TTemplateString31),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString31),
  filter: Optional(TInputFilesystemFilter30),
  backgroundProcesses: Optional(Array2(TBackgroundProcess30)),
  toolCache: Optional(TTemplateString31),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor30)),
  envMerge: Optional(Array2(TEnvMergeStrategy30)),
  timeout: Optional(TTemplateString31),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath57)),
  artifactPaths: Optional(Array2(TArtifactPath30)),
  outputs: Optional(TTaskDefinitionOutputs30),
  problemMatchers: Optional(Array2(TProblemMatcher57)),
  problemPaths: Optional(Array2(TProblemPath57)),
  parallelismType: Optional(Enum(ParallelismType30)),
  parallelismValue: Optional(TParallelismValue30),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString31)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString31),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter30),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString31,
      if: Optional(TTemplateString31),
      action: Optional(TTemplateString31)
    })
  )
});
var TCrossRunSource20 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents20 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource20,
  relativeScopedKey: String2()
});
var TTaskDefinition30 = Composite([
  TTaskDefinitionWithoutParallel30,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel30),
    parallelKey: Optional(TTemplateString31),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString31), TTemplateString31]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString31)), TTemplateString31])),
    parallelismTotal: Optional(TTemplateString31)
  })
]);
var TLayerWithManifest57 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId58,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext30 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret30 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess30 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString31,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString31,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult57 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus57),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus57),
  startedAt: Optional(TDateString58),
  completedAt: Optional(TDateString58),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem57 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity57),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary24 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults57 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary24),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest47 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact57 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest47, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact30 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor21)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor21))
      })
    )
  )
});
var TGithubStatusCheck16 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration30 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow30 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow30 || {});
var TConcurrencyPool30 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow30) });
var LeaseState30 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState30 || {});
var TTiming49 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps49 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming49)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming49),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming49),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming49.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming49),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming49),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming49),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming49),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming49),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming49),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming49),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming49)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming49.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic30 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction46 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact57)
});
var TBaseLayerSpecificationTriple23 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId23 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification23 = Union([TBaseLayerSpecificationTriple23, TBaseLayerSpecificationLayerId23]);
var TBaseLayerDescriptor23 = Composite([
  TBaseLayerSpecificationTriple23,
  TBaseLayerSpecificationLayerId23,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit23 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit23 || {});
var TTTL23 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit23)
});
var TResolvedWriteCacheConfiguration8 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL23, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration8 = Object2({
  enabled: Boolean2()
});
var TTip34 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory4 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask30 = Object2({
  schemaVersion: Literal(ThisSchemaVersion30),
  taskId: TTaskOrGroupId58,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId31),
  generatorTaskId: Optional(TTaskOrGroupId58),
  definition: TTaskDefinition30,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus30),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus30),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus30),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus30),
  resultStatus: Enum(TaskResultStatus30),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason30)),
  attemptCounts: Record(TRetryCategory4, Number2()),
  resolvedAt: Optional(TDateString58),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString58),
  debugReadyAt: Optional(TDateString58),
  debugStartedAt: Optional(TDateString58),
  debugEndedAt: Optional(TDateString58),
  cancellationRequestedAt: Optional(TDateString58),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString58),
  cancelledAt: Optional(TDateString58),
  concurrencyPool: Optional(TConcurrencyPool30),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext30),
  usedSecrets: Optional(Array2(TUsedSecret30)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration8),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration8),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString31, cacheKey: Enum(EnvironmentVariableCacheKey55) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString31),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess30)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact30)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest57)),
  previousLayers: Optional(Array2(TLayerWithManifest57)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest57)),
  filesystemLayers: Optional(Array2(TLayerWithManifest57)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString31)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration30),
      baseLayer: TBaseLayerDescriptor23,
      crossRunSource: Optional(TCrossRunSource20)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification30),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath28)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult57)),
  whiteoutLayer: Optional(TLayerWithManifest57),
  outputLayers: Optional(Array2(TLayerWithManifest57)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey55) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem57)),
  testResults: Optional(Array2(TTestResults57)),
  artifacts: Optional(Array2(TArtifact57)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents20),
  tips: Array2(TTip34),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps49,
  networkTraffic: TNetworkTraffic30,
  outputRetryActions: Array2(TRetryAction46),
  retryAction: Optional(TRetryAction46),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest57),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString58)
});
var TRetryManifestEntry30 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry30 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString58,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString58),
  mostRecentlyAttemptedAt: Optional(TDateString58),
  finishedAt: Optional(TDateString58),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory4
});
var TGraphRoots30 = Object2({ resolution: Array2(TGraphNodeId31), runtime: Array2(TGraphNodeId31) });
var TRunGraph30 = Object2({
  roots: TGraphRoots30,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId31, Array2(TGraphNodeId31)),
    runtime: Record(TGraphNodeId31, Array2(TGraphNodeId31))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId31, Array2(TGraphNodeId31)),
    runtime: Record(TGraphNodeId31, Array2(TGraphNodeId31))
  }),
  subgraphs: Record(TGraphNodeId31, Object2({ roots: TGraphRoots30 })),
  parents: Record(TGraphNodeId31, TGraphNodeId31),
  definitionOrders: Record(TGraphNodeId31, Number2())
});
var TActor30 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState30 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState30)
});
var ApprovalRequestState27 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState27 || {});
var TApprovalRequest27 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState27)
});
var TRun30 = Object2({
  schemaVersion: Literal(ThisSchemaVersion30),
  persistenceExpiresAtSeconds: TEpochSeconds31,
  runId: String2(),
  createdAt: TDateString58,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor30),
  mintDirectoryArtifact: Optional(TArtifact57),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck16),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool30),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration30),
  eventNumber: Number2(),
  retries: Array2(TRetry30),
  approvalRequests: Array2(TApprovalRequest27),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph30,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry30)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey31, TConcurrencyPoolState30),
  baseLayer: Optional(TBaseLayerDescriptor23),
  crossRunSource: TCrossRunSource20,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus30),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus30),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus30),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus30),
  resultStatus: Enum(RunResultStatus30),
  waitingForLeaseAt: Optional(TDateString58),
  waitingForManualStartAt: Optional(TDateString58),
  startedAt: Optional(TDateString58),
  cancellationRequestedAt: Optional(TDateString58),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString58),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v68.ts
var ThisSchemaVersion31 = "v68" /* V68 */;
var TTaskOrGroupId59 = TBrandedString();
var TGraphNodeId32 = TBrandedString();
var TTemplateString32 = TBrandedString();
var TEvaluatedString32 = TBrandedString();
var TDateString59 = TBrandedString();
var TEpochSeconds32 = TBrandedNumber();
var TScopedTaskKey32 = TBrandedString();
var TaskType31 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType31 || {});
var TaskResultStatus31 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus31 || {});
var TaskExecutionStatus31 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus31 || {});
var TaskExecutionWaitingSubStatus31 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus31 || {});
var TaskExecutionAbortedSubStatus31 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus31 || {});
var TaskExecutionFinishedSubStatus31 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus31 || {});
var TaskAttemptReason31 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason31 || {});
var BackgroundProcessResultStatus58 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus58 || {});
var BackgroundProcessResultFinishedSubStatus58 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus58 || {});
var RunResultStatus31 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus31 || {});
var RunExecutionStatus31 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus31 || {});
var RunExecutionWaitingSubStatus31 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus31 || {});
var RunExecutionAbortedSubStatus31 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus31 || {});
var RunExecutionFinishedSubStatus31 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus31 || {});
var TSource31 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey56 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey56 || {});
var TExpandedEnvDescriptor31 = Object2({ value: Optional(TTemplateString32), cacheKey: Enum(EnvironmentVariableCacheKey56) });
var TEnvMergeStrategy31 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath58 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern58 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity58 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity58 || {});
var TProblemMatcher58 = Object2({ owner: String2(), severity: Optional(Enum(Severity58)), pattern: Array2(TProblemMatcherPattern58) });
var TProblemPath58 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath31 = Object2({ key: String2(), path: TTemplateString32 });
var TResolvedArtifactPath29 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck31 = Object2({ run: TTemplateString32, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess31 = Object2({
  key: String2(),
  command: TTemplateString32,
  readyCheck: Optional(TExpandedReadyCheck31),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType31 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType31 || {});
var TParallelismValue31 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification31 = Object2({
  cpus: Optional(TTemplateString32),
  memory: Optional(TTemplateString32),
  disk: Object2({ size: Optional(TTemplateString32) }),
  staticIps: Optional(TTemplateString32),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification31 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs31 = Object2({
  values: Optional(Record(String2(), TTemplateString32)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor22 = Object2({ path: TTemplateString32, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor22 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet22 = Union([TTemplateString32, Array2(Union([TTemplateString32, TFilterDescriptor22]))]);
var TInputFilesystemFilter31 = Object2({
  workspace: Optional(TFilterSet22),
  artifacts: Optional(Record(TTemplateString32, TFilterSet22))
});
var TOutputFilesystemFilter31 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration24 = Object2({
  enabled: TTemplateString32,
  ttl: Optional(TTemplateString32)
});
var TTaskDefinitionWithoutParallel31 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification31),
  type: Optional(Enum(TaskType31)),
  after: Optional(TTemplateString32),
  if: Optional(TTemplateString32),
  source: Optional(TSource31),
  cacheConfiguration: TCacheConfiguration24,
  docker: Optional(TTemplateString32),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString32),
  filter: Optional(TInputFilesystemFilter31),
  backgroundProcesses: Optional(Array2(TBackgroundProcess31)),
  toolCache: Optional(TTemplateString32),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor31)),
  envMerge: Optional(Array2(TEnvMergeStrategy31)),
  timeout: Optional(TTemplateString32),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath58)),
  artifactPaths: Optional(Array2(TArtifactPath31)),
  outputs: Optional(TTaskDefinitionOutputs31),
  problemMatchers: Optional(Array2(TProblemMatcher58)),
  problemPaths: Optional(Array2(TProblemPath58)),
  parallelismType: Optional(Enum(ParallelismType31)),
  parallelismValue: Optional(TParallelismValue31),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString32)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString32),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter31),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString32,
      if: Optional(TTemplateString32),
      action: Optional(TTemplateString32)
    })
  )
});
var TCrossRunSource21 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents21 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource21,
  relativeScopedKey: String2()
});
var TTaskDefinition31 = Composite([
  TTaskDefinitionWithoutParallel31,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel31),
    parallelKey: Optional(TTemplateString32),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString32), TTemplateString32]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString32)), TTemplateString32])),
    parallelismTotal: Optional(TTemplateString32)
  })
]);
var TLayerWithManifest58 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId59,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext31 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret31 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess31 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString32,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString32,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult58 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus58),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus58),
  startedAt: Optional(TDateString59),
  completedAt: Optional(TDateString59),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem58 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity58),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary25 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults58 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary25),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest48 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact58 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest48, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact31 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor22)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor22))
      })
    )
  )
});
var TGithubStatusCheck17 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration31 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow31 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow31 || {});
var TConcurrencyPool31 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow31) });
var LeaseState31 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState31 || {});
var TTiming50 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps50 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming50)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming50),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming50),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming50.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming50),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming50),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming50),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming50),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming50),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming50),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming50),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming50)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming50.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic31 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction47 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact58)
});
var TBaseLayerSpecificationTriple24 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId24 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification24 = Union([TBaseLayerSpecificationTriple24, TBaseLayerSpecificationLayerId24]);
var TBaseLayerDescriptor24 = Composite([
  TBaseLayerSpecificationTriple24,
  TBaseLayerSpecificationLayerId24,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit24 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit24 || {});
var TTTL24 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit24)
});
var TResolvedWriteCacheConfiguration9 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL24, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration9 = Object2({
  enabled: Boolean2()
});
var TTip35 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory5 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask31 = Object2({
  schemaVersion: Literal(ThisSchemaVersion31),
  taskId: TTaskOrGroupId59,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId32),
  generatorTaskId: Optional(TTaskOrGroupId59),
  definition: TTaskDefinition31,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus31),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus31),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus31),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus31),
  resultStatus: Enum(TaskResultStatus31),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason31)),
  attemptCounts: Record(TRetryCategory5, Number2()),
  resolvedAt: Optional(TDateString59),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString59),
  debugReadyAt: Optional(TDateString59),
  debugStartedAt: Optional(TDateString59),
  debugEndedAt: Optional(TDateString59),
  cancellationRequestedAt: Optional(TDateString59),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString59),
  cancelledAt: Optional(TDateString59),
  concurrencyPool: Optional(TConcurrencyPool31),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext31),
  usedSecrets: Optional(Array2(TUsedSecret31)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration9),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration9),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString32, cacheKey: Enum(EnvironmentVariableCacheKey56) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString32),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess31)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact31)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest58)),
  previousLayers: Optional(Array2(TLayerWithManifest58)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest58)),
  filesystemLayers: Optional(Array2(TLayerWithManifest58)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString32)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration31),
      baseLayer: TBaseLayerDescriptor24,
      crossRunSource: Optional(TCrossRunSource21)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification31),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath29)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult58)),
  whiteoutLayer: Optional(TLayerWithManifest58),
  outputLayers: Optional(Array2(TLayerWithManifest58)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey56) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem58)),
  testResults: Optional(Array2(TTestResults58)),
  artifacts: Optional(Array2(TArtifact58)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents21),
  tips: Array2(TTip35),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps50,
  networkTraffic: TNetworkTraffic31,
  outputRetryActions: Array2(TRetryAction47),
  retryAction: Optional(TRetryAction47),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest58),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString59)
});
var TRetryManifestEntry31 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry31 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString59,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString59),
  mostRecentlyAttemptedAt: Optional(TDateString59),
  finishedAt: Optional(TDateString59),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory5
});
var TGraphRoots31 = Object2({ resolution: Array2(TGraphNodeId32), runtime: Array2(TGraphNodeId32) });
var TRunGraph31 = Object2({
  roots: TGraphRoots31,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId32, Array2(TGraphNodeId32)),
    runtime: Record(TGraphNodeId32, Array2(TGraphNodeId32))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId32, Array2(TGraphNodeId32)),
    runtime: Record(TGraphNodeId32, Array2(TGraphNodeId32))
  }),
  subgraphs: Record(TGraphNodeId32, Object2({ roots: TGraphRoots31 })),
  parents: Record(TGraphNodeId32, TGraphNodeId32),
  definitionOrders: Record(TGraphNodeId32, Number2())
});
var TActor31 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState31 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState31)
});
var ApprovalRequestState28 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState28 || {});
var TApprovalRequest28 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState28)
});
var TRun31 = Object2({
  schemaVersion: Literal(ThisSchemaVersion31),
  persistenceExpiresAtSeconds: TEpochSeconds32,
  runId: String2(),
  createdAt: TDateString59,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor31),
  mintDirectoryArtifact: Optional(TArtifact58),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck17),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool31),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration31),
  eventNumber: Number2(),
  retries: Array2(TRetry31),
  approvalRequests: Array2(TApprovalRequest28),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph31,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry31)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey32, TConcurrencyPoolState31),
  baseLayer: Optional(TBaseLayerDescriptor24),
  crossRunSource: TCrossRunSource21,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus31),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus31),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus31),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus31),
  resultStatus: Enum(RunResultStatus31),
  waitingForLeaseAt: Optional(TDateString59),
  waitingForManualStartAt: Optional(TDateString59),
  startedAt: Optional(TDateString59),
  cancellationRequestedAt: Optional(TDateString59),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString59),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v69.ts
var ThisSchemaVersion32 = "v69" /* V69 */;
var TTaskOrGroupId60 = TBrandedString();
var TGraphNodeId33 = TBrandedString();
var TTemplateString33 = TBrandedString();
var TEvaluatedString33 = TBrandedString();
var TDateString60 = TBrandedString();
var TEpochSeconds33 = TBrandedNumber();
var TScopedTaskKey33 = TBrandedString();
var TaskType32 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType32 || {});
var TaskResultStatus32 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus32 || {});
var TaskExecutionStatus32 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus32 || {});
var TaskExecutionWaitingSubStatus32 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus32 || {});
var TaskExecutionAbortedSubStatus32 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus32 || {});
var TaskExecutionFinishedSubStatus32 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus32 || {});
var TaskAttemptReason32 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason32 || {});
var BackgroundProcessResultStatus59 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus59 || {});
var BackgroundProcessResultFinishedSubStatus59 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus59 || {});
var RunResultStatus32 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus32 || {});
var RunExecutionStatus32 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus32 || {});
var RunExecutionWaitingSubStatus32 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus32 || {});
var RunExecutionAbortedSubStatus32 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus32 || {});
var RunExecutionFinishedSubStatus32 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus32 || {});
var TSource32 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey57 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey57 || {});
var TExpandedEnvDescriptor32 = Object2({ value: Optional(TTemplateString33), cacheKey: Enum(EnvironmentVariableCacheKey57) });
var TEnvMergeStrategy32 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath59 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern59 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity59 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity59 || {});
var TProblemMatcher59 = Object2({ owner: String2(), severity: Optional(Enum(Severity59)), pattern: Array2(TProblemMatcherPattern59) });
var TProblemPath59 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath32 = Object2({ key: String2(), path: TTemplateString33 });
var TResolvedArtifactPath30 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck32 = Object2({ run: TTemplateString33, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess32 = Object2({
  key: String2(),
  command: TTemplateString33,
  readyCheck: Optional(TExpandedReadyCheck32),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType32 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType32 || {});
var TParallelismValue32 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification32 = Object2({
  cpus: Optional(TTemplateString33),
  memory: Optional(TTemplateString33),
  disk: Object2({ size: Optional(TTemplateString33) }),
  staticIps: Optional(TTemplateString33),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification32 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs32 = Object2({
  values: Optional(Record(String2(), TTemplateString33)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor23 = Object2({ path: TTemplateString33, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor23 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet23 = Union([TTemplateString33, Array2(Union([TTemplateString33, TFilterDescriptor23]))]);
var TInputFilesystemFilter32 = Object2({
  workspace: Optional(TFilterSet23),
  artifacts: Optional(Record(TTemplateString33, TFilterSet23))
});
var TOutputFilesystemFilter32 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration25 = Object2({
  enabled: TTemplateString33,
  ttl: Optional(TTemplateString33)
});
var TTaskDefinitionWithoutParallel32 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification32),
  type: Optional(Enum(TaskType32)),
  after: Optional(TTemplateString33),
  if: Optional(TTemplateString33),
  source: Optional(TSource32),
  cacheConfiguration: TCacheConfiguration25,
  docker: Optional(TTemplateString33),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString33),
  filter: Optional(TInputFilesystemFilter32),
  backgroundProcesses: Optional(Array2(TBackgroundProcess32)),
  toolCache: Optional(TTemplateString33),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor32)),
  envMerge: Optional(Array2(TEnvMergeStrategy32)),
  timeout: Optional(TTemplateString33),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath59)),
  artifactPaths: Optional(Array2(TArtifactPath32)),
  outputs: Optional(TTaskDefinitionOutputs32),
  problemMatchers: Optional(Array2(TProblemMatcher59)),
  problemPaths: Optional(Array2(TProblemPath59)),
  parallelismType: Optional(Enum(ParallelismType32)),
  parallelismValue: Optional(TParallelismValue32),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString33)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString33),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter32),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString33,
      if: Optional(TTemplateString33),
      action: Optional(TTemplateString33)
    })
  )
});
var TCrossRunSource22 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents22 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource22,
  relativeScopedKey: String2()
});
var TTaskDefinition32 = Composite([
  TTaskDefinitionWithoutParallel32,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel32),
    parallelKey: Optional(TTemplateString33),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString33), TTemplateString33]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString33)), TTemplateString33])),
    parallelismTotal: Optional(TTemplateString33)
  })
]);
var TLayerWithManifest59 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId60,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext32 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret32 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess32 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString33,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString33,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult59 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus59),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus59),
  startedAt: Optional(TDateString60),
  completedAt: Optional(TDateString60),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem59 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity59),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary26 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults59 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary26),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest49 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact59 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest49, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact32 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor23)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor23))
      })
    )
  )
});
var TGithubStatusCheck18 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration32 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow32 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow32 || {});
var TConcurrencyPool32 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow32) });
var LeaseState32 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState32 || {});
var TTiming51 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps51 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming51)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming51),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming51),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming51.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming51),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming51),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming51),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming51),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming51),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming51),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming51),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming51)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming51.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic32 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction48 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact59)
});
var TBaseLayerSpecificationTriple25 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId25 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification25 = Union([TBaseLayerSpecificationTriple25, TBaseLayerSpecificationLayerId25]);
var TBaseLayerDescriptor25 = Composite([
  TBaseLayerSpecificationTriple25,
  TBaseLayerSpecificationLayerId25,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit25 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit25 || {});
var TTTL25 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit25)
});
var TResolvedWriteCacheConfiguration10 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL25, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration10 = Object2({
  enabled: Boolean2()
});
var TTip36 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory6 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask32 = Object2({
  schemaVersion: Literal(ThisSchemaVersion32),
  taskId: TTaskOrGroupId60,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId33),
  generatorTaskId: Optional(TTaskOrGroupId60),
  definition: TTaskDefinition32,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus32),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus32),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus32),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus32),
  resultStatus: Enum(TaskResultStatus32),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason32)),
  attemptCounts: Record(TRetryCategory6, Number2()),
  resolvedAt: Optional(TDateString60),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString60),
  debugReadyAt: Optional(TDateString60),
  debugStartedAt: Optional(TDateString60),
  debugEndedAt: Optional(TDateString60),
  cancellationRequestedAt: Optional(TDateString60),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString60),
  cancelledAt: Optional(TDateString60),
  concurrencyPool: Optional(TConcurrencyPool32),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext32),
  usedSecrets: Optional(Array2(TUsedSecret32)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration10),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration10),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString33, cacheKey: Enum(EnvironmentVariableCacheKey57) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString33),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess32)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact32)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest59)),
  previousLayers: Optional(Array2(TLayerWithManifest59)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest59)),
  filesystemLayers: Optional(Array2(TLayerWithManifest59)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString33)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration32),
      baseLayer: TBaseLayerDescriptor25,
      crossRunSource: Optional(TCrossRunSource22)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification32),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath30)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult59)),
  whiteoutLayer: Optional(TLayerWithManifest59),
  outputLayers: Optional(Array2(TLayerWithManifest59)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey57) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem59)),
  testResults: Optional(Array2(TTestResults59)),
  artifacts: Optional(Array2(TArtifact59)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents22),
  tips: Array2(TTip36),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps51,
  networkTraffic: TNetworkTraffic32,
  outputRetryActions: Array2(TRetryAction48),
  retryAction: Optional(TRetryAction48),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest59),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString60),
  deepRunningExecutableTaskCount: Number2()
});
var TRetryManifestEntry32 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry32 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString60,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString60),
  mostRecentlyAttemptedAt: Optional(TDateString60),
  finishedAt: Optional(TDateString60),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory6
});
var TGraphRoots32 = Object2({ resolution: Array2(TGraphNodeId33), runtime: Array2(TGraphNodeId33) });
var TRunGraph32 = Object2({
  roots: TGraphRoots32,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId33, Array2(TGraphNodeId33)),
    runtime: Record(TGraphNodeId33, Array2(TGraphNodeId33))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId33, Array2(TGraphNodeId33)),
    runtime: Record(TGraphNodeId33, Array2(TGraphNodeId33))
  }),
  subgraphs: Record(TGraphNodeId33, Object2({ roots: TGraphRoots32 })),
  parents: Record(TGraphNodeId33, TGraphNodeId33),
  definitionOrders: Record(TGraphNodeId33, Number2())
});
var TActor32 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState32 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState32)
});
var ApprovalRequestState29 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState29 || {});
var TApprovalRequest29 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState29)
});
var TRun32 = Object2({
  schemaVersion: Literal(ThisSchemaVersion32),
  persistenceExpiresAtSeconds: TEpochSeconds33,
  runId: String2(),
  createdAt: TDateString60,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor32),
  mintDirectoryArtifact: Optional(TArtifact59),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck18),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool32),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration32),
  eventNumber: Number2(),
  retries: Array2(TRetry32),
  approvalRequests: Array2(TApprovalRequest29),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph32,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry32)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey33, TConcurrencyPoolState32),
  baseLayer: Optional(TBaseLayerDescriptor25),
  crossRunSource: TCrossRunSource22,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus32),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus32),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus32),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus32),
  resultStatus: Enum(RunResultStatus32),
  waitingForLeaseAt: Optional(TDateString60),
  waitingForManualStartAt: Optional(TDateString60),
  startedAt: Optional(TDateString60),
  cancellationRequestedAt: Optional(TDateString60),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString60),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v70.ts
var ThisSchemaVersion33 = "v70" /* V70 */;
var TTaskOrGroupId61 = TBrandedString();
var TGraphNodeId34 = TBrandedString();
var TTemplateString34 = TBrandedString();
var TEvaluatedString34 = TBrandedString();
var TDateString61 = TBrandedString();
var TEpochSeconds34 = TBrandedNumber();
var TScopedTaskKey34 = TBrandedString();
var TaskType33 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType33 || {});
var TaskResultStatus33 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus33 || {});
var TaskExecutionStatus33 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus33 || {});
var TaskExecutionWaitingSubStatus33 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus33 || {});
var TaskExecutionAbortedSubStatus33 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus33 || {});
var TaskExecutionFinishedSubStatus33 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus33 || {});
var TaskAttemptReason33 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason33 || {});
var BackgroundProcessResultStatus60 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus60 || {});
var BackgroundProcessResultFinishedSubStatus60 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus60 || {});
var RunResultStatus33 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus33 || {});
var RunExecutionStatus33 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus33 || {});
var RunExecutionWaitingSubStatus33 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus33 || {});
var RunExecutionAbortedSubStatus33 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus33 || {});
var RunExecutionFinishedSubStatus33 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus33 || {});
var TSource33 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey58 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey58 || {});
var TExpandedEnvDescriptor33 = Object2({ value: Optional(TTemplateString34), cacheKey: Enum(EnvironmentVariableCacheKey58) });
var TEnvMergeStrategy33 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath60 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern60 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity60 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity60 || {});
var TProblemMatcher60 = Object2({ owner: String2(), severity: Optional(Enum(Severity60)), pattern: Array2(TProblemMatcherPattern60) });
var TProblemPath60 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath33 = Object2({ key: String2(), path: TTemplateString34 });
var TResolvedArtifactPath31 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck33 = Object2({ run: TTemplateString34, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess33 = Object2({
  key: String2(),
  command: TTemplateString34,
  readyCheck: Optional(TExpandedReadyCheck33),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType33 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType33 || {});
var TParallelismValue33 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification33 = Object2({
  cpus: Optional(TTemplateString34),
  memory: Optional(TTemplateString34),
  disk: Object2({ size: Optional(TTemplateString34) }),
  staticIps: Optional(TTemplateString34),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification33 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs33 = Object2({
  values: Optional(Record(String2(), TTemplateString34)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor24 = Object2({ path: TTemplateString34, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor24 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet24 = Union([TTemplateString34, Array2(Union([TTemplateString34, TFilterDescriptor24]))]);
var TInputFilesystemFilter33 = Object2({
  workspace: Optional(TFilterSet24),
  artifacts: Optional(Record(TTemplateString34, TFilterSet24))
});
var TOutputFilesystemFilter33 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration26 = Object2({
  enabled: TTemplateString34,
  ttl: Optional(TTemplateString34)
});
var TTaskDefinitionWithoutParallel33 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification33),
  type: Optional(Enum(TaskType33)),
  after: Optional(TTemplateString34),
  if: Optional(TTemplateString34),
  source: Optional(TSource33),
  cacheConfiguration: TCacheConfiguration26,
  docker: Optional(TTemplateString34),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString34),
  filter: Optional(TInputFilesystemFilter33),
  backgroundProcesses: Optional(Array2(TBackgroundProcess33)),
  toolCache: Optional(TTemplateString34),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor33)),
  envMerge: Optional(Array2(TEnvMergeStrategy33)),
  timeout: Optional(TTemplateString34),
  healthTimeout: Optional(TTemplateString34),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath60)),
  artifactPaths: Optional(Array2(TArtifactPath33)),
  outputs: Optional(TTaskDefinitionOutputs33),
  problemMatchers: Optional(Array2(TProblemMatcher60)),
  problemPaths: Optional(Array2(TProblemPath60)),
  parallelismType: Optional(Enum(ParallelismType33)),
  parallelismValue: Optional(TParallelismValue33),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString34)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString34),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter33),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString34,
      if: Optional(TTemplateString34),
      action: Optional(TTemplateString34)
    })
  )
});
var TCrossRunSource23 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents23 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource23,
  relativeScopedKey: String2()
});
var TTaskDefinition33 = Composite([
  TTaskDefinitionWithoutParallel33,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel33),
    parallelKey: Optional(TTemplateString34),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString34), TTemplateString34]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString34)), TTemplateString34])),
    parallelismTotal: Optional(TTemplateString34)
  })
]);
var TLayerWithManifest60 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId61,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext33 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret33 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess33 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString34,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString34,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult60 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus60),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus60),
  startedAt: Optional(TDateString61),
  completedAt: Optional(TDateString61),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem60 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity60),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary27 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults60 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary27),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest50 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact60 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest50, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact33 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor24)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor24))
      })
    )
  )
});
var TGithubStatusCheck19 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration33 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow33 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow33 || {});
var TConcurrencyPool33 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow33) });
var LeaseState33 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState33 || {});
var TTiming52 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps52 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming52)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming52),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming52),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming52.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming52),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming52),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming52),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming52),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming52),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming52),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming52),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming52)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming52.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic33 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction49 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact60)
});
var TBaseLayerSpecificationTriple26 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"])
});
var TBaseLayerSpecificationLayerId26 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification26 = Union([TBaseLayerSpecificationTriple26, TBaseLayerSpecificationLayerId26]);
var TBaseLayerDescriptor26 = Composite([
  TBaseLayerSpecificationTriple26,
  TBaseLayerSpecificationLayerId26,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit26 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit26 || {});
var TTTL26 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit26)
});
var TResolvedWriteCacheConfiguration11 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL26, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration11 = Object2({
  enabled: Boolean2()
});
var TTip37 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory7 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask33 = Object2({
  schemaVersion: Literal(ThisSchemaVersion33),
  taskId: TTaskOrGroupId61,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId34),
  generatorTaskId: Optional(TTaskOrGroupId61),
  definition: TTaskDefinition33,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus33),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus33),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus33),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus33),
  resultStatus: Enum(TaskResultStatus33),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason33)),
  attemptCounts: Record(TRetryCategory7, Number2()),
  resolvedAt: Optional(TDateString61),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString61),
  debugReadyAt: Optional(TDateString61),
  debugStartedAt: Optional(TDateString61),
  debugEndedAt: Optional(TDateString61),
  cancellationRequestedAt: Optional(TDateString61),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString61),
  cancelledAt: Optional(TDateString61),
  concurrencyPool: Optional(TConcurrencyPool33),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext33),
  usedSecrets: Optional(Array2(TUsedSecret33)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration11),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration11),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString34, cacheKey: Enum(EnvironmentVariableCacheKey58) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString34),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess33)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact33)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest60)),
  previousLayers: Optional(Array2(TLayerWithManifest60)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest60)),
  filesystemLayers: Optional(Array2(TLayerWithManifest60)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString34)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration33),
      baseLayer: TBaseLayerDescriptor26,
      crossRunSource: Optional(TCrossRunSource23)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification33),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath31)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult60)),
  whiteoutLayer: Optional(TLayerWithManifest60),
  outputLayers: Optional(Array2(TLayerWithManifest60)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey58) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem60)),
  testResults: Optional(Array2(TTestResults60)),
  artifacts: Optional(Array2(TArtifact60)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents23),
  tips: Array2(TTip37),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps52,
  networkTraffic: TNetworkTraffic33,
  outputRetryActions: Array2(TRetryAction49),
  retryAction: Optional(TRetryAction49),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest60),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString61),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry33 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry33 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString61,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString61),
  mostRecentlyAttemptedAt: Optional(TDateString61),
  finishedAt: Optional(TDateString61),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory7
});
var TGraphRoots33 = Object2({ resolution: Array2(TGraphNodeId34), runtime: Array2(TGraphNodeId34) });
var TRunGraph33 = Object2({
  roots: TGraphRoots33,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId34, Array2(TGraphNodeId34)),
    runtime: Record(TGraphNodeId34, Array2(TGraphNodeId34))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId34, Array2(TGraphNodeId34)),
    runtime: Record(TGraphNodeId34, Array2(TGraphNodeId34))
  }),
  subgraphs: Record(TGraphNodeId34, Object2({ roots: TGraphRoots33 })),
  parents: Record(TGraphNodeId34, TGraphNodeId34),
  definitionOrders: Record(TGraphNodeId34, Number2())
});
var TActor33 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState33 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState33)
});
var ApprovalRequestState30 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState30 || {});
var TApprovalRequest30 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState30)
});
var TRun33 = Object2({
  schemaVersion: Literal(ThisSchemaVersion33),
  persistenceExpiresAtSeconds: TEpochSeconds34,
  runId: String2(),
  createdAt: TDateString61,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor33),
  mintDirectoryArtifact: Optional(TArtifact60),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck19),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool33),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration33),
  eventNumber: Number2(),
  retries: Array2(TRetry33),
  approvalRequests: Array2(TApprovalRequest30),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph33,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry33)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey34, TConcurrencyPoolState33),
  baseLayer: Optional(TBaseLayerDescriptor26),
  crossRunSource: TCrossRunSource23,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus33),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus33),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus33),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus33),
  resultStatus: Enum(RunResultStatus33),
  waitingForLeaseAt: Optional(TDateString61),
  waitingForManualStartAt: Optional(TDateString61),
  startedAt: Optional(TDateString61),
  cancellationRequestedAt: Optional(TDateString61),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString61),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v71.ts
var ThisSchemaVersion34 = "v71" /* V71 */;
var TTaskOrGroupId62 = TBrandedString();
var TGraphNodeId35 = TBrandedString();
var TTemplateString35 = TBrandedString();
var TEvaluatedString35 = TBrandedString();
var TDateString62 = TBrandedString();
var TEpochSeconds35 = TBrandedNumber();
var TScopedTaskKey35 = TBrandedString();
var TaskType34 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType34 || {});
var TaskResultStatus34 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus34 || {});
var TaskExecutionStatus34 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus34 || {});
var TaskExecutionWaitingSubStatus34 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus34 || {});
var TaskExecutionAbortedSubStatus34 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus34 || {});
var TaskExecutionFinishedSubStatus34 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus34 || {});
var TaskAttemptReason34 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason34 || {});
var BackgroundProcessResultStatus61 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus61 || {});
var BackgroundProcessResultFinishedSubStatus61 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus61 || {});
var RunResultStatus34 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus34 || {});
var RunExecutionStatus34 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus34 || {});
var RunExecutionWaitingSubStatus34 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus34 || {});
var RunExecutionAbortedSubStatus34 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus34 || {});
var RunExecutionFinishedSubStatus34 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus34 || {});
var TSource34 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey59 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey59 || {});
var TExpandedEnvDescriptor34 = Object2({ value: Optional(TTemplateString35), cacheKey: Enum(EnvironmentVariableCacheKey59) });
var TEnvMergeStrategy34 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath61 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern61 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity61 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity61 || {});
var TProblemMatcher61 = Object2({ owner: String2(), severity: Optional(Enum(Severity61)), pattern: Array2(TProblemMatcherPattern61) });
var TProblemPath61 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath34 = Object2({ key: String2(), path: TTemplateString35 });
var TResolvedArtifactPath32 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck34 = Object2({ run: TTemplateString35, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess34 = Object2({
  key: String2(),
  command: TTemplateString35,
  readyCheck: Optional(TExpandedReadyCheck34),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType34 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType34 || {});
var TParallelismValue34 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification34 = Object2({
  cpus: Optional(TTemplateString35),
  memory: Optional(TTemplateString35),
  disk: Object2({ size: Optional(TTemplateString35) }),
  staticIps: Optional(TTemplateString35),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification34 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs34 = Object2({
  values: Optional(Record(String2(), TTemplateString35)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor25 = Object2({ path: TTemplateString35, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor25 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet25 = Union([TTemplateString35, Array2(Union([TTemplateString35, TFilterDescriptor25]))]);
var TInputFilesystemFilter34 = Object2({
  workspace: Optional(TFilterSet25),
  artifacts: Optional(Record(TTemplateString35, TFilterSet25))
});
var TOutputFilesystemFilter34 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration27 = Object2({
  enabled: TTemplateString35,
  ttl: Optional(TTemplateString35)
});
var TTaskDefinitionWithoutParallel34 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification34),
  type: Optional(Enum(TaskType34)),
  after: Optional(TTemplateString35),
  if: Optional(TTemplateString35),
  source: Optional(TSource34),
  cacheConfiguration: TCacheConfiguration27,
  docker: Optional(TTemplateString35),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString35),
  filter: Optional(TInputFilesystemFilter34),
  backgroundProcesses: Optional(Array2(TBackgroundProcess34)),
  toolCache: Optional(TTemplateString35),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor34)),
  envMerge: Optional(Array2(TEnvMergeStrategy34)),
  timeout: Optional(TTemplateString35),
  healthTimeout: Optional(TTemplateString35),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath61)),
  artifactPaths: Optional(Array2(TArtifactPath34)),
  outputs: Optional(TTaskDefinitionOutputs34),
  problemMatchers: Optional(Array2(TProblemMatcher61)),
  problemPaths: Optional(Array2(TProblemPath61)),
  parallelismType: Optional(Enum(ParallelismType34)),
  parallelismValue: Optional(TParallelismValue34),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString35)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString35),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter34),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString35,
      if: Optional(TTemplateString35),
      action: Optional(TTemplateString35)
    })
  )
});
var TCrossRunSource24 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents24 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource24,
  relativeScopedKey: String2()
});
var TTaskDefinition34 = Composite([
  TTaskDefinitionWithoutParallel34,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel34),
    parallelKey: Optional(TTemplateString35),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString35), TTemplateString35]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString35)), TTemplateString35])),
    parallelismTotal: Optional(TTemplateString35)
  })
]);
var TLayerWithManifest61 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId62,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext34 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret34 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess34 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString35,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString35,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult61 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus61),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus61),
  startedAt: Optional(TDateString62),
  completedAt: Optional(TDateString62),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem61 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity61),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary28 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults61 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary28),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest51 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact61 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest51, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact34 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor25)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor25))
      })
    )
  )
});
var TGithubStatusCheck20 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration34 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow34 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow34 || {});
var TConcurrencyPool34 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow34) });
var LeaseState34 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState34 || {});
var TTiming53 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps53 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming53)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming53),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming53),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming53.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming53),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming53),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming53),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming53),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming53),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming53),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming53),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming53)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming53.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic34 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction50 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact61)
});
var TBaseLayer8 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2(),
    uid: Number2(),
    gid: Number2()
  }),
  group: Object2({
    name: String2(),
    gid: Number2()
  })
});
var TResolvedBaseConfig2 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer8
});
var TTLUnit27 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit27 || {});
var TTTL27 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit27)
});
var TResolvedWriteCacheConfiguration12 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL27, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration12 = Object2({
  enabled: Boolean2()
});
var TTip38 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory8 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask34 = Object2({
  schemaVersion: Literal(ThisSchemaVersion34),
  taskId: TTaskOrGroupId62,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId35),
  generatorTaskId: Optional(TTaskOrGroupId62),
  definition: TTaskDefinition34,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus34),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus34),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus34),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus34),
  resultStatus: Enum(TaskResultStatus34),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason34)),
  attemptCounts: Record(TRetryCategory8, Number2()),
  resolvedAt: Optional(TDateString62),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString62),
  debugReadyAt: Optional(TDateString62),
  debugStartedAt: Optional(TDateString62),
  debugEndedAt: Optional(TDateString62),
  cancellationRequestedAt: Optional(TDateString62),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString62),
  cancelledAt: Optional(TDateString62),
  concurrencyPool: Optional(TConcurrencyPool34),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext34),
  usedSecrets: Optional(Array2(TUsedSecret34)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration12),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration12),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString35, cacheKey: Enum(EnvironmentVariableCacheKey59) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString35),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess34)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact34)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest61)),
  previousLayers: Optional(Array2(TLayerWithManifest61)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest61)),
  filesystemLayers: Optional(Array2(TLayerWithManifest61)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString35)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration34),
      baseConfig: TResolvedBaseConfig2,
      crossRunSource: Optional(TCrossRunSource24)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification34),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath32)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult61)),
  whiteoutLayer: Optional(TLayerWithManifest61),
  outputLayers: Optional(Array2(TLayerWithManifest61)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey59) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem61)),
  testResults: Optional(Array2(TTestResults61)),
  artifacts: Optional(Array2(TArtifact61)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents24),
  tips: Array2(TTip38),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps53,
  networkTraffic: TNetworkTraffic34,
  outputRetryActions: Array2(TRetryAction50),
  retryAction: Optional(TRetryAction50),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest61),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString62),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry34 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry34 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString62,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString62),
  mostRecentlyAttemptedAt: Optional(TDateString62),
  finishedAt: Optional(TDateString62),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory8
});
var TGraphRoots34 = Object2({ resolution: Array2(TGraphNodeId35), runtime: Array2(TGraphNodeId35) });
var TRunGraph34 = Object2({
  roots: TGraphRoots34,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId35, Array2(TGraphNodeId35)),
    runtime: Record(TGraphNodeId35, Array2(TGraphNodeId35))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId35, Array2(TGraphNodeId35)),
    runtime: Record(TGraphNodeId35, Array2(TGraphNodeId35))
  }),
  subgraphs: Record(TGraphNodeId35, Object2({ roots: TGraphRoots34 })),
  parents: Record(TGraphNodeId35, TGraphNodeId35),
  definitionOrders: Record(TGraphNodeId35, Number2())
});
var TActor34 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState34 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState34)
});
var ApprovalRequestState31 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState31 || {});
var TApprovalRequest31 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState31)
});
var TRun34 = Object2({
  schemaVersion: Literal(ThisSchemaVersion34),
  persistenceExpiresAtSeconds: TEpochSeconds35,
  runId: String2(),
  createdAt: TDateString62,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor34),
  mintDirectoryArtifact: Optional(TArtifact61),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck20),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool34),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration34),
  eventNumber: Number2(),
  retries: Array2(TRetry34),
  approvalRequests: Array2(TApprovalRequest31),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph34,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry34)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey35, TConcurrencyPoolState34),
  baseConfig: Optional(TResolvedBaseConfig2),
  crossRunSource: TCrossRunSource24,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus34),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus34),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus34),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus34),
  resultStatus: Enum(RunResultStatus34),
  waitingForLeaseAt: Optional(TDateString62),
  waitingForManualStartAt: Optional(TDateString62),
  startedAt: Optional(TDateString62),
  cancellationRequestedAt: Optional(TDateString62),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString62),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v72.ts
var ThisSchemaVersion35 = "v72" /* V72 */;
var TTaskOrGroupId63 = TBrandedString();
var TGraphNodeId36 = TBrandedString();
var TTemplateString36 = TBrandedString();
var TEvaluatedString36 = TBrandedString();
var TDateString63 = TBrandedString();
var TEpochSeconds36 = TBrandedNumber();
var TScopedTaskKey36 = TBrandedString();
var TaskType35 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType35 || {});
var TaskResultStatus35 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus35 || {});
var TaskExecutionStatus35 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus35 || {});
var TaskExecutionWaitingSubStatus35 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus35 || {});
var TaskExecutionAbortedSubStatus35 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus35 || {});
var TaskExecutionFinishedSubStatus35 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus35 || {});
var TaskAttemptReason35 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason35 || {});
var BackgroundProcessResultStatus62 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus62 || {});
var BackgroundProcessResultFinishedSubStatus62 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus62 || {});
var RunResultStatus35 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus35 || {});
var RunExecutionStatus35 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus35 || {});
var RunExecutionWaitingSubStatus35 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus35 || {});
var RunExecutionAbortedSubStatus35 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus35 || {});
var RunExecutionFinishedSubStatus35 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus35 || {});
var TSource35 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey60 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey60 || {});
var TExpandedEnvDescriptor35 = Object2({ value: Optional(TTemplateString36), cacheKey: Enum(EnvironmentVariableCacheKey60) });
var TEnvMergeStrategy35 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath62 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern62 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity62 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity62 || {});
var TProblemMatcher62 = Object2({ owner: String2(), severity: Optional(Enum(Severity62)), pattern: Array2(TProblemMatcherPattern62) });
var TProblemPath62 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath35 = Object2({ key: String2(), path: TTemplateString36 });
var TResolvedArtifactPath33 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck35 = Object2({ run: TTemplateString36, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess35 = Object2({
  key: String2(),
  command: TTemplateString36,
  readyCheck: Optional(TExpandedReadyCheck35),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType35 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType35 || {});
var TParallelismValue35 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification35 = Object2({
  cpus: Optional(TTemplateString36),
  memory: Optional(TTemplateString36),
  disk: Object2({ size: Optional(TTemplateString36) }),
  staticIps: Optional(TTemplateString36),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification35 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs35 = Object2({
  values: Optional(Record(String2(), TTemplateString36)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor26 = Object2({ path: TTemplateString36, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor26 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet26 = Union([TTemplateString36, Array2(Union([TTemplateString36, TFilterDescriptor26]))]);
var TInputFilesystemFilter35 = Object2({
  workspace: Optional(TFilterSet26),
  artifacts: Optional(Record(TTemplateString36, TFilterSet26))
});
var TOutputFilesystemFilter35 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration28 = Object2({
  enabled: TTemplateString36,
  ttl: Optional(TTemplateString36)
});
var TTaskDefinitionWithoutParallel35 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification35),
  type: Optional(Enum(TaskType35)),
  after: Optional(TTemplateString36),
  if: Optional(TTemplateString36),
  source: Optional(TSource35),
  cacheConfiguration: TCacheConfiguration28,
  docker: Optional(TTemplateString36),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString36),
  filter: Optional(TInputFilesystemFilter35),
  backgroundProcesses: Optional(Array2(TBackgroundProcess35)),
  toolCache: Optional(TTemplateString36),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor35)),
  envMerge: Optional(Array2(TEnvMergeStrategy35)),
  timeout: Optional(TTemplateString36),
  healthTimeout: Optional(TTemplateString36),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath62)),
  artifactPaths: Optional(Array2(TArtifactPath35)),
  outputs: Optional(TTaskDefinitionOutputs35),
  problemMatchers: Optional(Array2(TProblemMatcher62)),
  problemPaths: Optional(Array2(TProblemPath62)),
  parallelismType: Optional(Enum(ParallelismType35)),
  parallelismValue: Optional(TParallelismValue35),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString36)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString36),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter35),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString36,
      if: Optional(TTemplateString36),
      action: Optional(TTemplateString36)
    })
  )
});
var TCrossRunSource25 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents25 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource25,
  relativeScopedKey: String2()
});
var TTaskDefinition35 = Composite([
  TTaskDefinitionWithoutParallel35,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel35),
    parallelKey: Optional(TTemplateString36),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString36), TTemplateString36]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString36)), TTemplateString36])),
    parallelismTotal: Optional(TTemplateString36)
  })
]);
var TLayerWithManifest62 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId63,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext35 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret35 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess35 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString36,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString36,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult62 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus62),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus62),
  startedAt: Optional(TDateString63),
  completedAt: Optional(TDateString63),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem62 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity62),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary29 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults62 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary29),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest52 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact62 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest52, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact35 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor26)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor26))
      })
    )
  )
});
var TGithubStatusCheck21 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration35 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow35 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow35 || {});
var TConcurrencyPool35 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow35) });
var LeaseState35 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState35 || {});
var TTiming54 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps54 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming54)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming54),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming54),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming54.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming54),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming54),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming54),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming54),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming54),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming54),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming54),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming54)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming54.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic35 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction51 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact62)
});
var TBaseLayer9 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2(),
    uid: Number2(),
    gid: Number2()
  }),
  group: Object2({
    name: String2(),
    gid: Number2()
  })
});
var TResolvedBaseConfig3 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer9
});
var TTLUnit28 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit28 || {});
var TTTL28 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit28)
});
var TResolvedWriteCacheConfiguration13 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL28, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration13 = Object2({
  enabled: Boolean2()
});
var TTip39 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory9 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask35 = Object2({
  schemaVersion: Literal(ThisSchemaVersion35),
  taskId: TTaskOrGroupId63,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId36),
  generatorTaskId: Optional(TTaskOrGroupId63),
  definition: TTaskDefinition35,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus35),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus35),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus35),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus35),
  resultStatus: Enum(TaskResultStatus35),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason35)),
  attemptCounts: Record(TRetryCategory9, Number2()),
  resolvedAt: Optional(TDateString63),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString63),
  debugReadyAt: Optional(TDateString63),
  debugStartedAt: Optional(TDateString63),
  debugEndedAt: Optional(TDateString63),
  cancellationRequestedAt: Optional(TDateString63),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString63),
  cancelledAt: Optional(TDateString63),
  concurrencyPool: Optional(TConcurrencyPool35),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext35),
  usedSecrets: Optional(Array2(TUsedSecret35)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration13),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration13),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString36, cacheKey: Enum(EnvironmentVariableCacheKey60) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString36),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess35)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact35)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest62)),
  previousLayers: Optional(Array2(TLayerWithManifest62)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest62)),
  filesystemLayers: Optional(Array2(TLayerWithManifest62)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString36)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration35),
      baseConfig: TResolvedBaseConfig3,
      crossRunSource: Optional(TCrossRunSource25)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification35),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath33)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult62)),
  whiteoutLayer: Optional(TLayerWithManifest62),
  outputLayers: Optional(Array2(TLayerWithManifest62)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey60) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem62)),
  testResults: Optional(Array2(TTestResults62)),
  artifacts: Optional(Array2(TArtifact62)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents25),
  tips: Array2(TTip39),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps54,
  networkTraffic: TNetworkTraffic35,
  outputRetryActions: Array2(TRetryAction51),
  retryAction: Optional(TRetryAction51),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest62),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString63),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry35 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry35 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString63,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString63),
  mostRecentlyAttemptedAt: Optional(TDateString63),
  finishedAt: Optional(TDateString63),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory9
});
var TGraphRoots35 = Object2({ resolution: Array2(TGraphNodeId36), runtime: Array2(TGraphNodeId36) });
var TRunGraph35 = Object2({
  roots: TGraphRoots35,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId36, Array2(TGraphNodeId36)),
    runtime: Record(TGraphNodeId36, Array2(TGraphNodeId36))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId36, Array2(TGraphNodeId36)),
    runtime: Record(TGraphNodeId36, Array2(TGraphNodeId36))
  }),
  subgraphs: Record(TGraphNodeId36, Object2({ roots: TGraphRoots35 })),
  parents: Record(TGraphNodeId36, TGraphNodeId36),
  definitionOrders: Record(TGraphNodeId36, Number2())
});
var TActor35 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState35 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState35)
});
var ApprovalRequestState32 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState32 || {});
var TApprovalRequest32 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState32)
});
var TRun35 = Object2({
  schemaVersion: Literal(ThisSchemaVersion35),
  persistenceExpiresAtSeconds: TEpochSeconds36,
  runId: String2(),
  createdAt: TDateString63,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor35),
  mintDirectoryArtifact: Optional(TArtifact62),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck21),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  statusChecksEnabled: Boolean2(),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool35),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration35),
  eventNumber: Number2(),
  retries: Array2(TRetry35),
  approvalRequests: Array2(TApprovalRequest32),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph35,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry35)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey36, TConcurrencyPoolState35),
  baseConfig: Optional(TResolvedBaseConfig3),
  crossRunSource: TCrossRunSource25,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus35),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus35),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus35),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus35),
  resultStatus: Enum(RunResultStatus35),
  waitingForLeaseAt: Optional(TDateString63),
  waitingForManualStartAt: Optional(TDateString63),
  startedAt: Optional(TDateString63),
  cancellationRequestedAt: Optional(TDateString63),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString63),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v73.ts
var ThisSchemaVersion36 = "v73" /* V73 */;
var TTaskOrGroupId64 = TBrandedString();
var TGraphNodeId37 = TBrandedString();
var TTemplateString37 = TBrandedString();
var TEvaluatedString37 = TBrandedString();
var TDateString64 = TBrandedString();
var TEpochSeconds37 = TBrandedNumber();
var TScopedTaskKey37 = TBrandedString();
var TaskType36 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType36 || {});
var TaskResultStatus36 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus36 || {});
var TaskExecutionStatus36 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus36 || {});
var TaskExecutionWaitingSubStatus36 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus36 || {});
var TaskExecutionAbortedSubStatus36 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus36 || {});
var TaskExecutionFinishedSubStatus36 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus36 || {});
var TaskAttemptReason36 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason36 || {});
var BackgroundProcessResultStatus63 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus63 || {});
var BackgroundProcessResultFinishedSubStatus63 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus63 || {});
var RunResultStatus36 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus36 || {});
var RunExecutionStatus36 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus36 || {});
var RunExecutionWaitingSubStatus36 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus36 || {});
var RunExecutionAbortedSubStatus36 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus36 || {});
var RunExecutionFinishedSubStatus36 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus36 || {});
var TSource36 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey61 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey61 || {});
var TExpandedEnvDescriptor36 = Object2({ value: Optional(TTemplateString37), cacheKey: Enum(EnvironmentVariableCacheKey61) });
var TEnvMergeStrategy36 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath63 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern63 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity63 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity63 || {});
var TProblemMatcher63 = Object2({ owner: String2(), severity: Optional(Enum(Severity63)), pattern: Array2(TProblemMatcherPattern63) });
var TProblemPath63 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath36 = Object2({ key: String2(), path: TTemplateString37 });
var TResolvedArtifactPath34 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck36 = Object2({ run: TTemplateString37, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess36 = Object2({
  key: String2(),
  command: TTemplateString37,
  readyCheck: Optional(TExpandedReadyCheck36),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType36 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType36 || {});
var TParallelismValue36 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification36 = Object2({
  cpus: Optional(TTemplateString37),
  memory: Optional(TTemplateString37),
  disk: Object2({ size: Optional(TTemplateString37) }),
  staticIps: Optional(TTemplateString37),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification36 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs36 = Object2({
  values: Optional(Record(String2(), TTemplateString37)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor27 = Object2({ path: TTemplateString37, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor27 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet27 = Union([TTemplateString37, Array2(Union([TTemplateString37, TFilterDescriptor27]))]);
var TInputFilesystemFilter36 = Object2({
  workspace: Optional(TFilterSet27),
  artifacts: Optional(Record(TTemplateString37, TFilterSet27))
});
var TOutputFilesystemFilter36 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration29 = Object2({
  enabled: TTemplateString37,
  ttl: Optional(TTemplateString37)
});
var TTaskDefinitionWithoutParallel36 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification36),
  type: Optional(Enum(TaskType36)),
  after: Optional(TTemplateString37),
  if: Optional(TTemplateString37),
  source: Optional(TSource36),
  cacheConfiguration: TCacheConfiguration29,
  docker: Optional(TTemplateString37),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString37),
  filter: Optional(TInputFilesystemFilter36),
  backgroundProcesses: Optional(Array2(TBackgroundProcess36)),
  toolCache: Optional(TTemplateString37),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor36)),
  envMerge: Optional(Array2(TEnvMergeStrategy36)),
  timeout: Optional(TTemplateString37),
  healthTimeout: Optional(TTemplateString37),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath63)),
  artifactPaths: Optional(Array2(TArtifactPath36)),
  outputs: Optional(TTaskDefinitionOutputs36),
  problemMatchers: Optional(Array2(TProblemMatcher63)),
  problemPaths: Optional(Array2(TProblemPath63)),
  parallelismType: Optional(Enum(ParallelismType36)),
  parallelismValue: Optional(TParallelismValue36),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString37)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString37),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter36),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString37,
      if: Optional(TTemplateString37),
      action: Optional(TTemplateString37)
    })
  )
});
var TCrossRunSource26 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents26 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource26,
  relativeScopedKey: String2()
});
var TTaskDefinition36 = Composite([
  TTaskDefinitionWithoutParallel36,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel36),
    parallelKey: Optional(TTemplateString37),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString37), TTemplateString37]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString37)), TTemplateString37])),
    parallelismTotal: Optional(TTemplateString37)
  })
]);
var TLayerWithManifest63 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId64,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext36 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret36 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess36 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString37,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString37,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult63 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus63),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus63),
  startedAt: Optional(TDateString64),
  completedAt: Optional(TDateString64),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem63 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity63),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary30 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults63 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary30),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest53 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact63 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest53, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact36 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor27)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor27))
      })
    )
  )
});
var TGithubStatusCheck22 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration36 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow36 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow36 || {});
var TConcurrencyPool36 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow36) });
var LeaseState36 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState36 || {});
var TTiming55 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps55 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming55)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming55),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming55),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming55.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming55),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming55),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming55),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming55),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming55),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming55),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming55),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming55)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming55.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic36 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction52 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact63)
});
var TBaseLayer10 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2(),
    uid: Number2(),
    gid: Number2()
  }),
  group: Object2({
    name: String2(),
    gid: Number2()
  })
});
var TResolvedBaseConfig4 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer10
});
var TTLUnit29 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit29 || {});
var TTTL29 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit29)
});
var TResolvedWriteCacheConfiguration14 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL29, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration14 = Object2({
  enabled: Boolean2()
});
var TTip40 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory10 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask36 = Object2({
  schemaVersion: Literal(ThisSchemaVersion36),
  taskId: TTaskOrGroupId64,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId37),
  generatorTaskId: Optional(TTaskOrGroupId64),
  definition: TTaskDefinition36,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus36),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus36),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus36),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus36),
  resultStatus: Enum(TaskResultStatus36),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason36)),
  attemptCounts: Record(TRetryCategory10, Number2()),
  resolvedAt: Optional(TDateString64),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString64),
  debugReadyAt: Optional(TDateString64),
  debugStartedAt: Optional(TDateString64),
  debugEndedAt: Optional(TDateString64),
  cancellationRequestedAt: Optional(TDateString64),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString64),
  cancelledAt: Optional(TDateString64),
  concurrencyPool: Optional(TConcurrencyPool36),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext36),
  usedSecrets: Optional(Array2(TUsedSecret36)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration14),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration14),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString37, cacheKey: Enum(EnvironmentVariableCacheKey61) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString37),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess36)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact36)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest63)),
  previousLayers: Optional(Array2(TLayerWithManifest63)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest63)),
  filesystemLayers: Optional(Array2(TLayerWithManifest63)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString37)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration36),
      baseConfig: TResolvedBaseConfig4,
      crossRunSource: Optional(TCrossRunSource26)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification36),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath34)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult63)),
  whiteoutLayer: Optional(TLayerWithManifest63),
  outputLayers: Optional(Array2(TLayerWithManifest63)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey61) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem63)),
  testResults: Optional(Array2(TTestResults63)),
  artifacts: Optional(Array2(TArtifact63)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents26),
  tips: Array2(TTip40),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps55,
  networkTraffic: TNetworkTraffic36,
  outputRetryActions: Array2(TRetryAction52),
  retryAction: Optional(TRetryAction52),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest63),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString64),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry36 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry36 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString64,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString64),
  mostRecentlyAttemptedAt: Optional(TDateString64),
  finishedAt: Optional(TDateString64),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory10
});
var TGraphRoots36 = Object2({ resolution: Array2(TGraphNodeId37), runtime: Array2(TGraphNodeId37) });
var TRunGraph36 = Object2({
  roots: TGraphRoots36,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId37, Array2(TGraphNodeId37)),
    runtime: Record(TGraphNodeId37, Array2(TGraphNodeId37))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId37, Array2(TGraphNodeId37)),
    runtime: Record(TGraphNodeId37, Array2(TGraphNodeId37))
  }),
  subgraphs: Record(TGraphNodeId37, Object2({ roots: TGraphRoots36 })),
  parents: Record(TGraphNodeId37, TGraphNodeId37),
  definitionOrders: Record(TGraphNodeId37, Number2())
});
var TActor36 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState36 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState36)
});
var ApprovalRequestState33 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState33 || {});
var TApprovalRequest33 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState33)
});
var TRun36 = Object2({
  schemaVersion: Literal(ThisSchemaVersion36),
  persistenceExpiresAtSeconds: TEpochSeconds37,
  runId: String2(),
  createdAt: TDateString64,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor36),
  mintDirectoryArtifact: Optional(TArtifact63),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck22),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  statusChecksEnabled: Boolean2(),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool36),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration36),
  eventNumber: Number2(),
  retries: Array2(TRetry36),
  approvalRequests: Array2(TApprovalRequest33),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph36,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry36)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey37, TConcurrencyPoolState36),
  baseConfig: Optional(TResolvedBaseConfig4),
  crossRunSource: TCrossRunSource26,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus36),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus36),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus36),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus36),
  resultStatus: Enum(RunResultStatus36),
  waitingForLeaseAt: Optional(TDateString64),
  waitingForManualStartAt: Optional(TDateString64),
  startedAt: Optional(TDateString64),
  cancellationRequestedAt: Optional(TDateString64),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString64),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v74.ts
var ThisSchemaVersion37 = "v74" /* V74 */;
var TTaskOrGroupId65 = TBrandedString();
var TGraphNodeId38 = TBrandedString();
var TTemplateString38 = TBrandedString();
var TEvaluatedString38 = TBrandedString();
var TDateString65 = TBrandedString();
var TEpochSeconds38 = TBrandedNumber();
var TScopedTaskKey38 = TBrandedString();
var TaskType37 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType37 || {});
var TaskResultStatus37 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus37 || {});
var TaskExecutionStatus37 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus37 || {});
var TaskExecutionWaitingSubStatus37 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus37 || {});
var TaskExecutionAbortedSubStatus37 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus37 || {});
var TaskExecutionFinishedSubStatus37 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus37 || {});
var TaskAttemptReason37 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason37 || {});
var BackgroundProcessResultStatus64 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus64 || {});
var BackgroundProcessResultFinishedSubStatus64 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus64 || {});
var RunResultStatus37 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus37 || {});
var RunExecutionStatus37 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus37 || {});
var RunExecutionWaitingSubStatus37 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus37 || {});
var RunExecutionAbortedSubStatus37 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus37 || {});
var RunExecutionFinishedSubStatus37 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus37 || {});
var TSource37 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey62 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey62 || {});
var TExpandedEnvDescriptor37 = Object2({ value: Optional(TTemplateString38), cacheKey: Enum(EnvironmentVariableCacheKey62) });
var TEnvMergeStrategy37 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath64 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern64 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity64 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity64 || {});
var TProblemMatcher64 = Object2({ owner: String2(), severity: Optional(Enum(Severity64)), pattern: Array2(TProblemMatcherPattern64) });
var TProblemPath64 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath37 = Object2({ key: String2(), path: TTemplateString38 });
var TResolvedArtifactPath35 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck37 = Object2({ run: TTemplateString38, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess37 = Object2({
  key: String2(),
  command: TTemplateString38,
  readyCheck: Optional(TExpandedReadyCheck37),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType37 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType37 || {});
var TParallelismValue37 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification37 = Object2({
  cpus: Optional(TTemplateString38),
  memory: Optional(TTemplateString38),
  disk: Object2({ size: Optional(TTemplateString38) }),
  staticIps: Optional(TTemplateString38),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification37 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs37 = Object2({
  values: Optional(Record(String2(), TTemplateString38)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor28 = Object2({ path: TTemplateString38, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor28 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet28 = Union([TTemplateString38, Array2(Union([TTemplateString38, TFilterDescriptor28]))]);
var TInputFilesystemFilter37 = Object2({
  workspace: Optional(TFilterSet28),
  artifacts: Optional(Record(TTemplateString38, TFilterSet28))
});
var TOutputFilesystemFilter37 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration30 = Object2({
  enabled: TTemplateString38,
  ttl: Optional(TTemplateString38)
});
var TTaskDefinitionWithoutParallel37 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification37),
  type: Optional(Enum(TaskType37)),
  after: Optional(TTemplateString38),
  if: Optional(TTemplateString38),
  source: Optional(TSource37),
  cacheConfiguration: TCacheConfiguration30,
  docker: Optional(TTemplateString38),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString38),
  filter: Optional(TInputFilesystemFilter37),
  backgroundProcesses: Optional(Array2(TBackgroundProcess37)),
  toolCache: Optional(TTemplateString38),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor37)),
  envMerge: Optional(Array2(TEnvMergeStrategy37)),
  timeout: Optional(TTemplateString38),
  healthTimeout: Optional(TTemplateString38),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath64)),
  artifactPaths: Optional(Array2(TArtifactPath37)),
  outputs: Optional(TTaskDefinitionOutputs37),
  problemMatchers: Optional(Array2(TProblemMatcher64)),
  problemPaths: Optional(Array2(TProblemPath64)),
  parallelismType: Optional(Enum(ParallelismType37)),
  parallelismValue: Optional(TParallelismValue37),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString38)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString38),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter37),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString38,
      if: Optional(TTemplateString38),
      action: Optional(TTemplateString38)
    })
  )
});
var TCrossRunSource27 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents27 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource27,
  relativeScopedKey: String2()
});
var TTaskDefinition37 = Composite([
  TTaskDefinitionWithoutParallel37,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel37),
    parallelKey: Optional(TTemplateString38),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString38), TTemplateString38]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString38)), TTemplateString38])),
    parallelismTotal: Optional(TTemplateString38)
  })
]);
var TLayerWithManifest64 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId65,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext37 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret37 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess37 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString38,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString38,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult64 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus64),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus64),
  startedAt: Optional(TDateString65),
  completedAt: Optional(TDateString65),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem64 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity64),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary31 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults64 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary31),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest54 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact64 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest54, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact37 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor28)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor28))
      })
    )
  )
});
var TGithubStatusCheck23 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration37 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow37 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow37 || {});
var TConcurrencyPool37 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow37) });
var LeaseState37 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState37 || {});
var TTiming56 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps56 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming56)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming56),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming56),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming56.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming56),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming56),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming56),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming56),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming56),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming56),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming56),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming56)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming56.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic37 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig2 = Object2({
  user: Optional(String2())
});
var TResolvedImageConfig2 = Object2({
  user: Optional(String2())
});
var TRetryAction53 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact64)
});
var TBaseLayer11 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2(),
    uid: Number2(),
    gid: Number2()
  }),
  group: Object2({
    name: String2(),
    gid: Number2()
  })
});
var TResolvedBaseConfig5 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer11
});
var TTLUnit30 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit30 || {});
var TTTL30 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit30)
});
var TResolvedWriteCacheConfiguration15 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL30, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration15 = Object2({
  enabled: Boolean2()
});
var TTip41 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory11 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask37 = Object2({
  schemaVersion: Literal(ThisSchemaVersion37),
  taskId: TTaskOrGroupId65,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId38),
  generatorTaskId: Optional(TTaskOrGroupId65),
  definition: TTaskDefinition37,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus37),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus37),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus37),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus37),
  resultStatus: Enum(TaskResultStatus37),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason37)),
  attemptCounts: Record(TRetryCategory11, Number2()),
  resolvedAt: Optional(TDateString65),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString65),
  debugReadyAt: Optional(TDateString65),
  debugStartedAt: Optional(TDateString65),
  debugEndedAt: Optional(TDateString65),
  cancellationRequestedAt: Optional(TDateString65),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString65),
  cancelledAt: Optional(TDateString65),
  concurrencyPool: Optional(TConcurrencyPool37),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext37),
  usedSecrets: Optional(Array2(TUsedSecret37)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration15),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration15),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString38, cacheKey: Enum(EnvironmentVariableCacheKey62) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString38),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess37)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact37)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest64)),
  previousLayers: Optional(Array2(TLayerWithManifest64)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest64)),
  resolvedImageConfig: Optional(TResolvedImageConfig2),
  filesystemLayers: Optional(Array2(TLayerWithManifest64)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString38)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration37),
      baseConfig: TResolvedBaseConfig5,
      crossRunSource: Optional(TCrossRunSource27)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification37),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath35)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult64)),
  whiteoutLayer: Optional(TLayerWithManifest64),
  outputLayers: Optional(Array2(TLayerWithManifest64)),
  outputImageConfig: Optional(TOutputImageConfig2),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey62) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem64)),
  testResults: Optional(Array2(TTestResults64)),
  artifacts: Optional(Array2(TArtifact64)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents27),
  tips: Array2(TTip41),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps56,
  networkTraffic: TNetworkTraffic37,
  outputRetryActions: Array2(TRetryAction53),
  retryAction: Optional(TRetryAction53),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest64),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString65),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry37 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry37 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString65,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString65),
  mostRecentlyAttemptedAt: Optional(TDateString65),
  finishedAt: Optional(TDateString65),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory11
});
var TGraphRoots37 = Object2({ resolution: Array2(TGraphNodeId38), runtime: Array2(TGraphNodeId38) });
var TRunGraph37 = Object2({
  roots: TGraphRoots37,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId38, Array2(TGraphNodeId38)),
    runtime: Record(TGraphNodeId38, Array2(TGraphNodeId38))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId38, Array2(TGraphNodeId38)),
    runtime: Record(TGraphNodeId38, Array2(TGraphNodeId38))
  }),
  subgraphs: Record(TGraphNodeId38, Object2({ roots: TGraphRoots37 })),
  parents: Record(TGraphNodeId38, TGraphNodeId38),
  definitionOrders: Record(TGraphNodeId38, Number2())
});
var TActor37 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState37 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState37)
});
var ApprovalRequestState34 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState34 || {});
var TApprovalRequest34 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState34)
});
var TRun37 = Object2({
  schemaVersion: Literal(ThisSchemaVersion37),
  persistenceExpiresAtSeconds: TEpochSeconds38,
  runId: String2(),
  createdAt: TDateString65,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor37),
  mintDirectoryArtifact: Optional(TArtifact64),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck23),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  statusChecksEnabled: Boolean2(),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool37),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration37),
  eventNumber: Number2(),
  retries: Array2(TRetry37),
  approvalRequests: Array2(TApprovalRequest34),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph37,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry37)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey38, TConcurrencyPoolState37),
  baseConfig: Optional(TResolvedBaseConfig5),
  crossRunSource: TCrossRunSource27,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus37),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus37),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus37),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus37),
  resultStatus: Enum(RunResultStatus37),
  waitingForLeaseAt: Optional(TDateString65),
  waitingForManualStartAt: Optional(TDateString65),
  startedAt: Optional(TDateString65),
  cancellationRequestedAt: Optional(TDateString65),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString65),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v75.ts
var ThisSchemaVersion38 = "v75" /* V75 */;
var TTaskOrGroupId66 = TBrandedString();
var TGraphNodeId39 = TBrandedString();
var TTemplateString39 = TBrandedString();
var TEvaluatedString39 = TBrandedString();
var TDateString66 = TBrandedString();
var TEpochSeconds39 = TBrandedNumber();
var TScopedTaskKey39 = TBrandedString();
var TaskType38 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType38 || {});
var TaskResultStatus38 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus38 || {});
var TaskExecutionStatus38 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus38 || {});
var TaskExecutionWaitingSubStatus38 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus38 || {});
var TaskExecutionAbortedSubStatus38 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus38 || {});
var TaskExecutionFinishedSubStatus38 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus38 || {});
var TaskAttemptReason38 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason38 || {});
var BackgroundProcessResultStatus65 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus65 || {});
var BackgroundProcessResultFinishedSubStatus65 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus65 || {});
var RunResultStatus38 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus38 || {});
var RunExecutionStatus38 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus38 || {});
var RunExecutionWaitingSubStatus38 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus38 || {});
var RunExecutionAbortedSubStatus38 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus38 || {});
var RunExecutionFinishedSubStatus38 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus38 || {});
var TSource38 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey63 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey63 || {});
var TExpandedEnvDescriptor38 = Object2({ value: Optional(TTemplateString39), cacheKey: Enum(EnvironmentVariableCacheKey63) });
var TEnvMergeStrategy38 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath65 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern65 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity65 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity65 || {});
var TProblemMatcher65 = Object2({ owner: String2(), severity: Optional(Enum(Severity65)), pattern: Array2(TProblemMatcherPattern65) });
var TProblemPath65 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath38 = Object2({ key: String2(), path: TTemplateString39 });
var TResolvedArtifactPath36 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck38 = Object2({ run: TTemplateString39, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess38 = Object2({
  key: String2(),
  command: TTemplateString39,
  readyCheck: Optional(TExpandedReadyCheck38),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType38 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType38 || {});
var TParallelismValue38 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification38 = Object2({
  cpus: Optional(TTemplateString39),
  memory: Optional(TTemplateString39),
  disk: Object2({ size: Optional(TTemplateString39) }),
  staticIps: Optional(TTemplateString39),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification38 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs38 = Object2({
  values: Optional(Record(String2(), TTemplateString39)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor29 = Object2({ path: TTemplateString39, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor29 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet29 = Union([TTemplateString39, Array2(Union([TTemplateString39, TFilterDescriptor29]))]);
var TInputFilesystemFilter38 = Object2({
  workspace: Optional(TFilterSet29),
  artifacts: Optional(Record(TTemplateString39, TFilterSet29))
});
var TOutputFilesystemFilter38 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration31 = Object2({
  enabled: TTemplateString39,
  ttl: Optional(TTemplateString39)
});
var TTaskDefinitionWithoutParallel38 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification38),
  type: Optional(Enum(TaskType38)),
  after: Optional(TTemplateString39),
  if: Optional(TTemplateString39),
  source: Optional(TSource38),
  cacheConfiguration: TCacheConfiguration31,
  docker: Optional(TTemplateString39),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString39),
  filter: Optional(TInputFilesystemFilter38),
  backgroundProcesses: Optional(Array2(TBackgroundProcess38)),
  toolCache: Optional(TTemplateString39),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor38)),
  envMerge: Optional(Array2(TEnvMergeStrategy38)),
  timeout: Optional(TTemplateString39),
  healthTimeout: Optional(TTemplateString39),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath65)),
  artifactPaths: Optional(Array2(TArtifactPath38)),
  outputs: Optional(TTaskDefinitionOutputs38),
  problemMatchers: Optional(Array2(TProblemMatcher65)),
  problemPaths: Optional(Array2(TProblemPath65)),
  parallelismType: Optional(Enum(ParallelismType38)),
  parallelismValue: Optional(TParallelismValue38),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString39)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString39),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter38),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString39,
      if: Optional(TTemplateString39),
      action: Optional(TTemplateString39)
    })
  )
});
var TCrossRunSource28 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents28 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource28,
  relativeScopedKey: String2()
});
var TTaskDefinition38 = Composite([
  TTaskDefinitionWithoutParallel38,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel38),
    parallelKey: Optional(TTemplateString39),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString39), TTemplateString39]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString39)), TTemplateString39])),
    parallelismTotal: Optional(TTemplateString39)
  })
]);
var TLayerWithManifest65 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId66,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext38 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret38 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess38 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString39,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString39,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult65 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus65),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus65),
  startedAt: Optional(TDateString66),
  completedAt: Optional(TDateString66),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem65 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity65),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary32 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults65 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary32),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest55 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact65 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest55, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact38 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor29)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor29))
      })
    )
  )
});
var TDefaultStatusCheck2 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck2 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration38 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow38 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow38 || {});
var TConcurrencyPool38 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow38) });
var LeaseState38 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState38 || {});
var TTiming57 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps57 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming57)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming57),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming57),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming57.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming57),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming57),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming57),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming57),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming57),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming57),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming57),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming57)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming57.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic38 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig3 = Object2({
  user: Optional(String2())
});
var TResolvedImageConfig3 = Object2({
  user: Optional(String2())
});
var TRetryAction54 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact65)
});
var TBaseLayer12 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2(),
    uid: Number2(),
    gid: Number2()
  }),
  group: Object2({
    name: String2(),
    gid: Number2()
  })
});
var TResolvedBaseConfig6 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer12
});
var TTLUnit31 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit31 || {});
var TTTL31 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit31)
});
var TResolvedWriteCacheConfiguration16 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL31, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration16 = Object2({
  enabled: Boolean2()
});
var TTip42 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory12 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask38 = Object2({
  schemaVersion: Literal(ThisSchemaVersion38),
  taskId: TTaskOrGroupId66,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId39),
  generatorTaskId: Optional(TTaskOrGroupId66),
  definition: TTaskDefinition38,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus38),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus38),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus38),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus38),
  resultStatus: Enum(TaskResultStatus38),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason38)),
  attemptCounts: Record(TRetryCategory12, Number2()),
  resolvedAt: Optional(TDateString66),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString66),
  debugReadyAt: Optional(TDateString66),
  debugStartedAt: Optional(TDateString66),
  debugEndedAt: Optional(TDateString66),
  cancellationRequestedAt: Optional(TDateString66),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString66),
  cancelledAt: Optional(TDateString66),
  concurrencyPool: Optional(TConcurrencyPool38),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext38),
  usedSecrets: Optional(Array2(TUsedSecret38)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration16),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration16),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString39, cacheKey: Enum(EnvironmentVariableCacheKey63) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString39),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess38)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact38)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest65)),
  previousLayers: Optional(Array2(TLayerWithManifest65)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest65)),
  resolvedImageConfig: Optional(TResolvedImageConfig3),
  filesystemLayers: Optional(Array2(TLayerWithManifest65)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString39)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration38),
      baseConfig: TResolvedBaseConfig6,
      crossRunSource: Optional(TCrossRunSource28)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification38),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath36)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult65)),
  whiteoutLayer: Optional(TLayerWithManifest65),
  outputLayers: Optional(Array2(TLayerWithManifest65)),
  outputImageConfig: Optional(TOutputImageConfig3),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey63) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem65)),
  testResults: Optional(Array2(TTestResults65)),
  artifacts: Optional(Array2(TArtifact65)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents28),
  tips: Array2(TTip42),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps57,
  networkTraffic: TNetworkTraffic38,
  outputRetryActions: Array2(TRetryAction54),
  retryAction: Optional(TRetryAction54),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest65),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString66),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry38 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry38 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString66,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString66),
  mostRecentlyAttemptedAt: Optional(TDateString66),
  finishedAt: Optional(TDateString66),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory12
});
var TGraphRoots38 = Object2({ resolution: Array2(TGraphNodeId39), runtime: Array2(TGraphNodeId39) });
var TRunGraph38 = Object2({
  roots: TGraphRoots38,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId39, Array2(TGraphNodeId39)),
    runtime: Record(TGraphNodeId39, Array2(TGraphNodeId39))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId39, Array2(TGraphNodeId39)),
    runtime: Record(TGraphNodeId39, Array2(TGraphNodeId39))
  }),
  subgraphs: Record(TGraphNodeId39, Object2({ roots: TGraphRoots38 })),
  parents: Record(TGraphNodeId39, TGraphNodeId39),
  definitionOrders: Record(TGraphNodeId39, Number2())
});
var TActor38 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState38 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState38)
});
var ApprovalRequestState35 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState35 || {});
var TApprovalRequest35 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState35)
});
var TRun38 = Object2({
  schemaVersion: Literal(ThisSchemaVersion38),
  persistenceExpiresAtSeconds: TEpochSeconds39,
  runId: String2(),
  createdAt: TDateString66,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor38),
  mintDirectoryArtifact: Optional(TArtifact65),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck2,
  customStatusChecks: Array2(TCustomStatusCheck2),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool38),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration38),
  eventNumber: Number2(),
  retries: Array2(TRetry38),
  approvalRequests: Array2(TApprovalRequest35),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph38,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry38)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey39, TConcurrencyPoolState38),
  baseConfig: Optional(TResolvedBaseConfig6),
  crossRunSource: TCrossRunSource28,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus38),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus38),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus38),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus38),
  resultStatus: Enum(RunResultStatus38),
  waitingForLeaseAt: Optional(TDateString66),
  waitingForManualStartAt: Optional(TDateString66),
  startedAt: Optional(TDateString66),
  cancellationRequestedAt: Optional(TDateString66),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString66),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v76.ts
var ThisSchemaVersion39 = "v76" /* V76 */;
var TTaskOrGroupId67 = TBrandedString();
var TGraphNodeId40 = TBrandedString();
var TTemplateString40 = TBrandedString();
var TEvaluatedString40 = TBrandedString();
var TDateString67 = TBrandedString();
var TEpochSeconds40 = TBrandedNumber();
var TScopedTaskKey40 = TBrandedString();
var TaskType39 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType39 || {});
var TaskResultStatus39 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus39 || {});
var TaskExecutionStatus39 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus39 || {});
var TaskExecutionWaitingSubStatus39 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus39 || {});
var TaskExecutionAbortedSubStatus39 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus39 || {});
var TaskExecutionFinishedSubStatus39 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus39 || {});
var TaskAttemptReason39 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason39 || {});
var BackgroundProcessResultStatus66 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus66 || {});
var BackgroundProcessResultFinishedSubStatus66 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus66 || {});
var RunResultStatus39 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus39 || {});
var RunExecutionStatus39 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus39 || {});
var RunExecutionWaitingSubStatus39 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus39 || {});
var RunExecutionAbortedSubStatus39 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus39 || {});
var RunExecutionFinishedSubStatus39 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus39 || {});
var TSource39 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey64 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey64 || {});
var TExpandedEnvDescriptor39 = Object2({ value: Optional(TTemplateString40), cacheKey: Enum(EnvironmentVariableCacheKey64) });
var TEnvMergeStrategy39 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath66 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern66 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity66 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity66 || {});
var TProblemMatcher66 = Object2({ owner: String2(), severity: Optional(Enum(Severity66)), pattern: Array2(TProblemMatcherPattern66) });
var TProblemPath66 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath39 = Object2({ key: String2(), path: TTemplateString40 });
var TResolvedArtifactPath37 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck39 = Object2({ run: TTemplateString40, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess39 = Object2({
  key: String2(),
  command: TTemplateString40,
  readyCheck: Optional(TExpandedReadyCheck39),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType39 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType39 || {});
var TParallelismValue39 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification39 = Object2({
  cpus: Optional(TTemplateString40),
  memory: Optional(TTemplateString40),
  disk: Object2({ size: Optional(TTemplateString40) }),
  staticIps: Optional(TTemplateString40),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification39 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs39 = Object2({
  values: Optional(Record(String2(), TTemplateString40)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor30 = Object2({ path: TTemplateString40, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor30 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet30 = Union([TTemplateString40, Array2(Union([TTemplateString40, TFilterDescriptor30]))]);
var TInputFilesystemFilter39 = Object2({
  workspace: Optional(TFilterSet30),
  artifacts: Optional(Record(TTemplateString40, TFilterSet30))
});
var TOutputFilesystemFilter39 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration32 = Object2({
  enabled: TTemplateString40,
  ttl: Optional(TTemplateString40)
});
var TTaskDefinitionWithoutParallel39 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification39),
  type: Optional(Enum(TaskType39)),
  after: Optional(TTemplateString40),
  if: Optional(TTemplateString40),
  source: Optional(TSource39),
  cacheConfiguration: TCacheConfiguration32,
  docker: Optional(TTemplateString40),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString40),
  filter: Optional(TInputFilesystemFilter39),
  backgroundProcesses: Optional(Array2(TBackgroundProcess39)),
  toolCache: Optional(TTemplateString40),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor39)),
  envMerge: Optional(Array2(TEnvMergeStrategy39)),
  timeout: Optional(TTemplateString40),
  healthTimeout: Optional(TTemplateString40),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath66)),
  artifactPaths: Optional(Array2(TArtifactPath39)),
  outputs: Optional(TTaskDefinitionOutputs39),
  problemMatchers: Optional(Array2(TProblemMatcher66)),
  problemPaths: Optional(Array2(TProblemPath66)),
  parallelismType: Optional(Enum(ParallelismType39)),
  parallelismValue: Optional(TParallelismValue39),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString40)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString40),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter39),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString40,
      if: Optional(TTemplateString40),
      action: Optional(TTemplateString40)
    })
  )
});
var TCrossRunSource29 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents29 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource29,
  relativeScopedKey: String2()
});
var TTaskDefinition39 = Composite([
  TTaskDefinitionWithoutParallel39,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel39),
    parallelKey: Optional(TTemplateString40),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString40), TTemplateString40]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString40)), TTemplateString40])),
    parallelismTotal: Optional(TTemplateString40)
  })
]);
var TLayerWithManifest66 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId67,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext39 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret39 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess39 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString40,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString40,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult66 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus66),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus66),
  startedAt: Optional(TDateString67),
  completedAt: Optional(TDateString67),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem66 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity66),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary33 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults66 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary33),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest56 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact66 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest56, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact39 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor30)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor30))
      })
    )
  )
});
var TDefaultStatusCheck3 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck3 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration39 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow39 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow39 || {});
var TConcurrencyPool39 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow39) });
var LeaseState39 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState39 || {});
var TTiming58 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps58 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming58)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming58),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming58),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming58.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming58),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming58),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming58),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming58),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming58),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming58),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming58),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming58)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming58.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic39 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig4 = Object2({
  user: Optional(String2())
});
var TResolvedImageConfig4 = Object2({
  user: Optional(String2())
});
var TRetryAction55 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact66)
});
var TBaseLayer13 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig7 = Object2({
  image: Optional(String2()),
  prebuiltLayer: TBaseLayer13
});
var TTLUnit32 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit32 || {});
var TTTL32 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit32)
});
var TResolvedWriteCacheConfiguration17 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL32, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration17 = Object2({
  enabled: Boolean2()
});
var TTip43 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory13 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask39 = Object2({
  schemaVersion: Literal(ThisSchemaVersion39),
  taskId: TTaskOrGroupId67,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId40),
  generatorTaskId: Optional(TTaskOrGroupId67),
  definition: TTaskDefinition39,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus39),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus39),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus39),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus39),
  resultStatus: Enum(TaskResultStatus39),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason39)),
  attemptCounts: Record(TRetryCategory13, Number2()),
  resolvedAt: Optional(TDateString67),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString67),
  debugReadyAt: Optional(TDateString67),
  debugStartedAt: Optional(TDateString67),
  debugEndedAt: Optional(TDateString67),
  cancellationRequestedAt: Optional(TDateString67),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString67),
  cancelledAt: Optional(TDateString67),
  concurrencyPool: Optional(TConcurrencyPool39),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext39),
  usedSecrets: Optional(Array2(TUsedSecret39)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration17),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration17),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString40, cacheKey: Enum(EnvironmentVariableCacheKey64) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString40),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess39)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact39)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest66)),
  previousLayers: Optional(Array2(TLayerWithManifest66)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest66)),
  resolvedImageConfig: Optional(TResolvedImageConfig4),
  filesystemLayers: Optional(Array2(TLayerWithManifest66)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString40)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration39),
      baseConfig: TResolvedBaseConfig7,
      crossRunSource: Optional(TCrossRunSource29)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification39),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath37)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult66)),
  whiteoutLayer: Optional(TLayerWithManifest66),
  outputLayers: Optional(Array2(TLayerWithManifest66)),
  outputImageConfig: Optional(TOutputImageConfig4),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey64) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem66)),
  testResults: Optional(Array2(TTestResults66)),
  artifacts: Optional(Array2(TArtifact66)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents29),
  tips: Array2(TTip43),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps58,
  networkTraffic: TNetworkTraffic39,
  outputRetryActions: Array2(TRetryAction55),
  retryAction: Optional(TRetryAction55),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest66),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString67),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry39 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry39 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString67,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString67),
  mostRecentlyAttemptedAt: Optional(TDateString67),
  finishedAt: Optional(TDateString67),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory13
});
var TGraphRoots39 = Object2({ resolution: Array2(TGraphNodeId40), runtime: Array2(TGraphNodeId40) });
var TRunGraph39 = Object2({
  roots: TGraphRoots39,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId40, Array2(TGraphNodeId40)),
    runtime: Record(TGraphNodeId40, Array2(TGraphNodeId40))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId40, Array2(TGraphNodeId40)),
    runtime: Record(TGraphNodeId40, Array2(TGraphNodeId40))
  }),
  subgraphs: Record(TGraphNodeId40, Object2({ roots: TGraphRoots39 })),
  parents: Record(TGraphNodeId40, TGraphNodeId40),
  definitionOrders: Record(TGraphNodeId40, Number2())
});
var TActor39 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState39 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState39)
});
var ApprovalRequestState36 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState36 || {});
var TApprovalRequest36 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState36)
});
var TRun39 = Object2({
  schemaVersion: Literal(ThisSchemaVersion39),
  persistenceExpiresAtSeconds: TEpochSeconds40,
  runId: String2(),
  createdAt: TDateString67,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor39),
  mintDirectoryArtifact: Optional(TArtifact66),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck3,
  customStatusChecks: Array2(TCustomStatusCheck3),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool39),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration39),
  eventNumber: Number2(),
  retries: Array2(TRetry39),
  approvalRequests: Array2(TApprovalRequest36),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph39,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry39)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey40, TConcurrencyPoolState39),
  baseConfig: Optional(TResolvedBaseConfig7),
  crossRunSource: TCrossRunSource29,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus39),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus39),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus39),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus39),
  resultStatus: Enum(RunResultStatus39),
  waitingForLeaseAt: Optional(TDateString67),
  waitingForManualStartAt: Optional(TDateString67),
  startedAt: Optional(TDateString67),
  cancellationRequestedAt: Optional(TDateString67),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString67),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v77.ts
var ThisSchemaVersion40 = "v77" /* V77 */;
var TTaskOrGroupId68 = TBrandedString();
var TGraphNodeId41 = TBrandedString();
var TTemplateString41 = TBrandedString();
var TEvaluatedString41 = TBrandedString();
var TDateString68 = TBrandedString();
var TEpochSeconds41 = TBrandedNumber();
var TScopedTaskKey41 = TBrandedString();
var TaskType40 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType40 || {});
var TaskResultStatus40 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus40 || {});
var TaskExecutionStatus40 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus40 || {});
var TaskExecutionWaitingSubStatus40 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus40 || {});
var TaskExecutionAbortedSubStatus40 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus40 || {});
var TaskExecutionFinishedSubStatus40 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus40 || {});
var TaskAttemptReason40 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason40 || {});
var BackgroundProcessResultStatus67 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus67 || {});
var BackgroundProcessResultFinishedSubStatus67 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus67 || {});
var RunResultStatus40 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus40 || {});
var RunExecutionStatus40 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus40 || {});
var RunExecutionWaitingSubStatus40 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus40 || {});
var RunExecutionAbortedSubStatus40 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus40 || {});
var RunExecutionFinishedSubStatus40 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus40 || {});
var TSource40 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey65 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey65 || {});
var TExpandedEnvDescriptor40 = Object2({ value: Optional(TTemplateString41), cacheKey: Enum(EnvironmentVariableCacheKey65) });
var TEnvMergeStrategy40 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath67 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern67 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity67 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity67 || {});
var TProblemMatcher67 = Object2({ owner: String2(), severity: Optional(Enum(Severity67)), pattern: Array2(TProblemMatcherPattern67) });
var TProblemPath67 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath40 = Object2({ key: String2(), path: TTemplateString41 });
var TResolvedArtifactPath38 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck40 = Object2({ run: TTemplateString41, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess40 = Object2({
  key: String2(),
  command: TTemplateString41,
  readyCheck: Optional(TExpandedReadyCheck40),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType40 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType40 || {});
var TParallelismValue40 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification40 = Object2({
  cpus: Optional(TTemplateString41),
  memory: Optional(TTemplateString41),
  disk: Object2({ size: Optional(TTemplateString41) }),
  staticIps: Optional(TTemplateString41),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification40 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs40 = Object2({
  values: Optional(Record(String2(), TTemplateString41)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor31 = Object2({ path: TTemplateString41, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor31 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet31 = Union([TTemplateString41, Array2(Union([TTemplateString41, TFilterDescriptor31]))]);
var TInputFilesystemFilter40 = Object2({
  workspace: Optional(TFilterSet31),
  artifacts: Optional(Record(TTemplateString41, TFilterSet31))
});
var TOutputFilesystemFilter40 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration33 = Object2({
  enabled: TTemplateString41,
  ttl: Optional(TTemplateString41)
});
var TTaskDefinitionWithoutParallel40 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification40),
  type: Optional(Enum(TaskType40)),
  after: Optional(TTemplateString41),
  if: Optional(TTemplateString41),
  source: Optional(TSource40),
  cacheConfiguration: TCacheConfiguration33,
  docker: Optional(TTemplateString41),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString41),
  filter: Optional(TInputFilesystemFilter40),
  backgroundProcesses: Optional(Array2(TBackgroundProcess40)),
  toolCache: Optional(TTemplateString41),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor40)),
  envMerge: Optional(Array2(TEnvMergeStrategy40)),
  timeout: Optional(TTemplateString41),
  healthTimeout: Optional(TTemplateString41),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath67)),
  artifactPaths: Optional(Array2(TArtifactPath40)),
  outputs: Optional(TTaskDefinitionOutputs40),
  problemMatchers: Optional(Array2(TProblemMatcher67)),
  problemPaths: Optional(Array2(TProblemPath67)),
  parallelismType: Optional(Enum(ParallelismType40)),
  parallelismValue: Optional(TParallelismValue40),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString41)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString41),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter40),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString41,
      if: Optional(TTemplateString41),
      action: Optional(TTemplateString41)
    })
  )
});
var TCrossRunSource30 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents30 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource30,
  relativeScopedKey: String2()
});
var TTaskDefinition40 = Composite([
  TTaskDefinitionWithoutParallel40,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel40),
    parallelKey: Optional(TTemplateString41),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString41), TTemplateString41]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString41)), TTemplateString41])),
    parallelismTotal: Optional(TTemplateString41)
  })
]);
var TLayerWithManifest67 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId68,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext40 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret40 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess40 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString41,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString41,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult67 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus67),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus67),
  startedAt: Optional(TDateString68),
  completedAt: Optional(TDateString68),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem67 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity67),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary34 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults67 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary34),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest57 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact67 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest57, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact40 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor31)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor31))
      })
    )
  )
});
var TDefaultStatusCheck4 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck4 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration40 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow40 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow40 || {});
var TConcurrencyPool40 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow40) });
var LeaseState40 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState40 || {});
var TTiming59 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps59 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming59)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming59),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming59),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming59.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming59),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming59),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming59),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming59),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming59),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming59),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming59),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming59)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming59.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic40 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig5 = Object2({
  user: Optional(String2())
});
var TResolvedImageConfig5 = Object2({
  user: Optional(String2())
});
var TRetryAction56 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact67)
});
var TBaseLayer14 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig8 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer14
});
var TTLUnit33 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit33 || {});
var TTTL33 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit33)
});
var TResolvedWriteCacheConfiguration18 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL33, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration18 = Object2({
  enabled: Boolean2()
});
var TTip44 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory14 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask40 = Object2({
  schemaVersion: Literal(ThisSchemaVersion40),
  taskId: TTaskOrGroupId68,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId41),
  generatorTaskId: Optional(TTaskOrGroupId68),
  definition: TTaskDefinition40,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus40),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus40),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus40),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus40),
  resultStatus: Enum(TaskResultStatus40),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason40)),
  attemptCounts: Record(TRetryCategory14, Number2()),
  resolvedAt: Optional(TDateString68),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString68),
  debugReadyAt: Optional(TDateString68),
  debugStartedAt: Optional(TDateString68),
  debugEndedAt: Optional(TDateString68),
  cancellationRequestedAt: Optional(TDateString68),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString68),
  cancelledAt: Optional(TDateString68),
  concurrencyPool: Optional(TConcurrencyPool40),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext40),
  usedSecrets: Optional(Array2(TUsedSecret40)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration18),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration18),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString41, cacheKey: Enum(EnvironmentVariableCacheKey65) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString41),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess40)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact40)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest67)),
  previousLayers: Optional(Array2(TLayerWithManifest67)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest67)),
  resolvedImageConfig: Optional(TResolvedImageConfig5),
  filesystemLayers: Optional(Array2(TLayerWithManifest67)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString41)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration40),
      baseConfig: TResolvedBaseConfig8,
      crossRunSource: Optional(TCrossRunSource30)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification40),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath38)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult67)),
  whiteoutLayer: Optional(TLayerWithManifest67),
  outputLayers: Optional(Array2(TLayerWithManifest67)),
  outputImageConfig: Optional(TOutputImageConfig5),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey65) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem67)),
  testResults: Optional(Array2(TTestResults67)),
  artifacts: Optional(Array2(TArtifact67)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents30),
  tips: Array2(TTip44),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps59,
  networkTraffic: TNetworkTraffic40,
  outputRetryActions: Array2(TRetryAction56),
  retryAction: Optional(TRetryAction56),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest67),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString68),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry40 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry40 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString68,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString68),
  mostRecentlyAttemptedAt: Optional(TDateString68),
  finishedAt: Optional(TDateString68),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory14
});
var TGraphRoots40 = Object2({ resolution: Array2(TGraphNodeId41), runtime: Array2(TGraphNodeId41) });
var TRunGraph40 = Object2({
  roots: TGraphRoots40,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId41, Array2(TGraphNodeId41)),
    runtime: Record(TGraphNodeId41, Array2(TGraphNodeId41))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId41, Array2(TGraphNodeId41)),
    runtime: Record(TGraphNodeId41, Array2(TGraphNodeId41))
  }),
  subgraphs: Record(TGraphNodeId41, Object2({ roots: TGraphRoots40 })),
  parents: Record(TGraphNodeId41, TGraphNodeId41),
  definitionOrders: Record(TGraphNodeId41, Number2())
});
var TActor40 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState40 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState40)
});
var ApprovalRequestState37 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState37 || {});
var TApprovalRequest37 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState37)
});
var TRun40 = Object2({
  schemaVersion: Literal(ThisSchemaVersion40),
  persistenceExpiresAtSeconds: TEpochSeconds41,
  runId: String2(),
  createdAt: TDateString68,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor40),
  mintDirectoryArtifact: Optional(TArtifact67),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck4,
  customStatusChecks: Array2(TCustomStatusCheck4),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool40),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration40),
  eventNumber: Number2(),
  retries: Array2(TRetry40),
  approvalRequests: Array2(TApprovalRequest37),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph40,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry40)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey41, TConcurrencyPoolState40),
  baseConfig: Optional(TResolvedBaseConfig8),
  crossRunSource: TCrossRunSource30,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus40),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus40),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus40),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus40),
  resultStatus: Enum(RunResultStatus40),
  waitingForLeaseAt: Optional(TDateString68),
  waitingForManualStartAt: Optional(TDateString68),
  startedAt: Optional(TDateString68),
  cancellationRequestedAt: Optional(TDateString68),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString68),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v78.ts
var ThisSchemaVersion41 = "v78" /* V78 */;
var TTaskOrGroupId69 = TBrandedString();
var TGraphNodeId42 = TBrandedString();
var TTemplateString42 = TBrandedString();
var TEvaluatedString42 = TBrandedString();
var TDateString69 = TBrandedString();
var TEpochSeconds42 = TBrandedNumber();
var TScopedTaskKey42 = TBrandedString();
var TaskType41 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType41 || {});
var TaskResultStatus41 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus41 || {});
var TaskExecutionStatus41 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus41 || {});
var TaskExecutionWaitingSubStatus41 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus41 || {});
var TaskExecutionAbortedSubStatus41 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus41 || {});
var TaskExecutionFinishedSubStatus41 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus41 || {});
var TaskAttemptReason41 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason41 || {});
var BackgroundProcessResultStatus68 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus68 || {});
var BackgroundProcessResultFinishedSubStatus68 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus68 || {});
var RunResultStatus41 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus41 || {});
var RunExecutionStatus41 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus41 || {});
var RunExecutionWaitingSubStatus41 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus41 || {});
var RunExecutionAbortedSubStatus41 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus41 || {});
var RunExecutionFinishedSubStatus41 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus41 || {});
var TSource41 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey66 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey66 || {});
var TExpandedEnvDescriptor41 = Object2({ value: Optional(TTemplateString42), cacheKey: Enum(EnvironmentVariableCacheKey66) });
var TEnvMergeStrategy41 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath68 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern68 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity68 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity68 || {});
var TProblemMatcher68 = Object2({ owner: String2(), severity: Optional(Enum(Severity68)), pattern: Array2(TProblemMatcherPattern68) });
var TProblemPath68 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath41 = Object2({ key: String2(), path: TTemplateString42 });
var TResolvedArtifactPath39 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck41 = Object2({ run: TTemplateString42, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess41 = Object2({
  key: String2(),
  command: TTemplateString42,
  readyCheck: Optional(TExpandedReadyCheck41),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType41 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType41 || {});
var TParallelismValue41 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification41 = Object2({
  cpus: Optional(TTemplateString42),
  memory: Optional(TTemplateString42),
  disk: Object2({ size: Optional(TTemplateString42) }),
  staticIps: Optional(TTemplateString42),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification41 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs41 = Object2({
  values: Optional(Record(String2(), TTemplateString42)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor32 = Object2({ path: TTemplateString42, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor32 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet32 = Union([TTemplateString42, Array2(Union([TTemplateString42, TFilterDescriptor32]))]);
var TInputFilesystemFilter41 = Object2({
  workspace: Optional(TFilterSet32),
  artifacts: Optional(Record(TTemplateString42, TFilterSet32))
});
var TOutputFilesystemFilter41 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration34 = Object2({
  enabled: TTemplateString42,
  ttl: Optional(TTemplateString42)
});
var TTaskDefinitionWithoutParallel41 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification41),
  type: Optional(Enum(TaskType41)),
  after: Optional(TTemplateString42),
  if: Optional(TTemplateString42),
  source: Optional(TSource41),
  cacheConfiguration: TCacheConfiguration34,
  docker: Optional(TTemplateString42),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString42),
  filter: Optional(TInputFilesystemFilter41),
  backgroundProcesses: Optional(Array2(TBackgroundProcess41)),
  toolCache: Optional(TTemplateString42),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor41)),
  envMerge: Optional(Array2(TEnvMergeStrategy41)),
  timeout: Optional(TTemplateString42),
  healthTimeout: Optional(TTemplateString42),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath68)),
  artifactPaths: Optional(Array2(TArtifactPath41)),
  outputs: Optional(TTaskDefinitionOutputs41),
  problemMatchers: Optional(Array2(TProblemMatcher68)),
  problemPaths: Optional(Array2(TProblemPath68)),
  parallelismType: Optional(Enum(ParallelismType41)),
  parallelismValue: Optional(TParallelismValue41),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString42)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString42),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter41),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString42,
      if: Optional(TTemplateString42),
      action: Optional(TTemplateString42)
    })
  )
});
var TCrossRunSource31 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents31 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource31,
  relativeScopedKey: String2()
});
var TTaskDefinition41 = Composite([
  TTaskDefinitionWithoutParallel41,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel41),
    parallelKey: Optional(TTemplateString42),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString42), TTemplateString42]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString42)), TTemplateString42])),
    parallelismTotal: Optional(TTemplateString42)
  })
]);
var TLayerWithManifest68 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId69,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext41 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret41 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess41 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString42,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString42,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult68 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus68),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus68),
  startedAt: Optional(TDateString69),
  completedAt: Optional(TDateString69),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem68 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity68),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary35 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults68 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary35),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest58 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact68 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest58, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact41 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor32)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor32))
      })
    )
  )
});
var TDefaultStatusCheck5 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck5 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration41 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow41 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow41 || {});
var TConcurrencyPool41 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow41) });
var LeaseState41 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState41 || {});
var TTiming60 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps60 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming60)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming60),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming60),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming60.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming60),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming60),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming60),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming60),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming60),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming60),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming60),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming60)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming60.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic41 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig6 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TResolvedImageConfig6 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TRetryAction57 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact68)
});
var TBaseLayer15 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig9 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer15
});
var TTLUnit34 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit34 || {});
var TTTL34 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit34)
});
var TResolvedWriteCacheConfiguration19 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL34, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration19 = Object2({
  enabled: Boolean2()
});
var TTip45 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory15 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask41 = Object2({
  schemaVersion: Literal(ThisSchemaVersion41),
  taskId: TTaskOrGroupId69,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId42),
  generatorTaskId: Optional(TTaskOrGroupId69),
  definition: TTaskDefinition41,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus41),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus41),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus41),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus41),
  resultStatus: Enum(TaskResultStatus41),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason41)),
  attemptCounts: Record(TRetryCategory15, Number2()),
  resolvedAt: Optional(TDateString69),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString69),
  debugReadyAt: Optional(TDateString69),
  debugStartedAt: Optional(TDateString69),
  debugEndedAt: Optional(TDateString69),
  cancellationRequestedAt: Optional(TDateString69),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString69),
  cancelledAt: Optional(TDateString69),
  concurrencyPool: Optional(TConcurrencyPool41),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext41),
  usedSecrets: Optional(Array2(TUsedSecret41)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration19),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration19),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString42, cacheKey: Enum(EnvironmentVariableCacheKey66) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString42),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess41)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact41)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest68)),
  previousLayers: Optional(Array2(TLayerWithManifest68)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest68)),
  resolvedImageConfig: Optional(TResolvedImageConfig6),
  filesystemLayers: Optional(Array2(TLayerWithManifest68)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString42)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration41),
      baseConfig: TResolvedBaseConfig9,
      crossRunSource: Optional(TCrossRunSource31)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification41),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath39)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult68)),
  whiteoutLayer: Optional(TLayerWithManifest68),
  outputLayers: Optional(Array2(TLayerWithManifest68)),
  outputImageConfig: Optional(TOutputImageConfig6),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey66) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem68)),
  testResults: Optional(Array2(TTestResults68)),
  artifacts: Optional(Array2(TArtifact68)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents31),
  tips: Array2(TTip45),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps60,
  networkTraffic: TNetworkTraffic41,
  outputRetryActions: Array2(TRetryAction57),
  retryAction: Optional(TRetryAction57),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest68),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString69),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry41 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry41 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString69,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString69),
  mostRecentlyAttemptedAt: Optional(TDateString69),
  finishedAt: Optional(TDateString69),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory15
});
var TGraphRoots41 = Object2({ resolution: Array2(TGraphNodeId42), runtime: Array2(TGraphNodeId42) });
var TRunGraph41 = Object2({
  roots: TGraphRoots41,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId42, Array2(TGraphNodeId42)),
    runtime: Record(TGraphNodeId42, Array2(TGraphNodeId42))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId42, Array2(TGraphNodeId42)),
    runtime: Record(TGraphNodeId42, Array2(TGraphNodeId42))
  }),
  subgraphs: Record(TGraphNodeId42, Object2({ roots: TGraphRoots41 })),
  parents: Record(TGraphNodeId42, TGraphNodeId42),
  definitionOrders: Record(TGraphNodeId42, Number2())
});
var TActor41 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState41 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState41)
});
var ApprovalRequestState38 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState38 || {});
var TApprovalRequest38 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState38)
});
var TRun41 = Object2({
  schemaVersion: Literal(ThisSchemaVersion41),
  persistenceExpiresAtSeconds: TEpochSeconds42,
  runId: String2(),
  createdAt: TDateString69,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor41),
  mintDirectoryArtifact: Optional(TArtifact68),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck5,
  customStatusChecks: Array2(TCustomStatusCheck5),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool41),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration41),
  eventNumber: Number2(),
  retries: Array2(TRetry41),
  approvalRequests: Array2(TApprovalRequest38),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph41,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry41)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey42, TConcurrencyPoolState41),
  baseConfig: Optional(TResolvedBaseConfig9),
  crossRunSource: TCrossRunSource31,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus41),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus41),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus41),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus41),
  resultStatus: Enum(RunResultStatus41),
  waitingForLeaseAt: Optional(TDateString69),
  waitingForManualStartAt: Optional(TDateString69),
  startedAt: Optional(TDateString69),
  cancellationRequestedAt: Optional(TDateString69),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString69),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v79.ts
var ThisSchemaVersion42 = "v79" /* V79 */;
var TTaskOrGroupId70 = TBrandedString();
var TGraphNodeId43 = TBrandedString();
var TTemplateString43 = TBrandedString();
var TEvaluatedString43 = TBrandedString();
var TDateString70 = TBrandedString();
var TEpochSeconds43 = TBrandedNumber();
var TScopedTaskKey43 = TBrandedString();
var TaskType42 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType42 || {});
var TaskResultStatus42 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus42 || {});
var TaskExecutionStatus42 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus42 || {});
var TaskExecutionWaitingSubStatus42 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus42 || {});
var TaskExecutionAbortedSubStatus42 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus42 || {});
var TaskExecutionFinishedSubStatus42 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus42 || {});
var TaskAttemptReason42 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason42 || {});
var BackgroundProcessResultStatus69 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus69 || {});
var BackgroundProcessResultFinishedSubStatus69 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus69 || {});
var RunResultStatus42 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus42 || {});
var RunExecutionStatus42 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus42 || {});
var RunExecutionWaitingSubStatus42 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus42 || {});
var RunExecutionAbortedSubStatus42 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus42 || {});
var RunExecutionFinishedSubStatus42 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus42 || {});
var TSource42 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey67 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey67 || {});
var TExpandedEnvDescriptor42 = Object2({ value: Optional(TTemplateString43), cacheKey: Enum(EnvironmentVariableCacheKey67) });
var TEnvMergeStrategy42 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath69 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern69 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity69 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity69 || {});
var TProblemMatcher69 = Object2({ owner: String2(), severity: Optional(Enum(Severity69)), pattern: Array2(TProblemMatcherPattern69) });
var TProblemPath69 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath42 = Object2({ key: String2(), path: TTemplateString43 });
var TResolvedArtifactPath40 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck42 = Object2({ run: TTemplateString43, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess42 = Object2({
  key: String2(),
  command: TTemplateString43,
  readyCheck: Optional(TExpandedReadyCheck42),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType42 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType42 || {});
var TParallelismValue42 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification42 = Object2({
  cpus: Optional(TTemplateString43),
  memory: Optional(TTemplateString43),
  disk: Object2({ size: Optional(TTemplateString43) }),
  staticIps: Optional(TTemplateString43),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification42 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs42 = Object2({
  values: Optional(Record(String2(), TTemplateString43)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor33 = Object2({ path: TTemplateString43, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor33 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet33 = Union([TTemplateString43, Array2(Union([TTemplateString43, TFilterDescriptor33]))]);
var TInputFilesystemFilter42 = Object2({
  workspace: Optional(TFilterSet33),
  artifacts: Optional(Record(TTemplateString43, TFilterSet33))
});
var TOutputFilesystemFilter42 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration35 = Object2({
  enabled: TTemplateString43,
  ttl: Optional(TTemplateString43)
});
var TTaskDefinitionWithoutParallel42 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification42),
  type: Optional(Enum(TaskType42)),
  after: Optional(TTemplateString43),
  if: Optional(TTemplateString43),
  source: Optional(TSource42),
  cacheConfiguration: TCacheConfiguration35,
  docker: Optional(TTemplateString43),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString43),
  filter: Optional(TInputFilesystemFilter42),
  backgroundProcesses: Optional(Array2(TBackgroundProcess42)),
  toolCache: Optional(TTemplateString43),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor42)),
  envMerge: Optional(Array2(TEnvMergeStrategy42)),
  timeout: Optional(TTemplateString43),
  healthTimeout: Optional(TTemplateString43),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath69)),
  artifactPaths: Optional(Array2(TArtifactPath42)),
  outputs: Optional(TTaskDefinitionOutputs42),
  problemMatchers: Optional(Array2(TProblemMatcher69)),
  problemPaths: Optional(Array2(TProblemPath69)),
  parallelismType: Optional(Enum(ParallelismType42)),
  parallelismValue: Optional(TParallelismValue42),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString43)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString43),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter42),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString43,
      if: Optional(TTemplateString43),
      action: Optional(TTemplateString43)
    })
  )
});
var TCrossRunSource32 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents32 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource32,
  relativeScopedKey: String2()
});
var TTaskDefinition42 = Composite([
  TTaskDefinitionWithoutParallel42,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel42),
    parallelKey: Optional(TTemplateString43),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString43), TTemplateString43]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString43)), TTemplateString43])),
    parallelismTotal: Optional(TTemplateString43)
  })
]);
var TLayerWithManifest69 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId70,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext42 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret42 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess42 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString43,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString43,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult69 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus69),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus69),
  startedAt: Optional(TDateString70),
  completedAt: Optional(TDateString70),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem69 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity69),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary36 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults69 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary36),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest59 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact69 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest59, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact42 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor33)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor33))
      })
    )
  )
});
var TDefaultStatusCheck6 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck6 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration42 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow42 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow42 || {});
var TConcurrencyPool42 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow42) });
var LeaseState42 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState42 || {});
var TTiming61 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps61 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming61)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming61),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming61),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming61.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming61),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming61),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming61),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming61),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming61),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming61),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming61),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming61)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming61.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic42 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig7 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TResolvedImageConfig7 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TRetryAction58 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact69)
});
var TBaseLayer16 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig10 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer16,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit35 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit35 || {});
var TTTL35 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit35)
});
var TResolvedWriteCacheConfiguration20 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL35, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration20 = Object2({
  enabled: Boolean2()
});
var TTip46 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory16 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask42 = Object2({
  schemaVersion: Literal(ThisSchemaVersion42),
  taskId: TTaskOrGroupId70,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId43),
  generatorTaskId: Optional(TTaskOrGroupId70),
  definition: TTaskDefinition42,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus42),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus42),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus42),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus42),
  resultStatus: Enum(TaskResultStatus42),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason42)),
  attemptCounts: Record(TRetryCategory16, Number2()),
  resolvedAt: Optional(TDateString70),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString70),
  debugReadyAt: Optional(TDateString70),
  debugStartedAt: Optional(TDateString70),
  debugEndedAt: Optional(TDateString70),
  cancellationRequestedAt: Optional(TDateString70),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString70),
  cancelledAt: Optional(TDateString70),
  concurrencyPool: Optional(TConcurrencyPool42),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext42),
  usedSecrets: Optional(Array2(TUsedSecret42)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration20),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration20),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString43, cacheKey: Enum(EnvironmentVariableCacheKey67) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString43),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess42)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact42)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest69)),
  previousLayers: Optional(Array2(TLayerWithManifest69)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest69)),
  resolvedImageConfig: Optional(TResolvedImageConfig7),
  filesystemLayers: Optional(Array2(TLayerWithManifest69)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString43)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration42),
      baseConfig: TResolvedBaseConfig10,
      crossRunSource: Optional(TCrossRunSource32)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification42),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath40)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult69)),
  whiteoutLayer: Optional(TLayerWithManifest69),
  outputLayers: Optional(Array2(TLayerWithManifest69)),
  outputImageConfig: Optional(TOutputImageConfig7),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey67) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem69)),
  testResults: Optional(Array2(TTestResults69)),
  artifacts: Optional(Array2(TArtifact69)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents32),
  tips: Array2(TTip46),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps61,
  networkTraffic: TNetworkTraffic42,
  outputRetryActions: Array2(TRetryAction58),
  retryAction: Optional(TRetryAction58),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest69),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString70),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry42 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry42 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString70,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString70),
  mostRecentlyAttemptedAt: Optional(TDateString70),
  finishedAt: Optional(TDateString70),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory16
});
var TGraphRoots42 = Object2({ resolution: Array2(TGraphNodeId43), runtime: Array2(TGraphNodeId43) });
var TRunGraph42 = Object2({
  roots: TGraphRoots42,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId43, Array2(TGraphNodeId43)),
    runtime: Record(TGraphNodeId43, Array2(TGraphNodeId43))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId43, Array2(TGraphNodeId43)),
    runtime: Record(TGraphNodeId43, Array2(TGraphNodeId43))
  }),
  subgraphs: Record(TGraphNodeId43, Object2({ roots: TGraphRoots42 })),
  parents: Record(TGraphNodeId43, TGraphNodeId43),
  definitionOrders: Record(TGraphNodeId43, Number2())
});
var TActor42 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState42 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState42)
});
var ApprovalRequestState39 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState39 || {});
var TApprovalRequest39 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState39)
});
var TRun42 = Object2({
  schemaVersion: Literal(ThisSchemaVersion42),
  persistenceExpiresAtSeconds: TEpochSeconds43,
  runId: String2(),
  createdAt: TDateString70,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor42),
  mintDirectoryArtifact: Optional(TArtifact69),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck6,
  customStatusChecks: Array2(TCustomStatusCheck6),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool42),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration42),
  eventNumber: Number2(),
  retries: Array2(TRetry42),
  approvalRequests: Array2(TApprovalRequest39),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph42,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry42)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey43, TConcurrencyPoolState42),
  baseConfig: Optional(TResolvedBaseConfig10),
  crossRunSource: TCrossRunSource32,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus42),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus42),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus42),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus42),
  resultStatus: Enum(RunResultStatus42),
  waitingForLeaseAt: Optional(TDateString70),
  waitingForManualStartAt: Optional(TDateString70),
  startedAt: Optional(TDateString70),
  cancellationRequestedAt: Optional(TDateString70),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString70),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v80.ts
var ThisSchemaVersion43 = "v80" /* V80 */;
var TTaskOrGroupId71 = TBrandedString();
var TGraphNodeId44 = TBrandedString();
var TTemplateString44 = TBrandedString();
var TEvaluatedString44 = TBrandedString();
var TDateString71 = TBrandedString();
var TEpochSeconds44 = TBrandedNumber();
var TScopedTaskKey44 = TBrandedString();
var TaskType43 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType43 || {});
var TaskResultStatus43 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus43 || {});
var TaskExecutionStatus43 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus43 || {});
var TaskExecutionWaitingSubStatus43 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus43 || {});
var TaskExecutionAbortedSubStatus43 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus43 || {});
var TaskExecutionFinishedSubStatus43 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus43 || {});
var TaskAttemptReason43 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason43 || {});
var BackgroundProcessResultStatus70 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus70 || {});
var BackgroundProcessResultFinishedSubStatus70 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus70 || {});
var RunResultStatus43 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus43 || {});
var RunExecutionStatus43 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus43 || {});
var RunExecutionWaitingSubStatus43 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus43 || {});
var RunExecutionAbortedSubStatus43 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus43 || {});
var RunExecutionFinishedSubStatus43 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus43 || {});
var TSource43 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey68 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey68 || {});
var TExpandedEnvDescriptor43 = Object2({ value: Optional(TTemplateString44), cacheKey: Enum(EnvironmentVariableCacheKey68) });
var TEnvMergeStrategy43 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath70 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern70 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity70 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity70 || {});
var TProblemMatcher70 = Object2({ owner: String2(), severity: Optional(Enum(Severity70)), pattern: Array2(TProblemMatcherPattern70) });
var TProblemPath70 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath43 = Object2({ key: String2(), path: TTemplateString44 });
var TResolvedArtifactPath41 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck43 = Object2({ run: TTemplateString44, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess43 = Object2({
  key: String2(),
  command: TTemplateString44,
  readyCheck: Optional(TExpandedReadyCheck43),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType43 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType43 || {});
var TParallelismValue43 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification43 = Object2({
  cpus: Optional(TTemplateString44),
  memory: Optional(TTemplateString44),
  disk: Object2({ size: Optional(TTemplateString44) }),
  staticIps: Optional(TTemplateString44),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification43 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs43 = Object2({
  values: Optional(Record(String2(), TTemplateString44)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor34 = Object2({ path: TTemplateString44, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor34 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet34 = Union([TTemplateString44, Array2(Union([TTemplateString44, TFilterDescriptor34]))]);
var TInputFilesystemFilter43 = Object2({
  workspace: Optional(TFilterSet34),
  artifacts: Optional(Record(TTemplateString44, TFilterSet34))
});
var TOutputFilesystemFilter43 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration36 = Object2({
  enabled: TTemplateString44,
  ttl: Optional(TTemplateString44)
});
var TTaskDefinitionWithoutParallel43 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification43),
  type: Optional(Enum(TaskType43)),
  after: Optional(TTemplateString44),
  if: Optional(TTemplateString44),
  source: Optional(TSource43),
  cacheConfiguration: TCacheConfiguration36,
  docker: Optional(TTemplateString44),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString44),
  filter: Optional(TInputFilesystemFilter43),
  backgroundProcesses: Optional(Array2(TBackgroundProcess43)),
  toolCache: Optional(TTemplateString44),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor43)),
  envMerge: Optional(Array2(TEnvMergeStrategy43)),
  timeout: Optional(TTemplateString44),
  healthTimeout: Optional(TTemplateString44),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath70)),
  artifactPaths: Optional(Array2(TArtifactPath43)),
  outputs: Optional(TTaskDefinitionOutputs43),
  problemMatchers: Optional(Array2(TProblemMatcher70)),
  problemPaths: Optional(Array2(TProblemPath70)),
  parallelismType: Optional(Enum(ParallelismType43)),
  parallelismValue: Optional(TParallelismValue43),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString44)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString44),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter43),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString44,
      if: Optional(TTemplateString44),
      action: Optional(TTemplateString44)
    })
  )
});
var TCrossRunSource33 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents33 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource33,
  relativeScopedKey: String2()
});
var TTaskDefinition43 = Composite([
  TTaskDefinitionWithoutParallel43,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel43),
    parallelKey: Optional(TTemplateString44),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString44), TTemplateString44]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString44)), TTemplateString44])),
    parallelismTotal: Optional(TTemplateString44)
  })
]);
var TLayerWithManifest70 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId71,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext43 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret43 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess43 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString44,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString44,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult70 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus70),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus70),
  startedAt: Optional(TDateString71),
  completedAt: Optional(TDateString71),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem70 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity70),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary37 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults70 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary37),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest60 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact70 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest60, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact43 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor34)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor34))
      })
    )
  )
});
var TDefaultStatusCheck7 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck7 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration43 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow43 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow43 || {});
var TConcurrencyPool43 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow43) });
var LeaseState43 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState43 || {});
var TTiming62 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps62 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming62)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming62),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming62),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming62.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming62),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming62),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming62),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming62),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming62),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming62),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming62),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming62)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming62.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic43 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig8 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TResolvedImageConfig8 = Object2({
  user: Optional(String2()),
  shell: Optional(String2())
});
var TRetryAction59 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact70)
});
var TBaseLayer17 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig11 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer17,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit36 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit36 || {});
var TTTL36 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit36)
});
var TResolvedWriteCacheConfiguration21 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL36, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration21 = Object2({
  enabled: Boolean2()
});
var TTip47 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory17 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask43 = Object2({
  schemaVersion: Literal(ThisSchemaVersion43),
  taskId: TTaskOrGroupId71,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId44),
  generatorTaskId: Optional(TTaskOrGroupId71),
  definition: TTaskDefinition43,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus43),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus43),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus43),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus43),
  resultStatus: Enum(TaskResultStatus43),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason43)),
  attemptCounts: Record(TRetryCategory17, Number2()),
  resolvedAt: Optional(TDateString71),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString71),
  debugReadyAt: Optional(TDateString71),
  debugStartedAt: Optional(TDateString71),
  debugEndedAt: Optional(TDateString71),
  cancellationRequestedAt: Optional(TDateString71),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString71),
  cancelledAt: Optional(TDateString71),
  concurrencyPool: Optional(TConcurrencyPool43),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext43),
  usedSecrets: Optional(Array2(TUsedSecret43)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration21),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration21),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString44, cacheKey: Enum(EnvironmentVariableCacheKey68) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString44),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess43)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact43)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest70)),
  previousLayers: Optional(Array2(TLayerWithManifest70)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest70)),
  resolvedImageConfig: Optional(TResolvedImageConfig8),
  filesystemLayers: Optional(Array2(TLayerWithManifest70)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString44)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration43),
      baseConfig: TResolvedBaseConfig11,
      crossRunSource: Optional(TCrossRunSource33)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification43),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath41)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult70)),
  whiteoutLayer: Optional(TLayerWithManifest70),
  outputLayers: Optional(Array2(TLayerWithManifest70)),
  outputImageConfig: Optional(TOutputImageConfig8),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey68) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem70)),
  testResults: Optional(Array2(TTestResults70)),
  artifacts: Optional(Array2(TArtifact70)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents33),
  tips: Array2(TTip47),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps62,
  networkTraffic: TNetworkTraffic43,
  outputRetryActions: Array2(TRetryAction59),
  retryAction: Optional(TRetryAction59),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest70),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString71),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry43 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry43 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString71,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString71),
  mostRecentlyAttemptedAt: Optional(TDateString71),
  finishedAt: Optional(TDateString71),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory17
});
var TGraphRoots43 = Object2({ resolution: Array2(TGraphNodeId44), runtime: Array2(TGraphNodeId44) });
var TRunGraph43 = Object2({
  roots: TGraphRoots43,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId44, Array2(TGraphNodeId44)),
    runtime: Record(TGraphNodeId44, Array2(TGraphNodeId44))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId44, Array2(TGraphNodeId44)),
    runtime: Record(TGraphNodeId44, Array2(TGraphNodeId44))
  }),
  subgraphs: Record(TGraphNodeId44, Object2({ roots: TGraphRoots43 })),
  parents: Record(TGraphNodeId44, TGraphNodeId44),
  definitionOrders: Record(TGraphNodeId44, Number2())
});
var TActor43 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState43 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState43)
});
var ApprovalRequestState40 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState40 || {});
var TApprovalRequest40 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState40)
});
var TRun43 = Object2({
  schemaVersion: Literal(ThisSchemaVersion43),
  persistenceExpiresAtSeconds: TEpochSeconds44,
  runId: String2(),
  createdAt: TDateString71,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor43),
  mintDirectoryArtifact: Optional(TArtifact70),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck7,
  customStatusChecks: Array2(TCustomStatusCheck7),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool43),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration43),
  eventNumber: Number2(),
  retries: Array2(TRetry43),
  approvalRequests: Array2(TApprovalRequest40),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph43,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry43)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey44, TConcurrencyPoolState43),
  baseConfig: Optional(TResolvedBaseConfig11),
  crossRunSource: TCrossRunSource33,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus43),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus43),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus43),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus43),
  resultStatus: Enum(RunResultStatus43),
  waitingForLeaseAt: Optional(TDateString71),
  waitingForManualStartAt: Optional(TDateString71),
  startedAt: Optional(TDateString71),
  cancellationRequestedAt: Optional(TDateString71),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString71),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v81.ts
var ThisSchemaVersion44 = "v81" /* V81 */;
var TTaskOrGroupId72 = TBrandedString();
var TGraphNodeId45 = TBrandedString();
var TTemplateString45 = TBrandedString();
var TEvaluatedString45 = TBrandedString();
var TDateString72 = TBrandedString();
var TEpochSeconds45 = TBrandedNumber();
var TScopedTaskKey45 = TBrandedString();
var TaskType44 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType44 || {});
var TaskResultStatus44 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus44 || {});
var TaskExecutionStatus44 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus44 || {});
var TaskExecutionWaitingSubStatus44 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus44 || {});
var TaskExecutionAbortedSubStatus44 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus44 || {});
var TaskExecutionFinishedSubStatus44 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus44 || {});
var TaskAttemptReason44 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason44 || {});
var BackgroundProcessResultStatus71 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus71 || {});
var BackgroundProcessResultFinishedSubStatus71 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus71 || {});
var RunResultStatus44 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus44 || {});
var RunExecutionStatus44 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus44 || {});
var RunExecutionWaitingSubStatus44 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus44 || {});
var RunExecutionAbortedSubStatus44 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus44 || {});
var RunExecutionFinishedSubStatus44 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus44 || {});
var TSource44 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey69 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey69 || {});
var TExpandedEnvDescriptor44 = Object2({ value: Optional(TTemplateString45), cacheKey: Enum(EnvironmentVariableCacheKey69) });
var TEnvMergeStrategy44 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath71 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern71 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity71 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity71 || {});
var TProblemMatcher71 = Object2({ owner: String2(), severity: Optional(Enum(Severity71)), pattern: Array2(TProblemMatcherPattern71) });
var TProblemPath71 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath44 = Object2({ key: String2(), path: TTemplateString45 });
var TResolvedArtifactPath42 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck44 = Object2({ run: TTemplateString45, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess44 = Object2({
  key: String2(),
  command: TTemplateString45,
  readyCheck: Optional(TExpandedReadyCheck44),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType44 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType44 || {});
var TParallelismValue44 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification44 = Object2({
  cpus: Optional(TTemplateString45),
  memory: Optional(TTemplateString45),
  disk: Object2({ size: Optional(TTemplateString45) }),
  staticIps: Optional(TTemplateString45),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification44 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs44 = Object2({
  values: Optional(Record(String2(), TTemplateString45)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor35 = Object2({ path: TTemplateString45, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor35 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet35 = Union([TTemplateString45, Array2(Union([TTemplateString45, TFilterDescriptor35]))]);
var TInputFilesystemFilter44 = Object2({
  workspace: Optional(TFilterSet35),
  artifacts: Optional(Record(TTemplateString45, TFilterSet35))
});
var TOutputFilesystemFilter44 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration37 = Object2({
  enabled: TTemplateString45,
  ttl: Optional(TTemplateString45)
});
var TTaskDefinitionWithoutParallel44 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification44),
  type: Optional(Enum(TaskType44)),
  after: Optional(TTemplateString45),
  if: Optional(TTemplateString45),
  source: Optional(TSource44),
  cacheConfiguration: TCacheConfiguration37,
  docker: Optional(TTemplateString45),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString45),
  filter: Optional(TInputFilesystemFilter44),
  backgroundProcesses: Optional(Array2(TBackgroundProcess44)),
  toolCache: Optional(TTemplateString45),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor44)),
  envMerge: Optional(Array2(TEnvMergeStrategy44)),
  timeout: Optional(TTemplateString45),
  healthTimeout: Optional(TTemplateString45),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath71)),
  artifactPaths: Optional(Array2(TArtifactPath44)),
  outputs: Optional(TTaskDefinitionOutputs44),
  problemMatchers: Optional(Array2(TProblemMatcher71)),
  problemPaths: Optional(Array2(TProblemPath71)),
  parallelismType: Optional(Enum(ParallelismType44)),
  parallelismValue: Optional(TParallelismValue44),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString45)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString45),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter44),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString45,
      if: Optional(TTemplateString45),
      action: Optional(TTemplateString45)
    })
  )
});
var TCrossRunSource34 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents34 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource34,
  relativeScopedKey: String2()
});
var TTaskDefinition44 = Composite([
  TTaskDefinitionWithoutParallel44,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel44),
    parallelKey: Optional(TTemplateString45),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString45), TTemplateString45]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString45)), TTemplateString45])),
    parallelismTotal: Optional(TTemplateString45)
  })
]);
var TLayerWithManifest71 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId72,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext44 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret44 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess44 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString45,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString45,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult71 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus71),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus71),
  startedAt: Optional(TDateString72),
  completedAt: Optional(TDateString72),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem71 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity71),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary38 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults71 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary38),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest61 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact71 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest61, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact44 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor35)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor35))
      })
    )
  )
});
var TDefaultStatusCheck8 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck8 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration44 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow44 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow44 || {});
var TConcurrencyPool44 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow44) });
var LeaseState44 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState44 || {});
var TTiming63 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps63 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming63)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming63),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming63),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming63.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming63),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming63),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming63),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming63),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming63),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming63),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming63),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming63)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming63.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic44 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig9 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TResolvedImageConfig9 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TRetryAction60 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact71)
});
var TBaseLayer18 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig12 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer18,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit37 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit37 || {});
var TTTL37 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit37)
});
var TResolvedWriteCacheConfiguration22 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL37, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration22 = Object2({
  enabled: Boolean2()
});
var TTip48 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory18 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask44 = Object2({
  schemaVersion: Literal(ThisSchemaVersion44),
  taskId: TTaskOrGroupId72,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId45),
  generatorTaskId: Optional(TTaskOrGroupId72),
  definition: TTaskDefinition44,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus44),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus44),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus44),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus44),
  resultStatus: Enum(TaskResultStatus44),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason44)),
  attemptCounts: Record(TRetryCategory18, Number2()),
  resolvedAt: Optional(TDateString72),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString72),
  debugReadyAt: Optional(TDateString72),
  debugStartedAt: Optional(TDateString72),
  debugEndedAt: Optional(TDateString72),
  cancellationRequestedAt: Optional(TDateString72),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString72),
  cancelledAt: Optional(TDateString72),
  concurrencyPool: Optional(TConcurrencyPool44),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext44),
  usedSecrets: Optional(Array2(TUsedSecret44)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration22),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration22),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString45, cacheKey: Enum(EnvironmentVariableCacheKey69) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString45),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess44)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact44)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest71)),
  previousLayers: Optional(Array2(TLayerWithManifest71)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest71)),
  resolvedImageConfig: Optional(TResolvedImageConfig9),
  filesystemLayers: Optional(Array2(TLayerWithManifest71)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString45)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration44),
      baseConfig: TResolvedBaseConfig12,
      crossRunSource: Optional(TCrossRunSource34)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification44),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath42)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult71)),
  whiteoutLayer: Optional(TLayerWithManifest71),
  outputLayers: Optional(Array2(TLayerWithManifest71)),
  outputImageConfig: Optional(TOutputImageConfig9),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey69) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem71)),
  testResults: Optional(Array2(TTestResults71)),
  artifacts: Optional(Array2(TArtifact71)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents34),
  tips: Array2(TTip48),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps63,
  networkTraffic: TNetworkTraffic44,
  outputRetryActions: Array2(TRetryAction60),
  retryAction: Optional(TRetryAction60),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest71),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString72),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry44 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry44 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString72,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString72),
  mostRecentlyAttemptedAt: Optional(TDateString72),
  finishedAt: Optional(TDateString72),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory18
});
var TGraphRoots44 = Object2({ resolution: Array2(TGraphNodeId45), runtime: Array2(TGraphNodeId45) });
var TRunGraph44 = Object2({
  roots: TGraphRoots44,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId45, Array2(TGraphNodeId45)),
    runtime: Record(TGraphNodeId45, Array2(TGraphNodeId45))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId45, Array2(TGraphNodeId45)),
    runtime: Record(TGraphNodeId45, Array2(TGraphNodeId45))
  }),
  subgraphs: Record(TGraphNodeId45, Object2({ roots: TGraphRoots44 })),
  parents: Record(TGraphNodeId45, TGraphNodeId45),
  definitionOrders: Record(TGraphNodeId45, Number2())
});
var TActor44 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState44 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState44)
});
var ApprovalRequestState41 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState41 || {});
var TApprovalRequest41 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState41)
});
var TRun44 = Object2({
  schemaVersion: Literal(ThisSchemaVersion44),
  persistenceExpiresAtSeconds: TEpochSeconds45,
  runId: String2(),
  createdAt: TDateString72,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor44),
  mintDirectoryArtifact: Optional(TArtifact71),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck8,
  customStatusChecks: Array2(TCustomStatusCheck8),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool44),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration44),
  eventNumber: Number2(),
  retries: Array2(TRetry44),
  approvalRequests: Array2(TApprovalRequest41),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph44,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry44)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey45, TConcurrencyPoolState44),
  baseConfig: Optional(TResolvedBaseConfig12),
  crossRunSource: TCrossRunSource34,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus44),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus44),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus44),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus44),
  resultStatus: Enum(RunResultStatus44),
  waitingForLeaseAt: Optional(TDateString72),
  waitingForManualStartAt: Optional(TDateString72),
  startedAt: Optional(TDateString72),
  cancellationRequestedAt: Optional(TDateString72),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString72),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v82.ts
var ThisSchemaVersion45 = "v82" /* V82 */;
var TTaskOrGroupId73 = TBrandedString();
var TGraphNodeId46 = TBrandedString();
var TTemplateString46 = TBrandedString();
var TEvaluatedString46 = TBrandedString();
var TDateString73 = TBrandedString();
var TEpochSeconds46 = TBrandedNumber();
var TScopedTaskKey46 = TBrandedString();
var TaskType45 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType45 || {});
var TaskResultStatus45 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus45 || {});
var TaskExecutionStatus45 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus45 || {});
var TaskExecutionWaitingSubStatus45 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus45 || {});
var TaskExecutionAbortedSubStatus45 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus45 || {});
var TaskExecutionFinishedSubStatus45 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus45 || {});
var TaskAttemptReason45 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason45 || {});
var BackgroundProcessResultStatus72 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus72 || {});
var BackgroundProcessResultFinishedSubStatus72 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus72 || {});
var RunResultStatus45 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus45 || {});
var RunExecutionStatus45 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus45 || {});
var RunExecutionWaitingSubStatus45 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus45 || {});
var RunExecutionAbortedSubStatus45 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus45 || {});
var RunExecutionFinishedSubStatus45 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus45 || {});
var TSource45 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey70 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey70 || {});
var TExpandedEnvDescriptor45 = Object2({ value: Optional(TTemplateString46), cacheKey: Enum(EnvironmentVariableCacheKey70) });
var TEnvMergeStrategy45 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath72 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern72 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity72 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity72 || {});
var TProblemMatcher72 = Object2({ owner: String2(), severity: Optional(Enum(Severity72)), pattern: Array2(TProblemMatcherPattern72) });
var TProblemPath72 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath45 = Object2({ key: String2(), path: TTemplateString46 });
var TResolvedArtifactPath43 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck45 = Object2({ run: TTemplateString46, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess45 = Object2({
  key: String2(),
  command: TTemplateString46,
  readyCheck: Optional(TExpandedReadyCheck45),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType45 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType45 || {});
var TParallelismValue45 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification45 = Object2({
  cpus: Optional(TTemplateString46),
  memory: Optional(TTemplateString46),
  disk: Object2({ size: Optional(TTemplateString46) }),
  staticIps: Optional(TTemplateString46),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification45 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs45 = Object2({
  values: Optional(Record(String2(), TTemplateString46)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor36 = Object2({ path: TTemplateString46, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor36 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet36 = Union([TTemplateString46, Array2(Union([TTemplateString46, TFilterDescriptor36]))]);
var TInputFilesystemFilter45 = Object2({
  workspace: Optional(TFilterSet36),
  artifacts: Optional(Record(TTemplateString46, TFilterSet36))
});
var TOutputFilesystemFilter45 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration38 = Object2({
  enabled: TTemplateString46,
  ttl: Optional(TTemplateString46)
});
var TTaskDefinitionWithoutParallel45 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification45),
  type: Optional(Enum(TaskType45)),
  after: Optional(TTemplateString46),
  if: Optional(TTemplateString46),
  source: Optional(TSource45),
  cacheConfiguration: TCacheConfiguration38,
  docker: Optional(TTemplateString46),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString46),
  filter: Optional(TInputFilesystemFilter45),
  backgroundProcesses: Optional(Array2(TBackgroundProcess45)),
  toolCache: Optional(TTemplateString46),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor45)),
  envMerge: Optional(Array2(TEnvMergeStrategy45)),
  timeout: Optional(TTemplateString46),
  healthTimeout: Optional(TTemplateString46),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath72)),
  artifactPaths: Optional(Array2(TArtifactPath45)),
  outputs: Optional(TTaskDefinitionOutputs45),
  problemMatchers: Optional(Array2(TProblemMatcher72)),
  problemPaths: Optional(Array2(TProblemPath72)),
  parallelismType: Optional(Enum(ParallelismType45)),
  parallelismValue: Optional(TParallelismValue45),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString46)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString46),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter45),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString46,
      if: Optional(TTemplateString46),
      action: Optional(TTemplateString46)
    })
  )
});
var TCrossRunSource35 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents35 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource35,
  relativeScopedKey: String2()
});
var TTaskDefinition45 = Composite([
  TTaskDefinitionWithoutParallel45,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel45),
    parallelKey: Optional(TTemplateString46),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString46), TTemplateString46]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString46)), TTemplateString46])),
    parallelismTotal: Optional(TTemplateString46)
  })
]);
var TLayerWithManifest72 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId73,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext45 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret45 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess45 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString46,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString46,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult72 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus72),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus72),
  startedAt: Optional(TDateString73),
  completedAt: Optional(TDateString73),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem72 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity72),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary39 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults72 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary39),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest62 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact72 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest62, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact45 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor36)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor36))
      })
    )
  )
});
var TDefaultStatusCheck9 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck9 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration45 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow45 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow45 || {});
var TConcurrencyPool45 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow45) });
var LeaseState45 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState45 || {});
var TTiming64 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps64 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming64)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming64),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming64),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming64.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming64),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming64),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming64),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming64),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming64),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming64),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming64),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming64)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming64.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic45 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig10 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TResolvedImageConfig10 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TRetryAction61 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact72)
});
var TBaseLayer19 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig13 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer19,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit38 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit38 || {});
var TTTL38 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit38)
});
var TResolvedWriteCacheConfiguration23 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL38, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration23 = Object2({
  enabled: Boolean2()
});
var TTip49 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory19 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask45 = Object2({
  schemaVersion: Literal(ThisSchemaVersion45),
  taskId: TTaskOrGroupId73,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId46),
  generatorTaskId: Optional(TTaskOrGroupId73),
  definition: TTaskDefinition45,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus45),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus45),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus45),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus45),
  resultStatus: Enum(TaskResultStatus45),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason45)),
  attemptCounts: Record(TRetryCategory19, Number2()),
  resolvedAt: Optional(TDateString73),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString73),
  debugReadyAt: Optional(TDateString73),
  debugStartedAt: Optional(TDateString73),
  debugEndedAt: Optional(TDateString73),
  cancellationRequestedAt: Optional(TDateString73),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString73),
  cancelledAt: Optional(TDateString73),
  concurrencyPool: Optional(TConcurrencyPool45),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext45),
  usedSecrets: Optional(Array2(TUsedSecret45)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration23),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration23),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString46, cacheKey: Enum(EnvironmentVariableCacheKey70) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString46),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess45)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact45)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest72)),
  previousLayers: Optional(Array2(TLayerWithManifest72)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest72)),
  resolvedImageConfig: Optional(TResolvedImageConfig10),
  filesystemLayers: Optional(Array2(TLayerWithManifest72)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString46)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration45),
      baseConfig: TResolvedBaseConfig13,
      crossRunSource: Optional(TCrossRunSource35)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification45),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath43)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult72)),
  whiteoutLayer: Optional(TLayerWithManifest72),
  outputLayers: Optional(Array2(TLayerWithManifest72)),
  outputImageConfig: Optional(TOutputImageConfig10),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey70) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem72)),
  testResults: Optional(Array2(TTestResults72)),
  artifacts: Optional(Array2(TArtifact72)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents35),
  tips: Array2(TTip49),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps64,
  networkTraffic: TNetworkTraffic45,
  outputRetryActions: Array2(TRetryAction61),
  retryAction: Optional(TRetryAction61),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest72),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString73),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry45 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry45 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString73,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString73),
  mostRecentlyAttemptedAt: Optional(TDateString73),
  finishedAt: Optional(TDateString73),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory19
});
var TGraphRoots45 = Object2({ resolution: Array2(TGraphNodeId46), runtime: Array2(TGraphNodeId46) });
var TRunGraph45 = Object2({
  roots: TGraphRoots45,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId46, Array2(TGraphNodeId46)),
    runtime: Record(TGraphNodeId46, Array2(TGraphNodeId46))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId46, Array2(TGraphNodeId46)),
    runtime: Record(TGraphNodeId46, Array2(TGraphNodeId46))
  }),
  subgraphs: Record(TGraphNodeId46, Object2({ roots: TGraphRoots45 })),
  parents: Record(TGraphNodeId46, TGraphNodeId46),
  definitionOrders: Record(TGraphNodeId46, Number2())
});
var TActor45 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState45 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState45)
});
var ApprovalRequestState42 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState42 || {});
var TApprovalRequest42 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState42)
});
var TRun45 = Object2({
  schemaVersion: Literal(ThisSchemaVersion45),
  persistenceExpiresAtSeconds: TEpochSeconds46,
  runId: String2(),
  createdAt: TDateString73,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor45),
  mintDirectoryArtifact: Optional(TArtifact72),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck9,
  customStatusChecks: Array2(TCustomStatusCheck9),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool45),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration45),
  eventNumber: Number2(),
  retries: Array2(TRetry45),
  approvalRequests: Array2(TApprovalRequest42),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph45,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry45)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey46, TConcurrencyPoolState45),
  baseConfig: Optional(TResolvedBaseConfig13),
  crossRunSource: TCrossRunSource35,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus45),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus45),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus45),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus45),
  resultStatus: Enum(RunResultStatus45),
  waitingForLeaseAt: Optional(TDateString73),
  waitingForManualStartAt: Optional(TDateString73),
  startedAt: Optional(TDateString73),
  cancellationRequestedAt: Optional(TDateString73),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString73),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v83.ts
var ThisSchemaVersion46 = "v83" /* V83 */;
var TTaskOrGroupId74 = TBrandedString();
var TGraphNodeId47 = TBrandedString();
var TTemplateString47 = TBrandedString();
var TEvaluatedString47 = TBrandedString();
var TDateString74 = TBrandedString();
var TEpochSeconds47 = TBrandedNumber();
var TScopedTaskKey47 = TBrandedString();
var TaskType46 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType46 || {});
var TaskResultStatus46 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus46 || {});
var TaskExecutionStatus46 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus46 || {});
var TaskExecutionWaitingSubStatus46 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus46 || {});
var TaskExecutionAbortedSubStatus46 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus46 || {});
var TaskExecutionFinishedSubStatus46 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus46 || {});
var TaskAttemptReason46 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason46 || {});
var BackgroundProcessResultStatus73 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus73 || {});
var BackgroundProcessResultFinishedSubStatus73 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus73 || {});
var RunResultStatus46 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus46 || {});
var RunExecutionStatus46 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus46 || {});
var RunExecutionWaitingSubStatus46 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus46 || {});
var RunExecutionAbortedSubStatus46 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus46 || {});
var RunExecutionFinishedSubStatus46 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus46 || {});
var GitClonePatchStatus2 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus2 || {});
var TSource46 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey71 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey71 || {});
var TExpandedEnvDescriptor46 = Object2({ value: Optional(TTemplateString47), cacheKey: Enum(EnvironmentVariableCacheKey71) });
var TEnvMergeStrategy46 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath73 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern73 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity73 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity73 || {});
var TProblemMatcher73 = Object2({ owner: String2(), severity: Optional(Enum(Severity73)), pattern: Array2(TProblemMatcherPattern73) });
var TProblemPath73 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath46 = Object2({ key: String2(), path: TTemplateString47 });
var TResolvedArtifactPath44 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck46 = Object2({ run: TTemplateString47, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess46 = Object2({
  key: String2(),
  command: TTemplateString47,
  readyCheck: Optional(TExpandedReadyCheck46),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType46 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType46 || {});
var TParallelismValue46 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification46 = Object2({
  cpus: Optional(TTemplateString47),
  memory: Optional(TTemplateString47),
  disk: Object2({ size: Optional(TTemplateString47) }),
  staticIps: Optional(TTemplateString47),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification46 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs46 = Object2({
  values: Optional(Record(String2(), TTemplateString47)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor37 = Object2({ path: TTemplateString47, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor37 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet37 = Union([TTemplateString47, Array2(Union([TTemplateString47, TFilterDescriptor37]))]);
var TInputFilesystemFilter46 = Object2({
  workspace: Optional(TFilterSet37),
  artifacts: Optional(Record(TTemplateString47, TFilterSet37))
});
var TOutputFilesystemFilter46 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration39 = Object2({
  enabled: TTemplateString47,
  ttl: Optional(TTemplateString47)
});
var TTaskDefinitionWithoutParallel46 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification46),
  type: Optional(Enum(TaskType46)),
  after: Optional(TTemplateString47),
  if: Optional(TTemplateString47),
  source: Optional(TSource46),
  cacheConfiguration: TCacheConfiguration39,
  docker: Optional(TTemplateString47),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString47),
  filter: Optional(TInputFilesystemFilter46),
  backgroundProcesses: Optional(Array2(TBackgroundProcess46)),
  toolCache: Optional(TTemplateString47),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor46)),
  envMerge: Optional(Array2(TEnvMergeStrategy46)),
  timeout: Optional(TTemplateString47),
  healthTimeout: Optional(TTemplateString47),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath73)),
  artifactPaths: Optional(Array2(TArtifactPath46)),
  outputs: Optional(TTaskDefinitionOutputs46),
  problemMatchers: Optional(Array2(TProblemMatcher73)),
  problemPaths: Optional(Array2(TProblemPath73)),
  parallelismType: Optional(Enum(ParallelismType46)),
  parallelismValue: Optional(TParallelismValue46),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString47)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString47),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter46),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString47,
      if: Optional(TTemplateString47),
      action: Optional(TTemplateString47)
    })
  )
});
var TCrossRunSource36 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents36 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource36,
  relativeScopedKey: String2()
});
var TTaskDefinition46 = Composite([
  TTaskDefinitionWithoutParallel46,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel46),
    parallelKey: Optional(TTemplateString47),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString47), TTemplateString47]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString47)), TTemplateString47])),
    parallelismTotal: Optional(TTemplateString47)
  })
]);
var TLayerWithManifest73 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId74,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext46 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret46 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess46 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString47,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString47,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult73 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus73),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus73),
  startedAt: Optional(TDateString74),
  completedAt: Optional(TDateString74),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem73 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity73),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary40 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults73 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary40),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest63 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact73 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest63, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact46 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor37)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor37))
      })
    )
  )
});
var TDefaultStatusCheck10 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck10 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration46 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow46 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow46 || {});
var TConcurrencyPool46 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow46) });
var LeaseState46 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState46 || {});
var TTiming65 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps65 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming65)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming65),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming65),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming65.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming65),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming65),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming65),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming65),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming65),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming65),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming65),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming65)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming65.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic46 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig11 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TResolvedImageConfig11 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TRetryAction62 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact73)
});
var TBaseLayer20 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig14 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer20,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit39 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit39 || {});
var TTTL39 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit39)
});
var TResolvedWriteCacheConfiguration24 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL39, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration24 = Object2({
  enabled: Boolean2()
});
var TTip50 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory20 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask46 = Object2({
  schemaVersion: Literal(ThisSchemaVersion46),
  taskId: TTaskOrGroupId74,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId47),
  generatorTaskId: Optional(TTaskOrGroupId74),
  definition: TTaskDefinition46,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus46),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus46),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus46),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus46),
  resultStatus: Enum(TaskResultStatus46),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason46)),
  attemptCounts: Record(TRetryCategory20, Number2()),
  resolvedAt: Optional(TDateString74),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString74),
  debugReadyAt: Optional(TDateString74),
  debugStartedAt: Optional(TDateString74),
  debugEndedAt: Optional(TDateString74),
  cancellationRequestedAt: Optional(TDateString74),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString74),
  cancelledAt: Optional(TDateString74),
  concurrencyPool: Optional(TConcurrencyPool46),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext46),
  usedSecrets: Optional(Array2(TUsedSecret46)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration24),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration24),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString47, cacheKey: Enum(EnvironmentVariableCacheKey71) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString47),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess46)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact46)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest73)),
  previousLayers: Optional(Array2(TLayerWithManifest73)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest73)),
  resolvedImageConfig: Optional(TResolvedImageConfig11),
  filesystemLayers: Optional(Array2(TLayerWithManifest73)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString47)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration46),
      baseConfig: TResolvedBaseConfig14,
      crossRunSource: Optional(TCrossRunSource36)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification46),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath44)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult73)),
  whiteoutLayer: Optional(TLayerWithManifest73),
  outputLayers: Optional(Array2(TLayerWithManifest73)),
  outputImageConfig: Optional(TOutputImageConfig11),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey71) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem73)),
  testResults: Optional(Array2(TTestResults73)),
  artifacts: Optional(Array2(TArtifact73)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents36),
  tips: Array2(TTip50),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps65,
  networkTraffic: TNetworkTraffic46,
  outputRetryActions: Array2(TRetryAction62),
  retryAction: Optional(TRetryAction62),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest73),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString74),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry46 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry46 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString74,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString74),
  mostRecentlyAttemptedAt: Optional(TDateString74),
  finishedAt: Optional(TDateString74),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory20
});
var TGraphRoots46 = Object2({ resolution: Array2(TGraphNodeId47), runtime: Array2(TGraphNodeId47) });
var TRunGraph46 = Object2({
  roots: TGraphRoots46,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId47, Array2(TGraphNodeId47)),
    runtime: Record(TGraphNodeId47, Array2(TGraphNodeId47))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId47, Array2(TGraphNodeId47)),
    runtime: Record(TGraphNodeId47, Array2(TGraphNodeId47))
  }),
  subgraphs: Record(TGraphNodeId47, Object2({ roots: TGraphRoots46 })),
  parents: Record(TGraphNodeId47, TGraphNodeId47),
  definitionOrders: Record(TGraphNodeId47, Number2())
});
var TActor46 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState46 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState46)
});
var ApprovalRequestState43 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState43 || {});
var TApprovalRequest43 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState43)
});
var TRun46 = Object2({
  schemaVersion: Literal(ThisSchemaVersion46),
  persistenceExpiresAtSeconds: TEpochSeconds47,
  runId: String2(),
  createdAt: TDateString74,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor46),
  mintDirectoryArtifact: Optional(TArtifact73),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck10,
  customStatusChecks: Array2(TCustomStatusCheck10),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool46),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration46),
  eventNumber: Number2(),
  retries: Array2(TRetry46),
  approvalRequests: Array2(TApprovalRequest43),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph46,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry46)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey47, TConcurrencyPoolState46),
  baseConfig: Optional(TResolvedBaseConfig14),
  crossRunSource: TCrossRunSource36,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus46),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus46),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus46),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus46),
  resultStatus: Enum(RunResultStatus46),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus2), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString74),
  waitingForManualStartAt: Optional(TDateString74),
  startedAt: Optional(TDateString74),
  cancellationRequestedAt: Optional(TDateString74),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString74),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v84.ts
var ThisSchemaVersion47 = "v84" /* V84 */;
var TTaskOrGroupId75 = TBrandedString();
var TGraphNodeId48 = TBrandedString();
var TTemplateString48 = TBrandedString();
var TEvaluatedString48 = TBrandedString();
var TDateString75 = TBrandedString();
var TEpochSeconds48 = TBrandedNumber();
var TScopedTaskKey48 = TBrandedString();
var TaskType47 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType47 || {});
var TaskResultStatus47 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus47 || {});
var TaskExecutionStatus47 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus47 || {});
var TaskExecutionWaitingSubStatus47 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus47 || {});
var TaskExecutionAbortedSubStatus47 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus47 || {});
var TaskExecutionFinishedSubStatus47 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus47 || {});
var TaskAttemptReason47 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason47 || {});
var BackgroundProcessResultStatus74 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus74 || {});
var BackgroundProcessResultFinishedSubStatus74 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus74 || {});
var RunResultStatus47 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus47 || {});
var RunExecutionStatus47 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus47 || {});
var RunExecutionWaitingSubStatus47 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus47 || {});
var RunExecutionAbortedSubStatus47 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus47 || {});
var RunExecutionFinishedSubStatus47 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus47 || {});
var GitClonePatchStatus3 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus3 || {});
var TSource47 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey72 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey72 || {});
var TExpandedEnvDescriptor47 = Object2({ value: Optional(TTemplateString48), cacheKey: Enum(EnvironmentVariableCacheKey72) });
var TEnvMergeStrategy47 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath74 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern74 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity74 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity74 || {});
var TProblemMatcher74 = Object2({ owner: String2(), severity: Optional(Enum(Severity74)), pattern: Array2(TProblemMatcherPattern74) });
var TProblemPath74 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath47 = Object2({ key: String2(), path: TTemplateString48 });
var TResolvedArtifactPath45 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck47 = Object2({ run: TTemplateString48, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess47 = Object2({
  key: String2(),
  command: TTemplateString48,
  readyCheck: Optional(TExpandedReadyCheck47),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType47 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType47 || {});
var TParallelismValue47 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification47 = Object2({
  cpus: Optional(TTemplateString48),
  memory: Optional(TTemplateString48),
  disk: Object2({ size: Optional(TTemplateString48) }),
  staticIps: Optional(TTemplateString48),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification47 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs47 = Object2({
  values: Optional(Record(String2(), TTemplateString48)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor38 = Object2({ path: TTemplateString48, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor38 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet38 = Union([TTemplateString48, Array2(Union([TTemplateString48, TFilterDescriptor38]))]);
var TInputFilesystemFilter47 = Object2({
  workspace: Optional(TFilterSet38),
  artifacts: Optional(Record(TTemplateString48, TFilterSet38))
});
var TOutputFilesystemFilter47 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration40 = Object2({
  enabled: TTemplateString48,
  ttl: Optional(TTemplateString48)
});
var TTaskDefinitionWithoutParallel47 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification47),
  type: Optional(Enum(TaskType47)),
  after: Optional(TTemplateString48),
  if: Optional(TTemplateString48),
  source: Optional(TSource47),
  cacheConfiguration: TCacheConfiguration40,
  docker: Optional(TTemplateString48),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString48),
  filter: Optional(TInputFilesystemFilter47),
  backgroundProcesses: Optional(Array2(TBackgroundProcess47)),
  toolCache: Optional(TTemplateString48),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor47)),
  envMerge: Optional(Array2(TEnvMergeStrategy47)),
  timeout: Optional(TTemplateString48),
  healthTimeout: Optional(TTemplateString48),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath74)),
  artifactPaths: Optional(Array2(TArtifactPath47)),
  outputs: Optional(TTaskDefinitionOutputs47),
  problemMatchers: Optional(Array2(TProblemMatcher74)),
  problemPaths: Optional(Array2(TProblemPath74)),
  parallelismType: Optional(Enum(ParallelismType47)),
  parallelismValue: Optional(TParallelismValue47),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString48)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString48),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter47),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString48,
      if: Optional(TTemplateString48),
      action: Optional(TTemplateString48)
    })
  )
});
var TCrossRunSource37 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents37 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource37,
  relativeScopedKey: String2()
});
var TTaskDefinition47 = Composite([
  TTaskDefinitionWithoutParallel47,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel47),
    parallelKey: Optional(TTemplateString48),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString48), TTemplateString48]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString48)), TTemplateString48])),
    parallelismTotal: Optional(TTemplateString48)
  })
]);
var TLayerWithManifest74 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId75,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext47 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret47 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess47 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString48,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString48,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult74 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus74),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus74),
  startedAt: Optional(TDateString75),
  completedAt: Optional(TDateString75),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem74 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity74),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary41 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults74 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary41),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest64 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact74 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest64, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact47 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor38)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor38))
      })
    )
  )
});
var TDefaultStatusCheck11 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck11 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration47 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow47 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow47 || {});
var TConcurrencyPool47 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow47) });
var LeaseState47 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState47 || {});
var TTiming66 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps66 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming66)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming66),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming66),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming66.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming66),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming66),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming66),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming66),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming66),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming66),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming66),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming66)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming66.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic47 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig12 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TResolvedImageConfig12 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2())
});
var TRetryAction63 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact74)
});
var TBaseLayer21 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig15 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer21,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit40 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit40 || {});
var TTTL40 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit40)
});
var TResolvedWriteCacheConfiguration25 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL40, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration25 = Object2({
  enabled: Boolean2()
});
var TTip51 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory21 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask47 = Object2({
  schemaVersion: Literal(ThisSchemaVersion47),
  taskId: TTaskOrGroupId75,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId48),
  generatorTaskId: Optional(TTaskOrGroupId75),
  definition: TTaskDefinition47,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus47),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus47),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus47),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus47),
  resultStatus: Enum(TaskResultStatus47),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason47)),
  attemptCounts: Record(TRetryCategory21, Number2()),
  resolvedAt: Optional(TDateString75),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString75),
  debugReadyAt: Optional(TDateString75),
  debugStartedAt: Optional(TDateString75),
  debugEndedAt: Optional(TDateString75),
  cancellationRequestedAt: Optional(TDateString75),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString75),
  cancelledAt: Optional(TDateString75),
  concurrencyPool: Optional(TConcurrencyPool47),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext47),
  usedSecrets: Optional(Array2(TUsedSecret47)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration25),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration25),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString48, cacheKey: Enum(EnvironmentVariableCacheKey72) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString48),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess47)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact47)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest74)),
  previousLayers: Optional(Array2(TLayerWithManifest74)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest74)),
  resolvedImageConfig: Optional(TResolvedImageConfig12),
  filesystemLayers: Optional(Array2(TLayerWithManifest74)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString48)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration47),
      baseConfig: TResolvedBaseConfig15,
      crossRunSource: Optional(TCrossRunSource37)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification47),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath45)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult74)),
  whiteoutLayer: Optional(TLayerWithManifest74),
  outputLayers: Optional(Array2(TLayerWithManifest74)),
  outputImageConfig: Optional(TOutputImageConfig12),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey72) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem74)),
  testResults: Optional(Array2(TTestResults74)),
  artifacts: Optional(Array2(TArtifact74)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents37),
  tips: Array2(TTip51),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps66,
  networkTraffic: TNetworkTraffic47,
  outputRetryActions: Array2(TRetryAction63),
  retryAction: Optional(TRetryAction63),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest74),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString75),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry47 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry47 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString75,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString75),
  mostRecentlyAttemptedAt: Optional(TDateString75),
  finishedAt: Optional(TDateString75),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory21
});
var TGraphRoots47 = Object2({ resolution: Array2(TGraphNodeId48), runtime: Array2(TGraphNodeId48) });
var TRunGraph47 = Object2({
  roots: TGraphRoots47,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId48, Array2(TGraphNodeId48)),
    runtime: Record(TGraphNodeId48, Array2(TGraphNodeId48))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId48, Array2(TGraphNodeId48)),
    runtime: Record(TGraphNodeId48, Array2(TGraphNodeId48))
  }),
  subgraphs: Record(TGraphNodeId48, Object2({ roots: TGraphRoots47 })),
  parents: Record(TGraphNodeId48, TGraphNodeId48),
  definitionOrders: Record(TGraphNodeId48, Number2())
});
var TActor47 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState47 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState47)
});
var ApprovalRequestState44 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState44 || {});
var TApprovalRequest44 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState44)
});
var TRun47 = Object2({
  schemaVersion: Literal(ThisSchemaVersion47),
  persistenceExpiresAtSeconds: TEpochSeconds48,
  runId: String2(),
  createdAt: TDateString75,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor47),
  mintDirectoryArtifact: Optional(TArtifact74),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck11,
  customStatusChecks: Array2(TCustomStatusCheck11),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool47),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration47),
  eventNumber: Number2(),
  retries: Array2(TRetry47),
  approvalRequests: Array2(TApprovalRequest44),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph47,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry47)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey48, TConcurrencyPoolState47),
  baseConfig: Optional(TResolvedBaseConfig15),
  crossRunSource: TCrossRunSource37,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus47),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus47),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus47),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus47),
  resultStatus: Enum(RunResultStatus47),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus3), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString75),
  waitingForManualStartAt: Optional(TDateString75),
  startedAt: Optional(TDateString75),
  cancellationRequestedAt: Optional(TDateString75),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString75),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v85.ts
var ThisSchemaVersion48 = "v85" /* V85 */;
var TTaskOrGroupId76 = TBrandedString();
var TGraphNodeId49 = TBrandedString();
var TTemplateString49 = TBrandedString();
var TEvaluatedString49 = TBrandedString();
var TDateString76 = TBrandedString();
var TEpochSeconds49 = TBrandedNumber();
var TScopedTaskKey49 = TBrandedString();
var TaskType48 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType48 || {});
var TaskResultStatus48 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus48 || {});
var TaskExecutionStatus48 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus48 || {});
var TaskExecutionWaitingSubStatus48 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus48 || {});
var TaskExecutionAbortedSubStatus48 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus48 || {});
var TaskExecutionFinishedSubStatus48 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus48 || {});
var TaskAttemptReason48 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason48 || {});
var BackgroundProcessResultStatus75 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus75 || {});
var BackgroundProcessResultFinishedSubStatus75 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus75 || {});
var RunResultStatus48 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus48 || {});
var RunExecutionStatus48 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus48 || {});
var RunExecutionWaitingSubStatus48 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus48 || {});
var RunExecutionAbortedSubStatus48 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus48 || {});
var RunExecutionFinishedSubStatus48 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus48 || {});
var GitClonePatchStatus4 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus4 || {});
var TSource48 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey73 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey73 || {});
var TExpandedEnvDescriptor48 = Object2({ value: Optional(TTemplateString49), cacheKey: Enum(EnvironmentVariableCacheKey73) });
var TEnvMergeStrategy48 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath75 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern75 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity75 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity75 || {});
var TProblemMatcher75 = Object2({ owner: String2(), severity: Optional(Enum(Severity75)), pattern: Array2(TProblemMatcherPattern75) });
var TProblemPath75 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath48 = Object2({ key: String2(), path: TTemplateString49 });
var TResolvedArtifactPath46 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck48 = Object2({ run: TTemplateString49, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess48 = Object2({
  key: String2(),
  command: TTemplateString49,
  readyCheck: Optional(TExpandedReadyCheck48),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType48 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType48 || {});
var TParallelismValue48 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification48 = Object2({
  cpus: Optional(TTemplateString49),
  memory: Optional(TTemplateString49),
  disk: Object2({ size: Optional(TTemplateString49) }),
  staticIps: Optional(TTemplateString49),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification48 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs48 = Object2({
  values: Optional(Record(String2(), TTemplateString49)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor39 = Object2({ path: TTemplateString49, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor39 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet39 = Union([TTemplateString49, Array2(Union([TTemplateString49, TFilterDescriptor39]))]);
var TInputFilesystemFilter48 = Object2({
  workspace: Optional(TFilterSet39),
  artifacts: Optional(Record(TTemplateString49, TFilterSet39))
});
var TOutputFilesystemFilter48 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration41 = Object2({
  enabled: TTemplateString49,
  ttl: Optional(TTemplateString49)
});
var TTaskDefinitionWithoutParallel48 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification48),
  type: Optional(Enum(TaskType48)),
  after: Optional(TTemplateString49),
  if: Optional(TTemplateString49),
  source: Optional(TSource48),
  cacheConfiguration: TCacheConfiguration41,
  docker: Optional(TTemplateString49),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString49),
  filter: Optional(TInputFilesystemFilter48),
  backgroundProcesses: Optional(Array2(TBackgroundProcess48)),
  toolCache: Optional(TTemplateString49),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor48)),
  envMerge: Optional(Array2(TEnvMergeStrategy48)),
  timeout: Optional(TTemplateString49),
  healthTimeout: Optional(TTemplateString49),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath75)),
  artifactPaths: Optional(Array2(TArtifactPath48)),
  outputs: Optional(TTaskDefinitionOutputs48),
  problemMatchers: Optional(Array2(TProblemMatcher75)),
  problemPaths: Optional(Array2(TProblemPath75)),
  parallelismType: Optional(Enum(ParallelismType48)),
  parallelismValue: Optional(TParallelismValue48),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString49)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString49),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter48),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString49,
      if: Optional(TTemplateString49),
      action: Optional(TTemplateString49)
    })
  )
});
var TCrossRunSource38 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents38 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource38,
  relativeScopedKey: String2()
});
var TTaskDefinition48 = Composite([
  TTaskDefinitionWithoutParallel48,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel48),
    parallelKey: Optional(TTemplateString49),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString49), TTemplateString49]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString49)), TTemplateString49])),
    parallelismTotal: Optional(TTemplateString49)
  })
]);
var TLayerWithManifest75 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId76,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext48 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret48 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess48 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString49,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString49,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult75 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus75),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus75),
  startedAt: Optional(TDateString76),
  completedAt: Optional(TDateString76),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem75 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity75),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary42 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults75 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary42),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest65 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact75 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest65, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact48 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor39)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor39))
      })
    )
  )
});
var TDefaultStatusCheck12 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck12 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration48 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow48 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow48 || {});
var TConcurrencyPool48 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow48) });
var LeaseState48 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState48 || {});
var TTiming67 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps67 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming67)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming67),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming67),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming67.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming67),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming67),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming67),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming67),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming67),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming67),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming67),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming67)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming67.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic48 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig13 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2()),
  os: Optional(String2())
});
var TResolvedImageConfig13 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(String2()),
  entrypoint: Optional(String2()),
  os: Optional(String2())
});
var TRetryAction64 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact75)
});
var TBaseLayer22 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig16 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer22,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit41 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit41 || {});
var TTTL41 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit41)
});
var TResolvedWriteCacheConfiguration26 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL41, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration26 = Object2({
  enabled: Boolean2()
});
var TTip52 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory22 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask48 = Object2({
  schemaVersion: Literal(ThisSchemaVersion48),
  taskId: TTaskOrGroupId76,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId49),
  generatorTaskId: Optional(TTaskOrGroupId76),
  definition: TTaskDefinition48,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus48),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus48),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus48),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus48),
  resultStatus: Enum(TaskResultStatus48),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason48)),
  attemptCounts: Record(TRetryCategory22, Number2()),
  resolvedAt: Optional(TDateString76),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString76),
  debugReadyAt: Optional(TDateString76),
  debugStartedAt: Optional(TDateString76),
  debugEndedAt: Optional(TDateString76),
  cancellationRequestedAt: Optional(TDateString76),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString76),
  cancelledAt: Optional(TDateString76),
  concurrencyPool: Optional(TConcurrencyPool48),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext48),
  usedSecrets: Optional(Array2(TUsedSecret48)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration26),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration26),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString49, cacheKey: Enum(EnvironmentVariableCacheKey73) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString49),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess48)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact48)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest75)),
  previousLayers: Optional(Array2(TLayerWithManifest75)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest75)),
  resolvedImageConfig: Optional(TResolvedImageConfig13),
  filesystemLayers: Optional(Array2(TLayerWithManifest75)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString49)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration48),
      baseConfig: TResolvedBaseConfig16,
      crossRunSource: Optional(TCrossRunSource38)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification48),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath46)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult75)),
  whiteoutLayer: Optional(TLayerWithManifest75),
  outputLayers: Optional(Array2(TLayerWithManifest75)),
  outputImageConfig: Optional(TOutputImageConfig13),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey73) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem75)),
  testResults: Optional(Array2(TTestResults75)),
  artifacts: Optional(Array2(TArtifact75)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents38),
  tips: Array2(TTip52),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps67,
  networkTraffic: TNetworkTraffic48,
  outputRetryActions: Array2(TRetryAction64),
  retryAction: Optional(TRetryAction64),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest75),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString76),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry48 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry48 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString76,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString76),
  mostRecentlyAttemptedAt: Optional(TDateString76),
  finishedAt: Optional(TDateString76),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory22
});
var TGraphRoots48 = Object2({ resolution: Array2(TGraphNodeId49), runtime: Array2(TGraphNodeId49) });
var TRunGraph48 = Object2({
  roots: TGraphRoots48,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId49, Array2(TGraphNodeId49)),
    runtime: Record(TGraphNodeId49, Array2(TGraphNodeId49))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId49, Array2(TGraphNodeId49)),
    runtime: Record(TGraphNodeId49, Array2(TGraphNodeId49))
  }),
  subgraphs: Record(TGraphNodeId49, Object2({ roots: TGraphRoots48 })),
  parents: Record(TGraphNodeId49, TGraphNodeId49),
  definitionOrders: Record(TGraphNodeId49, Number2())
});
var TActor48 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState48 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState48)
});
var ApprovalRequestState45 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState45 || {});
var TApprovalRequest45 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState45)
});
var TRun48 = Object2({
  schemaVersion: Literal(ThisSchemaVersion48),
  persistenceExpiresAtSeconds: TEpochSeconds49,
  runId: String2(),
  createdAt: TDateString76,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor48),
  mintDirectoryArtifact: Optional(TArtifact75),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck12,
  customStatusChecks: Array2(TCustomStatusCheck12),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool48),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration48),
  eventNumber: Number2(),
  retries: Array2(TRetry48),
  approvalRequests: Array2(TApprovalRequest45),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph48,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry48)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey49, TConcurrencyPoolState48),
  baseConfig: Optional(TResolvedBaseConfig16),
  crossRunSource: TCrossRunSource38,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus48),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus48),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus48),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus48),
  resultStatus: Enum(RunResultStatus48),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus4), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString76),
  waitingForManualStartAt: Optional(TDateString76),
  startedAt: Optional(TDateString76),
  cancellationRequestedAt: Optional(TDateString76),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString76),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v86.ts
var ThisSchemaVersion49 = "v86" /* V86 */;
var TTaskOrGroupId77 = TBrandedString();
var TGraphNodeId50 = TBrandedString();
var TTemplateString50 = TBrandedString();
var TEvaluatedString50 = TBrandedString();
var TDateString77 = TBrandedString();
var TEpochSeconds50 = TBrandedNumber();
var TScopedTaskKey50 = TBrandedString();
var TaskType49 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType49 || {});
var TaskResultStatus49 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus49 || {});
var TaskExecutionStatus49 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus49 || {});
var TaskExecutionWaitingSubStatus49 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus49 || {});
var TaskExecutionAbortedSubStatus49 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus49 || {});
var TaskExecutionFinishedSubStatus49 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus49 || {});
var TaskAttemptReason49 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason49 || {});
var BackgroundProcessResultStatus76 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus76 || {});
var BackgroundProcessResultFinishedSubStatus76 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus76 || {});
var RunResultStatus49 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus49 || {});
var RunExecutionStatus49 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus49 || {});
var RunExecutionWaitingSubStatus49 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus49 || {});
var RunExecutionAbortedSubStatus49 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus49 || {});
var RunExecutionFinishedSubStatus49 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus49 || {});
var GitClonePatchStatus5 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus5 || {});
var TSource49 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey74 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey74 || {});
var TExpandedEnvDescriptor49 = Object2({ value: Optional(TTemplateString50), cacheKey: Enum(EnvironmentVariableCacheKey74) });
var TEnvMergeStrategy49 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath76 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern76 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity76 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity76 || {});
var TProblemMatcher76 = Object2({ owner: String2(), severity: Optional(Enum(Severity76)), pattern: Array2(TProblemMatcherPattern76) });
var TProblemPath76 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath49 = Object2({ key: String2(), path: TTemplateString50 });
var TResolvedArtifactPath47 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck49 = Object2({ run: TTemplateString50, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess49 = Object2({
  key: String2(),
  command: TTemplateString50,
  readyCheck: Optional(TExpandedReadyCheck49),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType49 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType49 || {});
var TParallelismValue49 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification49 = Object2({
  cpus: Optional(TTemplateString50),
  memory: Optional(TTemplateString50),
  disk: Object2({ size: Optional(TTemplateString50) }),
  staticIps: Optional(TTemplateString50),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification49 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs49 = Object2({
  values: Optional(Record(String2(), TTemplateString50)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor40 = Object2({ path: TTemplateString50, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor40 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet40 = Union([TTemplateString50, Array2(Union([TTemplateString50, TFilterDescriptor40]))]);
var TInputFilesystemFilter49 = Object2({
  workspace: Optional(TFilterSet40),
  artifacts: Optional(Record(TTemplateString50, TFilterSet40))
});
var TOutputFilesystemFilter49 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration42 = Object2({
  enabled: TTemplateString50,
  ttl: Optional(TTemplateString50)
});
var TTaskDefinitionWithoutParallel49 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification49),
  type: Optional(Enum(TaskType49)),
  after: Optional(TTemplateString50),
  if: Optional(TTemplateString50),
  source: Optional(TSource49),
  cacheConfiguration: TCacheConfiguration42,
  docker: Optional(TTemplateString50),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString50),
  filter: Optional(TInputFilesystemFilter49),
  backgroundProcesses: Optional(Array2(TBackgroundProcess49)),
  toolCache: Optional(TTemplateString50),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor49)),
  envMerge: Optional(Array2(TEnvMergeStrategy49)),
  timeout: Optional(TTemplateString50),
  healthTimeout: Optional(TTemplateString50),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath76)),
  artifactPaths: Optional(Array2(TArtifactPath49)),
  outputs: Optional(TTaskDefinitionOutputs49),
  problemMatchers: Optional(Array2(TProblemMatcher76)),
  problemPaths: Optional(Array2(TProblemPath76)),
  parallelismType: Optional(Enum(ParallelismType49)),
  parallelismValue: Optional(TParallelismValue49),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString50)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString50),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter49),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString50,
      if: Optional(TTemplateString50),
      action: Optional(TTemplateString50)
    })
  )
});
var TCrossRunSource39 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents39 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource39,
  relativeScopedKey: String2()
});
var TTaskDefinition49 = Composite([
  TTaskDefinitionWithoutParallel49,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel49),
    parallelKey: Optional(TTemplateString50),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString50), TTemplateString50]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString50)), TTemplateString50])),
    parallelismTotal: Optional(TTemplateString50)
  })
]);
var TLayerWithManifest76 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId77,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext49 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret49 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess49 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString50,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString50,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult76 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus76),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus76),
  startedAt: Optional(TDateString77),
  completedAt: Optional(TDateString77),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem76 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity76),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary43 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults76 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary43),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest66 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact76 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest66, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact49 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor40)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor40))
      })
    )
  )
});
var TDefaultStatusCheck13 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck13 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration49 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow49 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow49 || {});
var TConcurrencyPool49 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow49) });
var LeaseState49 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState49 || {});
var TTiming68 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps68 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming68)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming68),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming68),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming68.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming68),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming68),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming68),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming68),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming68),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming68),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming68),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming68)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming68.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic49 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig14 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  os: Optional(String2())
});
var TResolvedImageConfig14 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  os: Optional(String2())
});
var TRetryAction65 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact76)
});
var TBaseLayer23 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig17 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer23,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit42 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit42 || {});
var TTTL42 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit42)
});
var TResolvedWriteCacheConfiguration27 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL42, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration27 = Object2({
  enabled: Boolean2()
});
var TTip53 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory23 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask49 = Object2({
  schemaVersion: Literal(ThisSchemaVersion49),
  taskId: TTaskOrGroupId77,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId50),
  generatorTaskId: Optional(TTaskOrGroupId77),
  definition: TTaskDefinition49,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus49),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus49),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus49),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus49),
  resultStatus: Enum(TaskResultStatus49),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason49)),
  attemptCounts: Record(TRetryCategory23, Number2()),
  resolvedAt: Optional(TDateString77),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString77),
  debugReadyAt: Optional(TDateString77),
  debugStartedAt: Optional(TDateString77),
  debugEndedAt: Optional(TDateString77),
  cancellationRequestedAt: Optional(TDateString77),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString77),
  cancelledAt: Optional(TDateString77),
  concurrencyPool: Optional(TConcurrencyPool49),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext49),
  usedSecrets: Optional(Array2(TUsedSecret49)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration27),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration27),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString50, cacheKey: Enum(EnvironmentVariableCacheKey74) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString50),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess49)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact49)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest76)),
  previousLayers: Optional(Array2(TLayerWithManifest76)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest76)),
  resolvedImageConfig: Optional(TResolvedImageConfig14),
  filesystemLayers: Optional(Array2(TLayerWithManifest76)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString50)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration49),
      baseConfig: TResolvedBaseConfig17,
      crossRunSource: Optional(TCrossRunSource39)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification49),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath47)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult76)),
  whiteoutLayer: Optional(TLayerWithManifest76),
  outputLayers: Optional(Array2(TLayerWithManifest76)),
  outputImageConfig: Optional(TOutputImageConfig14),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey74) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem76)),
  testResults: Optional(Array2(TTestResults76)),
  artifacts: Optional(Array2(TArtifact76)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents39),
  tips: Array2(TTip53),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps68,
  networkTraffic: TNetworkTraffic49,
  outputRetryActions: Array2(TRetryAction65),
  retryAction: Optional(TRetryAction65),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest76),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString77),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry49 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry49 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString77,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString77),
  mostRecentlyAttemptedAt: Optional(TDateString77),
  finishedAt: Optional(TDateString77),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory23
});
var TGraphRoots49 = Object2({ resolution: Array2(TGraphNodeId50), runtime: Array2(TGraphNodeId50) });
var TRunGraph49 = Object2({
  roots: TGraphRoots49,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId50, Array2(TGraphNodeId50)),
    runtime: Record(TGraphNodeId50, Array2(TGraphNodeId50))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId50, Array2(TGraphNodeId50)),
    runtime: Record(TGraphNodeId50, Array2(TGraphNodeId50))
  }),
  subgraphs: Record(TGraphNodeId50, Object2({ roots: TGraphRoots49 })),
  parents: Record(TGraphNodeId50, TGraphNodeId50),
  definitionOrders: Record(TGraphNodeId50, Number2())
});
var TActor49 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState49 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState49)
});
var ApprovalRequestState46 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState46 || {});
var TApprovalRequest46 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState46)
});
var TRun49 = Object2({
  schemaVersion: Literal(ThisSchemaVersion49),
  persistenceExpiresAtSeconds: TEpochSeconds50,
  runId: String2(),
  createdAt: TDateString77,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor49),
  mintDirectoryArtifact: Optional(TArtifact76),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck13,
  customStatusChecks: Array2(TCustomStatusCheck13),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool49),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration49),
  eventNumber: Number2(),
  retries: Array2(TRetry49),
  approvalRequests: Array2(TApprovalRequest46),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph49,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry49)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey50, TConcurrencyPoolState49),
  baseConfig: Optional(TResolvedBaseConfig17),
  crossRunSource: TCrossRunSource39,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus49),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus49),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus49),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus49),
  resultStatus: Enum(RunResultStatus49),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus5), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString77),
  waitingForManualStartAt: Optional(TDateString77),
  startedAt: Optional(TDateString77),
  cancellationRequestedAt: Optional(TDateString77),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString77),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v87.ts
var ThisSchemaVersion50 = "v87" /* V87 */;
var TTaskOrGroupId78 = TBrandedString();
var TGraphNodeId51 = TBrandedString();
var TTemplateString51 = TBrandedString();
var TEvaluatedString51 = TBrandedString();
var TDateString78 = TBrandedString();
var TEpochSeconds51 = TBrandedNumber();
var TScopedTaskKey51 = TBrandedString();
var TaskType50 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType50 || {});
var TaskResultStatus50 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus50 || {});
var TaskExecutionStatus50 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus50 || {});
var TaskExecutionWaitingSubStatus50 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus50 || {});
var TaskExecutionAbortedSubStatus50 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus50 || {});
var TaskExecutionFinishedSubStatus50 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus50 || {});
var TaskAttemptReason50 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason50 || {});
var BackgroundProcessResultStatus77 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus77 || {});
var BackgroundProcessResultFinishedSubStatus77 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus77 || {});
var RunResultStatus50 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus50 || {});
var RunExecutionStatus50 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus50 || {});
var RunExecutionWaitingSubStatus50 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus50 || {});
var RunExecutionAbortedSubStatus50 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus50 || {});
var RunExecutionFinishedSubStatus50 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus50 || {});
var GitClonePatchStatus6 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus6 || {});
var TSource50 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey75 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey75 || {});
var TExpandedEnvDescriptor50 = Object2({ value: Optional(TTemplateString51), cacheKey: Enum(EnvironmentVariableCacheKey75) });
var TEnvMergeStrategy50 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath77 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern77 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity77 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity77 || {});
var TProblemMatcher77 = Object2({ owner: String2(), severity: Optional(Enum(Severity77)), pattern: Array2(TProblemMatcherPattern77) });
var TProblemPath77 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath50 = Object2({ key: String2(), path: TTemplateString51 });
var TResolvedArtifactPath48 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck50 = Object2({ run: TTemplateString51, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess50 = Object2({
  key: String2(),
  command: TTemplateString51,
  readyCheck: Optional(TExpandedReadyCheck50),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType50 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType50 || {});
var TParallelismValue50 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification50 = Object2({
  cpus: Optional(TTemplateString51),
  memory: Optional(TTemplateString51),
  disk: Object2({ size: Optional(TTemplateString51) }),
  staticIps: Optional(TTemplateString51),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification50 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs50 = Object2({
  values: Optional(Record(String2(), TTemplateString51)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor41 = Object2({ path: TTemplateString51, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor41 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet41 = Union([TTemplateString51, Array2(Union([TTemplateString51, TFilterDescriptor41]))]);
var TInputFilesystemFilter50 = Object2({
  workspace: Optional(TFilterSet41),
  artifacts: Optional(Record(TTemplateString51, TFilterSet41))
});
var TOutputFilesystemFilter50 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration43 = Object2({
  enabled: TTemplateString51,
  ttl: Optional(TTemplateString51)
});
var TTaskDefinitionWithoutParallel50 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification50),
  type: Optional(Enum(TaskType50)),
  after: Optional(TTemplateString51),
  if: Optional(TTemplateString51),
  source: Optional(TSource50),
  cacheConfiguration: TCacheConfiguration43,
  docker: Optional(TTemplateString51),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString51),
  filter: Optional(TInputFilesystemFilter50),
  backgroundProcesses: Optional(Array2(TBackgroundProcess50)),
  toolCache: Optional(TTemplateString51),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor50)),
  envMerge: Optional(Array2(TEnvMergeStrategy50)),
  timeout: Optional(TTemplateString51),
  healthTimeout: Optional(TTemplateString51),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath77)),
  artifactPaths: Optional(Array2(TArtifactPath50)),
  outputs: Optional(TTaskDefinitionOutputs50),
  problemMatchers: Optional(Array2(TProblemMatcher77)),
  problemPaths: Optional(Array2(TProblemPath77)),
  parallelismType: Optional(Enum(ParallelismType50)),
  parallelismValue: Optional(TParallelismValue50),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString51)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString51),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter50),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString51,
      if: Optional(TTemplateString51),
      action: Optional(TTemplateString51)
    })
  )
});
var TCrossRunSource40 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents40 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource40,
  relativeScopedKey: String2()
});
var TTaskDefinition50 = Composite([
  TTaskDefinitionWithoutParallel50,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel50),
    parallelKey: Optional(TTemplateString51),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString51), TTemplateString51]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString51)), TTemplateString51])),
    parallelismTotal: Optional(TTemplateString51)
  })
]);
var TLayerWithManifest77 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId78,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext50 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret50 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess50 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString51,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString51,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult77 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus77),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus77),
  startedAt: Optional(TDateString78),
  completedAt: Optional(TDateString78),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem77 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity77),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary44 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults77 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary44),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest67 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact77 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest67, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact50 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor41)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor41))
      })
    )
  )
});
var TDefaultStatusCheck14 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck14 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration50 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow50 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow50 || {});
var TConcurrencyPool50 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow50) });
var LeaseState50 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState50 || {});
var TTiming69 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps69 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming69)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming69),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming69),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming69.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming69),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming69),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming69),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming69),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming69),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming69),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming69),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming69)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming69.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic50 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig15 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig15 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2())])),
  entrypoint: Optional(Union([String2(), Array2(String2())])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction66 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact77)
});
var TBaseLayer24 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig18 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer24,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit43 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit43 || {});
var TTTL43 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit43)
});
var TResolvedWriteCacheConfiguration28 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL43, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration28 = Object2({
  enabled: Boolean2()
});
var TTip54 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory24 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask50 = Object2({
  schemaVersion: Literal(ThisSchemaVersion50),
  taskId: TTaskOrGroupId78,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId51),
  generatorTaskId: Optional(TTaskOrGroupId78),
  definition: TTaskDefinition50,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus50),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus50),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus50),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus50),
  resultStatus: Enum(TaskResultStatus50),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason50)),
  attemptCounts: Record(TRetryCategory24, Number2()),
  resolvedAt: Optional(TDateString78),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString78),
  debugReadyAt: Optional(TDateString78),
  debugStartedAt: Optional(TDateString78),
  debugEndedAt: Optional(TDateString78),
  cancellationRequestedAt: Optional(TDateString78),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString78),
  cancelledAt: Optional(TDateString78),
  concurrencyPool: Optional(TConcurrencyPool50),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext50),
  usedSecrets: Optional(Array2(TUsedSecret50)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration28),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration28),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString51, cacheKey: Enum(EnvironmentVariableCacheKey75) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString51),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess50)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact50)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest77)),
  previousLayers: Optional(Array2(TLayerWithManifest77)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest77)),
  resolvedImageConfig: Optional(TResolvedImageConfig15),
  filesystemLayers: Optional(Array2(TLayerWithManifest77)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString51)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration50),
      baseConfig: TResolvedBaseConfig18,
      crossRunSource: Optional(TCrossRunSource40)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification50),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath48)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult77)),
  whiteoutLayer: Optional(TLayerWithManifest77),
  outputLayers: Optional(Array2(TLayerWithManifest77)),
  outputImageConfig: Optional(TOutputImageConfig15),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey75) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem77)),
  testResults: Optional(Array2(TTestResults77)),
  artifacts: Optional(Array2(TArtifact77)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents40),
  tips: Array2(TTip54),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps69,
  networkTraffic: TNetworkTraffic50,
  outputRetryActions: Array2(TRetryAction66),
  retryAction: Optional(TRetryAction66),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest77),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString78),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry50 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry50 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString78,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString78),
  mostRecentlyAttemptedAt: Optional(TDateString78),
  finishedAt: Optional(TDateString78),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory24
});
var TGraphRoots50 = Object2({ resolution: Array2(TGraphNodeId51), runtime: Array2(TGraphNodeId51) });
var TRunGraph50 = Object2({
  roots: TGraphRoots50,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId51, Array2(TGraphNodeId51)),
    runtime: Record(TGraphNodeId51, Array2(TGraphNodeId51))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId51, Array2(TGraphNodeId51)),
    runtime: Record(TGraphNodeId51, Array2(TGraphNodeId51))
  }),
  subgraphs: Record(TGraphNodeId51, Object2({ roots: TGraphRoots50 })),
  parents: Record(TGraphNodeId51, TGraphNodeId51),
  definitionOrders: Record(TGraphNodeId51, Number2())
});
var TActor50 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState50 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState50)
});
var ApprovalRequestState47 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState47 || {});
var TApprovalRequest47 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState47)
});
var TRun50 = Object2({
  schemaVersion: Literal(ThisSchemaVersion50),
  persistenceExpiresAtSeconds: TEpochSeconds51,
  runId: String2(),
  createdAt: TDateString78,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor50),
  mintDirectoryArtifact: Optional(TArtifact77),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck14,
  customStatusChecks: Array2(TCustomStatusCheck14),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool50),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration50),
  eventNumber: Number2(),
  retries: Array2(TRetry50),
  approvalRequests: Array2(TApprovalRequest47),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph50,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry50)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey51, TConcurrencyPoolState50),
  baseConfig: Optional(TResolvedBaseConfig18),
  crossRunSource: TCrossRunSource40,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus50),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus50),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus50),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus50),
  resultStatus: Enum(RunResultStatus50),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus6), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString78),
  waitingForManualStartAt: Optional(TDateString78),
  startedAt: Optional(TDateString78),
  cancellationRequestedAt: Optional(TDateString78),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString78),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v88.ts
var ThisSchemaVersion51 = "v88" /* V88 */;
var TTaskOrGroupId79 = TBrandedString();
var TGraphNodeId52 = TBrandedString();
var TTemplateString52 = TBrandedString();
var TEvaluatedString52 = TBrandedString();
var TDateString79 = TBrandedString();
var TEpochSeconds52 = TBrandedNumber();
var TScopedTaskKey52 = TBrandedString();
var TaskType51 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType51 || {});
var TaskResultStatus51 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus51 || {});
var TaskExecutionStatus51 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus51 || {});
var TaskExecutionWaitingSubStatus51 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus51 || {});
var TaskExecutionAbortedSubStatus51 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus51 || {});
var TaskExecutionFinishedSubStatus51 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus51 || {});
var TaskAttemptReason51 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason51 || {});
var BackgroundProcessResultStatus78 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus78 || {});
var BackgroundProcessResultFinishedSubStatus78 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus78 || {});
var RunResultStatus51 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus51 || {});
var RunExecutionStatus51 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus51 || {});
var RunExecutionWaitingSubStatus51 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus51 || {});
var RunExecutionAbortedSubStatus51 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus51 || {});
var RunExecutionFinishedSubStatus51 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus51 || {});
var GitClonePatchStatus7 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus7 || {});
var TSource51 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey76 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey76 || {});
var TExpandedEnvDescriptor51 = Object2({ value: Optional(TTemplateString52), cacheKey: Enum(EnvironmentVariableCacheKey76) });
var TEnvMergeStrategy51 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath78 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern78 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity78 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity78 || {});
var TProblemMatcher78 = Object2({ owner: String2(), severity: Optional(Enum(Severity78)), pattern: Array2(TProblemMatcherPattern78) });
var TProblemPath78 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath51 = Object2({ key: String2(), path: TTemplateString52 });
var TResolvedArtifactPath49 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck51 = Object2({ run: TTemplateString52, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess51 = Object2({
  key: String2(),
  command: TTemplateString52,
  readyCheck: Optional(TExpandedReadyCheck51),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType51 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType51 || {});
var TParallelismValue51 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification51 = Object2({
  cpus: Optional(TTemplateString52),
  memory: Optional(TTemplateString52),
  disk: Object2({ size: Optional(TTemplateString52) }),
  staticIps: Optional(TTemplateString52),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification51 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs51 = Object2({
  values: Optional(Record(String2(), TTemplateString52)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor42 = Object2({ path: TTemplateString52, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor42 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet42 = Union([TTemplateString52, Array2(Union([TTemplateString52, TFilterDescriptor42]))]);
var TInputFilesystemFilter51 = Object2({
  workspace: Optional(TFilterSet42),
  artifacts: Optional(Record(TTemplateString52, TFilterSet42))
});
var TOutputFilesystemFilter51 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration44 = Object2({
  enabled: TTemplateString52,
  ttl: Optional(TTemplateString52)
});
var TTaskDefinitionWithoutParallel51 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification51),
  type: Optional(Enum(TaskType51)),
  after: Optional(TTemplateString52),
  if: Optional(TTemplateString52),
  source: Optional(TSource51),
  cacheConfiguration: TCacheConfiguration44,
  docker: Optional(TTemplateString52),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString52),
  filter: Optional(TInputFilesystemFilter51),
  backgroundProcesses: Optional(Array2(TBackgroundProcess51)),
  toolCache: Optional(TTemplateString52),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor51)),
  envMerge: Optional(Array2(TEnvMergeStrategy51)),
  timeout: Optional(TTemplateString52),
  healthTimeout: Optional(TTemplateString52),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath78)),
  artifactPaths: Optional(Array2(TArtifactPath51)),
  outputs: Optional(TTaskDefinitionOutputs51),
  problemMatchers: Optional(Array2(TProblemMatcher78)),
  problemPaths: Optional(Array2(TProblemPath78)),
  parallelismType: Optional(Enum(ParallelismType51)),
  parallelismValue: Optional(TParallelismValue51),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString52)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString52),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter51),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString52,
      if: Optional(TTemplateString52),
      action: Optional(TTemplateString52)
    })
  )
});
var TCrossRunSource41 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents41 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource41,
  relativeScopedKey: String2()
});
var TTaskDefinition51 = Composite([
  TTaskDefinitionWithoutParallel51,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel51),
    parallelKey: Optional(TTemplateString52),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString52), TTemplateString52]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString52)), TTemplateString52])),
    parallelismTotal: Optional(TTemplateString52)
  })
]);
var TLayerWithManifest78 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId79,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext51 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret51 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess51 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString52,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString52,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult78 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus78),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus78),
  startedAt: Optional(TDateString79),
  completedAt: Optional(TDateString79),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem78 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity78),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary45 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults78 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary45),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest68 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact78 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest68, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact51 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor42)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor42))
      })
    )
  )
});
var TDefaultStatusCheck15 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck15 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration51 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow51 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow51 || {});
var TConcurrencyPool51 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow51) });
var LeaseState51 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState51 || {});
var TTiming70 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps70 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming70)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming70),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming70),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming70.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming70),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming70),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming70),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming70),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming70),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming70),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming70),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming70)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming70.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic51 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig16 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig16 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction67 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact78)
});
var TBaseLayer25 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig19 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer25,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit44 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit44 || {});
var TTTL44 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit44)
});
var TResolvedWriteCacheConfiguration29 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL44, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration29 = Object2({
  enabled: Boolean2()
});
var TTip55 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory25 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask51 = Object2({
  schemaVersion: Literal(ThisSchemaVersion51),
  taskId: TTaskOrGroupId79,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId52),
  generatorTaskId: Optional(TTaskOrGroupId79),
  definition: TTaskDefinition51,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus51),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus51),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus51),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus51),
  resultStatus: Enum(TaskResultStatus51),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason51)),
  attemptCounts: Record(TRetryCategory25, Number2()),
  resolvedAt: Optional(TDateString79),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString79),
  debugReadyAt: Optional(TDateString79),
  debugStartedAt: Optional(TDateString79),
  debugEndedAt: Optional(TDateString79),
  cancellationRequestedAt: Optional(TDateString79),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString79),
  cancelledAt: Optional(TDateString79),
  concurrencyPool: Optional(TConcurrencyPool51),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext51),
  usedSecrets: Optional(Array2(TUsedSecret51)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration29),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration29),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString52, cacheKey: Enum(EnvironmentVariableCacheKey76) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString52),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess51)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact51)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest78)),
  previousLayers: Optional(Array2(TLayerWithManifest78)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest78)),
  resolvedImageConfig: Optional(TResolvedImageConfig16),
  filesystemLayers: Optional(Array2(TLayerWithManifest78)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString52)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration51),
      baseConfig: TResolvedBaseConfig19,
      crossRunSource: Optional(TCrossRunSource41)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification51),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath49)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult78)),
  whiteoutLayer: Optional(TLayerWithManifest78),
  outputLayers: Optional(Array2(TLayerWithManifest78)),
  outputImageConfig: Optional(TOutputImageConfig16),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey76) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem78)),
  testResults: Optional(Array2(TTestResults78)),
  artifacts: Optional(Array2(TArtifact78)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents41),
  tips: Array2(TTip55),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps70,
  networkTraffic: TNetworkTraffic51,
  outputRetryActions: Array2(TRetryAction67),
  retryAction: Optional(TRetryAction67),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest78),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString79),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry51 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry51 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString79,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString79),
  mostRecentlyAttemptedAt: Optional(TDateString79),
  finishedAt: Optional(TDateString79),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory25
});
var TGraphRoots51 = Object2({ resolution: Array2(TGraphNodeId52), runtime: Array2(TGraphNodeId52) });
var TRunGraph51 = Object2({
  roots: TGraphRoots51,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId52, Array2(TGraphNodeId52)),
    runtime: Record(TGraphNodeId52, Array2(TGraphNodeId52))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId52, Array2(TGraphNodeId52)),
    runtime: Record(TGraphNodeId52, Array2(TGraphNodeId52))
  }),
  subgraphs: Record(TGraphNodeId52, Object2({ roots: TGraphRoots51 })),
  parents: Record(TGraphNodeId52, TGraphNodeId52),
  definitionOrders: Record(TGraphNodeId52, Number2())
});
var TActor51 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState51 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState51)
});
var ApprovalRequestState48 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState48 || {});
var TApprovalRequest48 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState48)
});
var TRun51 = Object2({
  schemaVersion: Literal(ThisSchemaVersion51),
  persistenceExpiresAtSeconds: TEpochSeconds52,
  runId: String2(),
  createdAt: TDateString79,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor51),
  mintDirectoryArtifact: Optional(TArtifact78),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck15,
  customStatusChecks: Array2(TCustomStatusCheck15),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool51),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration51),
  eventNumber: Number2(),
  retries: Array2(TRetry51),
  approvalRequests: Array2(TApprovalRequest48),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph51,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry51)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey52, TConcurrencyPoolState51),
  baseConfig: Optional(TResolvedBaseConfig19),
  crossRunSource: TCrossRunSource41,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus51),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus51),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus51),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus51),
  resultStatus: Enum(RunResultStatus51),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus7), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString79),
  waitingForManualStartAt: Optional(TDateString79),
  startedAt: Optional(TDateString79),
  cancellationRequestedAt: Optional(TDateString79),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString79),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v89.ts
var ThisSchemaVersion52 = "v89" /* V89 */;
var TTaskOrGroupId80 = TBrandedString();
var TGraphNodeId53 = TBrandedString();
var TTemplateString53 = TBrandedString();
var TEvaluatedString53 = TBrandedString();
var TDateString80 = TBrandedString();
var TEpochSeconds53 = TBrandedNumber();
var TScopedTaskKey53 = TBrandedString();
var TaskType52 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType52 || {});
var TaskResultStatus52 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus52 || {});
var TaskExecutionStatus52 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus52 || {});
var TaskExecutionWaitingSubStatus52 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus52 || {});
var TaskExecutionAbortedSubStatus52 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus52 || {});
var TaskExecutionFinishedSubStatus52 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus52 || {});
var TaskAttemptReason52 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason52 || {});
var BackgroundProcessResultStatus79 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus79 || {});
var BackgroundProcessResultFinishedSubStatus79 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus79 || {});
var RunResultStatus52 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus52 || {});
var RunExecutionStatus52 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus52 || {});
var RunExecutionWaitingSubStatus52 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus52 || {});
var RunExecutionAbortedSubStatus52 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus52 || {});
var RunExecutionFinishedSubStatus52 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus52 || {});
var GitClonePatchStatus8 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus8 || {});
var TSource52 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey77 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey77 || {});
var TExpandedEnvDescriptor52 = Object2({ value: Optional(TTemplateString53), cacheKey: Enum(EnvironmentVariableCacheKey77) });
var TEnvMergeStrategy52 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath79 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern79 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity79 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity79 || {});
var TProblemMatcher79 = Object2({ owner: String2(), severity: Optional(Enum(Severity79)), pattern: Array2(TProblemMatcherPattern79) });
var TProblemPath79 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath52 = Object2({ key: String2(), path: TTemplateString53 });
var TResolvedArtifactPath50 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck52 = Object2({ run: TTemplateString53, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess52 = Object2({
  key: String2(),
  command: TTemplateString53,
  readyCheck: Optional(TExpandedReadyCheck52),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType52 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType52 || {});
var TParallelismValue52 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification52 = Object2({
  cpus: Optional(TTemplateString53),
  memory: Optional(TTemplateString53),
  disk: Object2({ size: Optional(TTemplateString53) }),
  staticIps: Optional(TTemplateString53),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification52 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs52 = Object2({
  values: Optional(Record(String2(), TTemplateString53)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor43 = Object2({ path: TTemplateString53, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor43 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet43 = Union([TTemplateString53, Array2(Union([TTemplateString53, TFilterDescriptor43]))]);
var TInputFilesystemFilter52 = Object2({
  workspace: Optional(TFilterSet43),
  artifacts: Optional(Record(TTemplateString53, TFilterSet43))
});
var TOutputFilesystemFilter52 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration45 = Object2({
  enabled: TTemplateString53,
  ttl: Optional(TTemplateString53)
});
var TTaskDefinitionWithoutParallel52 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification52),
  type: Optional(Enum(TaskType52)),
  after: Optional(TTemplateString53),
  if: Optional(TTemplateString53),
  source: Optional(TSource52),
  cacheConfiguration: TCacheConfiguration45,
  docker: Optional(TTemplateString53),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString53),
  filter: Optional(TInputFilesystemFilter52),
  backgroundProcesses: Optional(Array2(TBackgroundProcess52)),
  toolCache: Optional(TTemplateString53),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor52)),
  envMerge: Optional(Array2(TEnvMergeStrategy52)),
  timeout: Optional(TTemplateString53),
  healthTimeout: Optional(TTemplateString53),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath79)),
  artifactPaths: Optional(Array2(TArtifactPath52)),
  outputs: Optional(TTaskDefinitionOutputs52),
  problemMatchers: Optional(Array2(TProblemMatcher79)),
  problemPaths: Optional(Array2(TProblemPath79)),
  parallelismType: Optional(Enum(ParallelismType52)),
  parallelismValue: Optional(TParallelismValue52),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString53)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString53),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString53),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter52),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString53,
      if: Optional(TTemplateString53),
      action: Optional(TTemplateString53)
    })
  )
});
var TCrossRunSource42 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents42 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource42,
  relativeScopedKey: String2()
});
var TTaskDefinition52 = Composite([
  TTaskDefinitionWithoutParallel52,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel52),
    parallelKey: Optional(TTemplateString53),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString53), TTemplateString53]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString53)), TTemplateString53])),
    parallelismTotal: Optional(TTemplateString53)
  })
]);
var TLayerWithManifest79 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId80,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext52 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret52 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess52 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString53,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString53,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult79 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus79),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus79),
  startedAt: Optional(TDateString80),
  completedAt: Optional(TDateString80),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem79 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity79),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary46 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults79 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary46),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest69 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact79 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest69, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact52 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor43)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor43))
      })
    )
  )
});
var TDefaultStatusCheck16 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck16 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration52 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow52 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow52 || {});
var TConcurrencyPool52 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow52) });
var LeaseState52 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState52 || {});
var TTiming71 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps71 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming71)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming71),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming71),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming71.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming71),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming71),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming71),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming71),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming71),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming71),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming71),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming71)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming71.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic52 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig17 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig17 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction68 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact79)
});
var TBaseLayer26 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig20 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer26,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit45 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit45 || {});
var TTTL45 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit45)
});
var TResolvedWriteCacheConfiguration30 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL45, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration30 = Object2({
  enabled: Boolean2()
});
var TTip56 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory26 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask52 = Object2({
  schemaVersion: Literal(ThisSchemaVersion52),
  taskId: TTaskOrGroupId80,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId53),
  generatorTaskId: Optional(TTaskOrGroupId80),
  definition: TTaskDefinition52,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus52),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus52),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus52),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus52),
  resultStatus: Enum(TaskResultStatus52),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason52)),
  attemptCounts: Record(TRetryCategory26, Number2()),
  resolvedAt: Optional(TDateString80),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString80),
  debugReadyAt: Optional(TDateString80),
  debugStartedAt: Optional(TDateString80),
  debugEndedAt: Optional(TDateString80),
  cancellationRequestedAt: Optional(TDateString80),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString80),
  cancelledAt: Optional(TDateString80),
  concurrencyPool: Optional(TConcurrencyPool52),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext52),
  usedSecrets: Optional(Array2(TUsedSecret52)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration30),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration30),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString53, cacheKey: Enum(EnvironmentVariableCacheKey77) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString53),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess52)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact52)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest79)),
  previousLayers: Optional(Array2(TLayerWithManifest79)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest79)),
  resolvedImageConfig: Optional(TResolvedImageConfig17),
  filesystemLayers: Optional(Array2(TLayerWithManifest79)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString53)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration52),
      baseConfig: TResolvedBaseConfig20,
      crossRunSource: Optional(TCrossRunSource42)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification52),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath50)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult79)),
  whiteoutLayer: Optional(TLayerWithManifest79),
  outputLayers: Optional(Array2(TLayerWithManifest79)),
  outputImageConfig: Optional(TOutputImageConfig17),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey77) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem79)),
  testResults: Optional(Array2(TTestResults79)),
  artifacts: Optional(Array2(TArtifact79)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents42),
  tips: Array2(TTip56),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps71,
  networkTraffic: TNetworkTraffic52,
  outputRetryActions: Array2(TRetryAction68),
  retryAction: Optional(TRetryAction68),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest79),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString80),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry52 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry52 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString80,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString80),
  mostRecentlyAttemptedAt: Optional(TDateString80),
  finishedAt: Optional(TDateString80),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory26
});
var TGraphRoots52 = Object2({ resolution: Array2(TGraphNodeId53), runtime: Array2(TGraphNodeId53) });
var TRunGraph52 = Object2({
  roots: TGraphRoots52,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId53, Array2(TGraphNodeId53)),
    runtime: Record(TGraphNodeId53, Array2(TGraphNodeId53))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId53, Array2(TGraphNodeId53)),
    runtime: Record(TGraphNodeId53, Array2(TGraphNodeId53))
  }),
  subgraphs: Record(TGraphNodeId53, Object2({ roots: TGraphRoots52 })),
  parents: Record(TGraphNodeId53, TGraphNodeId53),
  definitionOrders: Record(TGraphNodeId53, Number2())
});
var TActor52 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState52 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState52)
});
var ApprovalRequestState49 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState49 || {});
var TApprovalRequest49 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState49)
});
var TRun52 = Object2({
  schemaVersion: Literal(ThisSchemaVersion52),
  persistenceExpiresAtSeconds: TEpochSeconds53,
  runId: String2(),
  createdAt: TDateString80,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor52),
  mintDirectoryArtifact: Optional(TArtifact79),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck16,
  customStatusChecks: Array2(TCustomStatusCheck16),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool52),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration52),
  eventNumber: Number2(),
  retries: Array2(TRetry52),
  approvalRequests: Array2(TApprovalRequest49),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph52,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry52)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey53, TConcurrencyPoolState52),
  baseConfig: Optional(TResolvedBaseConfig20),
  crossRunSource: TCrossRunSource42,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus52),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus52),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus52),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus52),
  resultStatus: Enum(RunResultStatus52),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus8), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString80),
  waitingForManualStartAt: Optional(TDateString80),
  startedAt: Optional(TDateString80),
  cancellationRequestedAt: Optional(TDateString80),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString80),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v90.ts
var ThisSchemaVersion53 = "v90" /* V90 */;
var TTaskOrGroupId81 = TBrandedString();
var TGraphNodeId54 = TBrandedString();
var TTemplateString54 = TBrandedString();
var TEvaluatedString54 = TBrandedString();
var TDateString81 = TBrandedString();
var TEpochSeconds54 = TBrandedNumber();
var TScopedTaskKey54 = TBrandedString();
var TaskType53 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType53 || {});
var TaskResultStatus53 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus53 || {});
var TaskExecutionStatus53 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus53 || {});
var TaskExecutionWaitingSubStatus53 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus53 || {});
var TaskExecutionAbortedSubStatus53 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus53 || {});
var TaskExecutionFinishedSubStatus53 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus53 || {});
var TaskAttemptReason53 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason53 || {});
var BackgroundProcessResultStatus80 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus80 || {});
var BackgroundProcessResultFinishedSubStatus80 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus80 || {});
var RunResultStatus53 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus53 || {});
var RunExecutionStatus53 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus53 || {});
var RunExecutionWaitingSubStatus53 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus53 || {});
var RunExecutionAbortedSubStatus53 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus53 || {});
var RunExecutionFinishedSubStatus53 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus53 || {});
var GitClonePatchStatus9 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus9 || {});
var TSource53 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey78 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey78 || {});
var TExpandedEnvDescriptor53 = Object2({ value: Optional(TTemplateString54), cacheKey: Enum(EnvironmentVariableCacheKey78) });
var TEnvMergeStrategy53 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath80 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern80 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity80 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity80 || {});
var TProblemMatcher80 = Object2({ owner: String2(), severity: Optional(Enum(Severity80)), pattern: Array2(TProblemMatcherPattern80) });
var TProblemPath80 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath53 = Object2({ key: String2(), path: TTemplateString54 });
var TResolvedArtifactPath51 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck53 = Object2({ run: TTemplateString54, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess53 = Object2({
  key: String2(),
  command: TTemplateString54,
  readyCheck: Optional(TExpandedReadyCheck53),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType53 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType53 || {});
var TParallelismValue53 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification53 = Object2({
  cpus: Optional(TTemplateString54),
  memory: Optional(TTemplateString54),
  disk: Object2({ size: Optional(TTemplateString54) }),
  staticIps: Optional(TTemplateString54),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification53 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs53 = Object2({
  values: Optional(Record(String2(), TTemplateString54)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor44 = Object2({ path: TTemplateString54, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor44 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet44 = Union([TTemplateString54, Array2(Union([TTemplateString54, TFilterDescriptor44]))]);
var TInputFilesystemFilter53 = Object2({
  workspace: Optional(TFilterSet44),
  artifacts: Optional(Record(TTemplateString54, TFilterSet44))
});
var TOutputFilesystemFilter53 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration46 = Object2({
  enabled: TTemplateString54,
  ttl: Optional(TTemplateString54)
});
var TTaskDefinitionWithoutParallel53 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification53),
  type: Optional(Enum(TaskType53)),
  after: Optional(TTemplateString54),
  if: Optional(TTemplateString54),
  source: Optional(TSource53),
  cacheConfiguration: TCacheConfiguration46,
  docker: Optional(TTemplateString54),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString54),
  filter: Optional(TInputFilesystemFilter53),
  backgroundProcesses: Optional(Array2(TBackgroundProcess53)),
  toolCache: Optional(TTemplateString54),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor53)),
  envMerge: Optional(Array2(TEnvMergeStrategy53)),
  timeout: Optional(TTemplateString54),
  healthTimeout: Optional(TTemplateString54),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath80)),
  artifactPaths: Optional(Array2(TArtifactPath53)),
  outputs: Optional(TTaskDefinitionOutputs53),
  problemMatchers: Optional(Array2(TProblemMatcher80)),
  problemPaths: Optional(Array2(TProblemPath80)),
  parallelismType: Optional(Enum(ParallelismType53)),
  parallelismValue: Optional(TParallelismValue53),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString54)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString54),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString54),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter53),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString54,
      if: Optional(TTemplateString54),
      action: Optional(TTemplateString54)
    })
  )
});
var TCrossRunSource43 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents43 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource43,
  relativeScopedKey: String2()
});
var TTaskDefinition53 = Composite([
  TTaskDefinitionWithoutParallel53,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel53),
    parallelKey: Optional(TTemplateString54),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString54), TTemplateString54]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString54)), TTemplateString54])),
    parallelismTotal: Optional(TTemplateString54)
  })
]);
var TLayerWithManifest80 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId81,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext53 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret53 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess53 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString54,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString54,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult80 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus80),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus80),
  startedAt: Optional(TDateString81),
  completedAt: Optional(TDateString81),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem80 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity80),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary47 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults80 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary47),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest70 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact80 = Object2({
  kind: TLiteralUnion(["file", "directory", "playwright-trace", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest70, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact53 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "playwright-trace", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor44)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "playwright-trace", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor44))
      })
    )
  )
});
var TDefaultStatusCheck17 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck17 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration53 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow53 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow53 || {});
var TConcurrencyPool53 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow53) });
var LeaseState53 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState53 || {});
var TTiming72 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps72 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming72)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming72),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming72),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming72.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming72),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming72),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming72),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming72),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming72),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming72),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming72),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming72)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming72.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic53 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig18 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig18 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction69 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact80)
});
var TBaseLayer27 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig21 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer27,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit46 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit46 || {});
var TTTL46 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit46)
});
var TResolvedWriteCacheConfiguration31 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL46, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration31 = Object2({
  enabled: Boolean2()
});
var TTip57 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory27 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask53 = Object2({
  schemaVersion: Literal(ThisSchemaVersion53),
  taskId: TTaskOrGroupId81,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId54),
  generatorTaskId: Optional(TTaskOrGroupId81),
  definition: TTaskDefinition53,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus53),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus53),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus53),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus53),
  resultStatus: Enum(TaskResultStatus53),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason53)),
  attemptCounts: Record(TRetryCategory27, Number2()),
  resolvedAt: Optional(TDateString81),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString81),
  debugReadyAt: Optional(TDateString81),
  debugStartedAt: Optional(TDateString81),
  debugEndedAt: Optional(TDateString81),
  cancellationRequestedAt: Optional(TDateString81),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString81),
  cancelledAt: Optional(TDateString81),
  concurrencyPool: Optional(TConcurrencyPool53),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext53),
  usedSecrets: Optional(Array2(TUsedSecret53)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration31),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration31),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString54, cacheKey: Enum(EnvironmentVariableCacheKey78) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString54),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess53)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact53)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest80)),
  previousLayers: Optional(Array2(TLayerWithManifest80)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest80)),
  resolvedImageConfig: Optional(TResolvedImageConfig18),
  filesystemLayers: Optional(Array2(TLayerWithManifest80)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString54)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration53),
      baseConfig: TResolvedBaseConfig21,
      crossRunSource: Optional(TCrossRunSource43)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification53),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath51)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult80)),
  whiteoutLayer: Optional(TLayerWithManifest80),
  outputLayers: Optional(Array2(TLayerWithManifest80)),
  outputImageConfig: Optional(TOutputImageConfig18),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey78) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem80)),
  testResults: Optional(Array2(TTestResults80)),
  artifacts: Optional(Array2(TArtifact80)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents43),
  tips: Array2(TTip57),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps72,
  networkTraffic: TNetworkTraffic53,
  outputRetryActions: Array2(TRetryAction69),
  retryAction: Optional(TRetryAction69),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest80),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString81),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry53 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry53 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString81,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString81),
  mostRecentlyAttemptedAt: Optional(TDateString81),
  finishedAt: Optional(TDateString81),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory27
});
var TGraphRoots53 = Object2({ resolution: Array2(TGraphNodeId54), runtime: Array2(TGraphNodeId54) });
var TRunGraph53 = Object2({
  roots: TGraphRoots53,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId54, Array2(TGraphNodeId54)),
    runtime: Record(TGraphNodeId54, Array2(TGraphNodeId54))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId54, Array2(TGraphNodeId54)),
    runtime: Record(TGraphNodeId54, Array2(TGraphNodeId54))
  }),
  subgraphs: Record(TGraphNodeId54, Object2({ roots: TGraphRoots53 })),
  parents: Record(TGraphNodeId54, TGraphNodeId54),
  definitionOrders: Record(TGraphNodeId54, Number2())
});
var TActor53 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState53 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState53)
});
var ApprovalRequestState50 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState50 || {});
var TApprovalRequest50 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState50)
});
var TRun53 = Object2({
  schemaVersion: Literal(ThisSchemaVersion53),
  persistenceExpiresAtSeconds: TEpochSeconds54,
  runId: String2(),
  createdAt: TDateString81,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor53),
  mintDirectoryArtifact: Optional(TArtifact80),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck17,
  customStatusChecks: Array2(TCustomStatusCheck17),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool53),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration53),
  eventNumber: Number2(),
  retries: Array2(TRetry53),
  approvalRequests: Array2(TApprovalRequest50),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph53,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry53)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey54, TConcurrencyPoolState53),
  baseConfig: Optional(TResolvedBaseConfig21),
  crossRunSource: TCrossRunSource43,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus53),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus53),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus53),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus53),
  resultStatus: Enum(RunResultStatus53),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus9), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString81),
  waitingForManualStartAt: Optional(TDateString81),
  startedAt: Optional(TDateString81),
  cancellationRequestedAt: Optional(TDateString81),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString81),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v91.ts
var ThisSchemaVersion54 = "v91" /* V91 */;
var TTaskOrGroupId82 = TBrandedString();
var TGraphNodeId55 = TBrandedString();
var TTemplateString55 = TBrandedString();
var TEvaluatedString55 = TBrandedString();
var TDateString82 = TBrandedString();
var TEpochSeconds55 = TBrandedNumber();
var TScopedTaskKey55 = TBrandedString();
var TaskType54 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType54 || {});
var TaskResultStatus54 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus54 || {});
var TaskExecutionStatus54 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus54 || {});
var TaskExecutionWaitingSubStatus54 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus54 || {});
var TaskExecutionAbortedSubStatus54 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus54 || {});
var TaskExecutionFinishedSubStatus54 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus54 || {});
var TaskAttemptReason54 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason54 || {});
var BackgroundProcessResultStatus81 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus81 || {});
var BackgroundProcessResultFinishedSubStatus81 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus81 || {});
var RunResultStatus54 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus54 || {});
var RunExecutionStatus54 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus54 || {});
var RunExecutionWaitingSubStatus54 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus54 || {});
var RunExecutionAbortedSubStatus54 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus54 || {});
var RunExecutionFinishedSubStatus54 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus54 || {});
var GitClonePatchStatus10 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus10 || {});
var TSource54 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey79 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey79 || {});
var TExpandedEnvDescriptor54 = Object2({ value: Optional(TTemplateString55), cacheKey: Enum(EnvironmentVariableCacheKey79) });
var TEnvMergeStrategy54 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath81 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern81 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity81 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity81 || {});
var TProblemMatcher81 = Object2({ owner: String2(), severity: Optional(Enum(Severity81)), pattern: Array2(TProblemMatcherPattern81) });
var TProblemPath81 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath54 = Object2({ key: String2(), path: TTemplateString55 });
var TResolvedArtifactPath52 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck54 = Object2({ run: TTemplateString55, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess54 = Object2({
  key: String2(),
  command: TTemplateString55,
  readyCheck: Optional(TExpandedReadyCheck54),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType54 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType54 || {});
var TParallelismValue54 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification54 = Object2({
  cpus: Optional(TTemplateString55),
  memory: Optional(TTemplateString55),
  disk: Object2({ size: Optional(TTemplateString55) }),
  staticIps: Optional(TTemplateString55),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification54 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs54 = Object2({
  values: Optional(Record(String2(), TTemplateString55)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor45 = Object2({ path: TTemplateString55, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor45 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet45 = Union([TTemplateString55, Array2(Union([TTemplateString55, TFilterDescriptor45]))]);
var TInputFilesystemFilter54 = Object2({
  workspace: Optional(TFilterSet45),
  artifacts: Optional(Record(TTemplateString55, TFilterSet45))
});
var TOutputFilesystemFilter54 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration47 = Object2({
  enabled: TTemplateString55,
  ttl: Optional(TTemplateString55)
});
var TTaskDefinitionWithoutParallel54 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification54),
  type: Optional(Enum(TaskType54)),
  after: Optional(TTemplateString55),
  if: Optional(TTemplateString55),
  source: Optional(TSource54),
  cacheConfiguration: TCacheConfiguration47,
  docker: Optional(TTemplateString55),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString55),
  filter: Optional(TInputFilesystemFilter54),
  backgroundProcesses: Optional(Array2(TBackgroundProcess54)),
  toolCache: Optional(TTemplateString55),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor54)),
  envMerge: Optional(Array2(TEnvMergeStrategy54)),
  timeout: Optional(TTemplateString55),
  healthTimeout: Optional(TTemplateString55),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath81)),
  artifactPaths: Optional(Array2(TArtifactPath54)),
  outputs: Optional(TTaskDefinitionOutputs54),
  problemMatchers: Optional(Array2(TProblemMatcher81)),
  problemPaths: Optional(Array2(TProblemPath81)),
  parallelismType: Optional(Enum(ParallelismType54)),
  parallelismValue: Optional(TParallelismValue54),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString55)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString55),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString55),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter54),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString55,
      if: Optional(TTemplateString55),
      action: Optional(TTemplateString55)
    })
  )
});
var TCrossRunSource44 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents44 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource44,
  relativeScopedKey: String2()
});
var TTaskDefinition54 = Composite([
  TTaskDefinitionWithoutParallel54,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel54),
    parallelKey: Optional(TTemplateString55),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString55), TTemplateString55]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString55)), TTemplateString55])),
    parallelismTotal: Optional(TTemplateString55)
  })
]);
var TLayerWithManifest81 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId82,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext54 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret54 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess54 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString55,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString55,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult81 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus81),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus81),
  startedAt: Optional(TDateString82),
  completedAt: Optional(TDateString82),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem81 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity81),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary48 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults81 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary48),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TOutputBlob5 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest71 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact81 = Composite([
  TOutputBlob5,
  Object2({
    manifest: Union([TArtifactManifest71, Null()])
  })
]);
var TReferencedArtifact54 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor45)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor45))
      })
    )
  )
});
var TDefaultStatusCheck18 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck18 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration54 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow54 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow54 || {});
var TConcurrencyPool54 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow54) });
var LeaseState54 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState54 || {});
var TTiming73 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps73 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming73)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming73),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming73),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming73.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming73),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming73),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming73),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming73),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming73),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming73),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming73),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming73)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming73.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic54 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig19 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig19 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction70 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact81)
});
var TBaseLayer28 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig22 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer28,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit47 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit47 || {});
var TTTL47 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit47)
});
var TResolvedWriteCacheConfiguration32 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL47, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration32 = Object2({
  enabled: Boolean2()
});
var TTip58 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory28 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask54 = Object2({
  schemaVersion: Literal(ThisSchemaVersion54),
  taskId: TTaskOrGroupId82,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId55),
  generatorTaskId: Optional(TTaskOrGroupId82),
  definition: TTaskDefinition54,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus54),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus54),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus54),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus54),
  resultStatus: Enum(TaskResultStatus54),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason54)),
  attemptCounts: Record(TRetryCategory28, Number2()),
  resolvedAt: Optional(TDateString82),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString82),
  debugReadyAt: Optional(TDateString82),
  debugStartedAt: Optional(TDateString82),
  debugEndedAt: Optional(TDateString82),
  cancellationRequestedAt: Optional(TDateString82),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString82),
  cancelledAt: Optional(TDateString82),
  concurrencyPool: Optional(TConcurrencyPool54),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext54),
  usedSecrets: Optional(Array2(TUsedSecret54)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration32),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration32),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString55, cacheKey: Enum(EnvironmentVariableCacheKey79) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString55),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess54)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact54)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest81)),
  previousLayers: Optional(Array2(TLayerWithManifest81)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest81)),
  resolvedImageConfig: Optional(TResolvedImageConfig19),
  filesystemLayers: Optional(Array2(TLayerWithManifest81)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString55)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration54),
      baseConfig: TResolvedBaseConfig22,
      crossRunSource: Optional(TCrossRunSource44)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification54),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath52)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult81)),
  whiteoutLayer: Optional(TLayerWithManifest81),
  outputLayers: Optional(Array2(TLayerWithManifest81)),
  outputImageConfig: Optional(TOutputImageConfig19),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey79) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem81)),
  testResults: Optional(Array2(TTestResults81)),
  artifacts: Optional(Array2(TArtifact81)),
  outputBlobs: Optional(Array2(TOutputBlob5)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents44),
  tips: Array2(TTip58),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps73,
  networkTraffic: TNetworkTraffic54,
  outputRetryActions: Array2(TRetryAction70),
  retryAction: Optional(TRetryAction70),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest81),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString82),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2())
});
var TRetryManifestEntry54 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry54 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString82,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString82),
  mostRecentlyAttemptedAt: Optional(TDateString82),
  finishedAt: Optional(TDateString82),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory28
});
var TGraphRoots54 = Object2({ resolution: Array2(TGraphNodeId55), runtime: Array2(TGraphNodeId55) });
var TRunGraph54 = Object2({
  roots: TGraphRoots54,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId55, Array2(TGraphNodeId55)),
    runtime: Record(TGraphNodeId55, Array2(TGraphNodeId55))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId55, Array2(TGraphNodeId55)),
    runtime: Record(TGraphNodeId55, Array2(TGraphNodeId55))
  }),
  subgraphs: Record(TGraphNodeId55, Object2({ roots: TGraphRoots54 })),
  parents: Record(TGraphNodeId55, TGraphNodeId55),
  definitionOrders: Record(TGraphNodeId55, Number2())
});
var TActor54 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState54 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState54)
});
var ApprovalRequestState51 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState51 || {});
var TApprovalRequest51 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState51)
});
var TRun54 = Object2({
  schemaVersion: Literal(ThisSchemaVersion54),
  persistenceExpiresAtSeconds: TEpochSeconds55,
  runId: String2(),
  createdAt: TDateString82,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor54),
  mintDirectoryArtifact: Optional(TArtifact81),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck18,
  customStatusChecks: Array2(TCustomStatusCheck18),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool54),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration54),
  eventNumber: Number2(),
  retries: Array2(TRetry54),
  approvalRequests: Array2(TApprovalRequest51),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph54,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry54)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey55, TConcurrencyPoolState54),
  baseConfig: Optional(TResolvedBaseConfig22),
  crossRunSource: TCrossRunSource44,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus54),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus54),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus54),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus54),
  resultStatus: Enum(RunResultStatus54),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus10), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString82),
  waitingForManualStartAt: Optional(TDateString82),
  startedAt: Optional(TDateString82),
  cancellationRequestedAt: Optional(TDateString82),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString82),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v92.ts
var ThisSchemaVersion55 = "v92" /* V92 */;
var TTaskOrGroupId83 = TBrandedString();
var TGraphNodeId56 = TBrandedString();
var TTemplateString56 = TBrandedString();
var TEvaluatedString56 = TBrandedString();
var TDateString83 = TBrandedString();
var TEpochSeconds56 = TBrandedNumber();
var TScopedTaskKey56 = TBrandedString();
var TaskType55 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType55 || {});
var TaskResultStatus55 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus55 || {});
var TaskExecutionStatus55 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus55 || {});
var TaskExecutionWaitingSubStatus55 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus55 || {});
var TaskExecutionAbortedSubStatus55 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus55 || {});
var TaskExecutionFinishedSubStatus55 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus55 || {});
var TaskAttemptReason55 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason55 || {});
var BackgroundProcessResultStatus82 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus82 || {});
var BackgroundProcessResultFinishedSubStatus82 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus82 || {});
var RunResultStatus55 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus55 || {});
var RunExecutionStatus55 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus55 || {});
var RunExecutionWaitingSubStatus55 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus55 || {});
var RunExecutionAbortedSubStatus55 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus55 || {});
var RunExecutionFinishedSubStatus55 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus55 || {});
var GitClonePatchStatus11 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus11 || {});
var TSource55 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey80 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey80 || {});
var TExpandedEnvDescriptor55 = Object2({ value: Optional(TTemplateString56), cacheKey: Enum(EnvironmentVariableCacheKey80) });
var TEnvMergeStrategy55 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath82 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern82 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity82 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity82 || {});
var TProblemMatcher82 = Object2({ owner: String2(), severity: Optional(Enum(Severity82)), pattern: Array2(TProblemMatcherPattern82) });
var TProblemPath82 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath55 = Object2({ key: String2(), path: TTemplateString56 });
var TResolvedArtifactPath53 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck55 = Object2({ run: TTemplateString56, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess55 = Object2({
  key: String2(),
  command: TTemplateString56,
  readyCheck: Optional(TExpandedReadyCheck55),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType55 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType55 || {});
var TParallelismValue55 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification55 = Object2({
  cpus: Optional(TTemplateString56),
  memory: Optional(TTemplateString56),
  disk: Object2({ size: Optional(TTemplateString56) }),
  staticIps: Optional(TTemplateString56),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification55 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs55 = Object2({
  values: Optional(Record(String2(), TTemplateString56)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor46 = Object2({ path: TTemplateString56, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor46 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet46 = Union([TTemplateString56, Array2(Union([TTemplateString56, TFilterDescriptor46]))]);
var TInputFilesystemFilter55 = Object2({
  workspace: Optional(TFilterSet46),
  artifacts: Optional(Record(TTemplateString56, TFilterSet46))
});
var TOutputFilesystemFilter55 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration48 = Object2({
  enabled: TTemplateString56,
  ttl: Optional(TTemplateString56)
});
var TTaskDefinitionWithoutParallel55 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification55),
  type: Optional(Enum(TaskType55)),
  after: Optional(TTemplateString56),
  if: Optional(TTemplateString56),
  source: Optional(TSource55),
  cacheConfiguration: TCacheConfiguration48,
  docker: Optional(TTemplateString56),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString56),
  filter: Optional(TInputFilesystemFilter55),
  backgroundProcesses: Optional(Array2(TBackgroundProcess55)),
  toolCache: Optional(TTemplateString56),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor55)),
  envMerge: Optional(Array2(TEnvMergeStrategy55)),
  timeout: Optional(TTemplateString56),
  healthTimeout: Optional(TTemplateString56),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath82)),
  artifactPaths: Optional(Array2(TArtifactPath55)),
  outputs: Optional(TTaskDefinitionOutputs55),
  problemMatchers: Optional(Array2(TProblemMatcher82)),
  problemPaths: Optional(Array2(TProblemPath82)),
  parallelismType: Optional(Enum(ParallelismType55)),
  parallelismValue: Optional(TParallelismValue55),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString56)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString56),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString56),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter55),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString56,
      if: Optional(TTemplateString56),
      action: Optional(TTemplateString56)
    })
  ),
  autoCancel: TTemplateString56
});
var TCrossRunSource45 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents45 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource45,
  relativeScopedKey: String2()
});
var TTaskDefinition55 = Composite([
  TTaskDefinitionWithoutParallel55,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel55),
    parallelKey: Optional(TTemplateString56),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString56), TTemplateString56]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString56)), TTemplateString56])),
    parallelismTotal: Optional(TTemplateString56)
  })
]);
var TLayerWithManifest82 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion2),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId83,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext55 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret55 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess55 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString56,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString56,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult82 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus82),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus82),
  startedAt: Optional(TDateString83),
  completedAt: Optional(TDateString83),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem82 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity82),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary49 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults82 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary49),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TOutputBlob6 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest72 = Object2({
  id: String2(),
  version: Enum(SchemaVersion2),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact82 = Composite([
  TOutputBlob6,
  Object2({
    manifest: Union([TArtifactManifest72, Null()])
  })
]);
var TReferencedArtifact55 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor46)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor46))
      })
    )
  )
});
var TDefaultStatusCheck19 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck19 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration55 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow55 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow55 || {});
var TConcurrencyPool55 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow55) });
var LeaseState55 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState55 || {});
var TTiming74 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps74 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming74)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming74),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming74),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming74.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming74),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming74),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming74),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming74),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming74),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming74),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming74),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming74)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming74.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic55 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig20 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig20 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction71 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact82)
});
var TBaseLayer29 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig23 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer29,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit48 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit48 || {});
var TTTL48 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit48)
});
var TResolvedWriteCacheConfiguration33 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL48, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration33 = Object2({
  enabled: Boolean2()
});
var TTip59 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory29 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask55 = Object2({
  schemaVersion: Literal(ThisSchemaVersion55),
  taskId: TTaskOrGroupId83,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId56),
  generatorTaskId: Optional(TTaskOrGroupId83),
  definition: TTaskDefinition55,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus55),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus55),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus55),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus55),
  resultStatus: Enum(TaskResultStatus55),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason55)),
  attemptCounts: Record(TRetryCategory29, Number2()),
  resolvedAt: Optional(TDateString83),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString83),
  debugReadyAt: Optional(TDateString83),
  debugStartedAt: Optional(TDateString83),
  debugEndedAt: Optional(TDateString83),
  cancellationRequestedAt: Optional(TDateString83),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString83),
  cancelledAt: Optional(TDateString83),
  concurrencyPool: Optional(TConcurrencyPool55),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext55),
  usedSecrets: Optional(Array2(TUsedSecret55)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration33),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration33),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString56, cacheKey: Enum(EnvironmentVariableCacheKey80) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString56),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess55)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact55)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest82)),
  previousLayers: Optional(Array2(TLayerWithManifest82)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest82)),
  resolvedImageConfig: Optional(TResolvedImageConfig20),
  filesystemLayers: Optional(Array2(TLayerWithManifest82)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString56)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration55),
      baseConfig: TResolvedBaseConfig23,
      crossRunSource: Optional(TCrossRunSource45)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification55),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath53)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult82)),
  whiteoutLayer: Optional(TLayerWithManifest82),
  outputLayers: Optional(Array2(TLayerWithManifest82)),
  outputImageConfig: Optional(TOutputImageConfig20),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey80) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem82)),
  testResults: Optional(Array2(TTestResults82)),
  artifacts: Optional(Array2(TArtifact82)),
  outputBlobs: Optional(Array2(TOutputBlob6)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents45),
  tips: Array2(TTip59),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps74,
  networkTraffic: TNetworkTraffic55,
  outputRetryActions: Array2(TRetryAction71),
  retryAction: Optional(TRetryAction71),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest82),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString83),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2()),
  resolvedAutoCancel: Optional(Boolean2())
});
var TRetryManifestEntry55 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry55 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString83,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString83),
  mostRecentlyAttemptedAt: Optional(TDateString83),
  finishedAt: Optional(TDateString83),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory29
});
var TGraphRoots55 = Object2({ resolution: Array2(TGraphNodeId56), runtime: Array2(TGraphNodeId56) });
var TRunGraph55 = Object2({
  roots: TGraphRoots55,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId56, Array2(TGraphNodeId56)),
    runtime: Record(TGraphNodeId56, Array2(TGraphNodeId56))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId56, Array2(TGraphNodeId56)),
    runtime: Record(TGraphNodeId56, Array2(TGraphNodeId56))
  }),
  subgraphs: Record(TGraphNodeId56, Object2({ roots: TGraphRoots55 })),
  parents: Record(TGraphNodeId56, TGraphNodeId56),
  definitionOrders: Record(TGraphNodeId56, Number2())
});
var TActor55 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState55 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState55)
});
var ApprovalRequestState52 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState52 || {});
var TApprovalRequest52 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState52)
});
var TRun55 = Object2({
  schemaVersion: Literal(ThisSchemaVersion55),
  persistenceExpiresAtSeconds: TEpochSeconds56,
  runId: String2(),
  createdAt: TDateString83,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor55),
  mintDirectoryArtifact: Optional(TArtifact82),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck19,
  customStatusChecks: Array2(TCustomStatusCheck19),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool55),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration55),
  eventNumber: Number2(),
  retries: Array2(TRetry55),
  approvalRequests: Array2(TApprovalRequest52),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph55,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry55)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey56, TConcurrencyPoolState55),
  baseConfig: Optional(TResolvedBaseConfig23),
  crossRunSource: TCrossRunSource45,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus55),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus55),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus55),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus55),
  resultStatus: Enum(RunResultStatus55),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus11), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString83),
  waitingForManualStartAt: Optional(TDateString83),
  startedAt: Optional(TDateString83),
  cancellationRequestedAt: Optional(TDateString83),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString83),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v93.ts
var ThisSchemaVersion56 = "v93" /* V93 */;
var TTaskOrGroupId84 = TBrandedString();
var TGraphNodeId57 = TBrandedString();
var TTemplateString57 = TBrandedString();
var TEvaluatedString57 = TBrandedString();
var TDateString84 = TBrandedString();
var TEpochSeconds57 = TBrandedNumber();
var TScopedTaskKey57 = TBrandedString();
var TaskType56 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType56 || {});
var TaskResultStatus56 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus56 || {});
var TaskExecutionStatus56 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus56 || {});
var TaskExecutionWaitingSubStatus56 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus56 || {});
var TaskExecutionAbortedSubStatus56 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus56 || {});
var TaskExecutionFinishedSubStatus56 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus56 || {});
var TaskAttemptReason56 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason56 || {});
var BackgroundProcessResultStatus83 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus83 || {});
var BackgroundProcessResultFinishedSubStatus83 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus83 || {});
var RunResultStatus56 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus56 || {});
var RunExecutionStatus56 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus56 || {});
var RunExecutionWaitingSubStatus56 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus56 || {});
var RunExecutionAbortedSubStatus56 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus56 || {});
var RunExecutionFinishedSubStatus56 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus56 || {});
var GitClonePatchStatus12 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus12 || {});
var TSource56 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey81 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey81 || {});
var TExpandedEnvDescriptor56 = Object2({ value: Optional(TTemplateString57), cacheKey: Enum(EnvironmentVariableCacheKey81) });
var TEnvMergeStrategy56 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath83 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern83 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity83 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity83 || {});
var TProblemMatcher83 = Object2({ owner: String2(), severity: Optional(Enum(Severity83)), pattern: Array2(TProblemMatcherPattern83) });
var TProblemPath83 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath56 = Object2({ key: String2(), path: TTemplateString57 });
var TResolvedArtifactPath54 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck56 = Object2({ run: TTemplateString57, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess56 = Object2({
  key: String2(),
  command: TTemplateString57,
  readyCheck: Optional(TExpandedReadyCheck56),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType56 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType56 || {});
var TParallelismValue56 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification56 = Object2({
  cpus: Optional(TTemplateString57),
  memory: Optional(TTemplateString57),
  disk: Object2({ size: Optional(TTemplateString57) }),
  staticIps: Optional(TTemplateString57),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification56 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs56 = Object2({
  values: Optional(Record(String2(), TTemplateString57)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor47 = Object2({ path: TTemplateString57, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor47 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet47 = Union([TTemplateString57, Array2(Union([TTemplateString57, TFilterDescriptor47]))]);
var TInputFilesystemFilter56 = Object2({
  workspace: Optional(TFilterSet47),
  artifacts: Optional(Record(TTemplateString57, TFilterSet47))
});
var TOutputFilesystemFilter56 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration49 = Object2({
  enabled: TTemplateString57,
  ttl: Optional(TTemplateString57)
});
var TTaskDefinitionWithoutParallel56 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification56),
  type: Optional(Enum(TaskType56)),
  after: Optional(TTemplateString57),
  if: Optional(TTemplateString57),
  source: Optional(TSource56),
  cacheConfiguration: TCacheConfiguration49,
  docker: Optional(TTemplateString57),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString57),
  filter: Optional(TInputFilesystemFilter56),
  backgroundProcesses: Optional(Array2(TBackgroundProcess56)),
  toolCache: Optional(TTemplateString57),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor56)),
  envMerge: Optional(Array2(TEnvMergeStrategy56)),
  timeout: Optional(TTemplateString57),
  healthTimeout: Optional(TTemplateString57),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath83)),
  artifactPaths: Optional(Array2(TArtifactPath56)),
  outputs: Optional(TTaskDefinitionOutputs56),
  problemMatchers: Optional(Array2(TProblemMatcher83)),
  problemPaths: Optional(Array2(TProblemPath83)),
  parallelismType: Optional(Enum(ParallelismType56)),
  parallelismValue: Optional(TParallelismValue56),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString57)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString57),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString57),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter56),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString57,
      if: Optional(TTemplateString57),
      action: Optional(TTemplateString57)
    })
  ),
  autoCancel: TTemplateString57
});
var TCrossRunSource46 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents46 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource46,
  relativeScopedKey: String2()
});
var TTaskDefinition56 = Composite([
  TTaskDefinitionWithoutParallel56,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel56),
    parallelKey: Optional(TTemplateString57),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString57), TTemplateString57]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString57)), TTemplateString57])),
    parallelismTotal: Optional(TTemplateString57)
  })
]);
var TLayerWithManifest83 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestCliVersion: String2(),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId84,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext56 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret56 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess56 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString57,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString57,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult83 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus83),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus83),
  startedAt: Optional(TDateString84),
  completedAt: Optional(TDateString84),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem83 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity83),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary50 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults83 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary50),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TOutputBlob7 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest73 = Object2({
  id: String2(),
  cliVersion: String2(),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact83 = Composite([
  TOutputBlob7,
  Object2({
    manifest: Union([TArtifactManifest73, Null()])
  })
]);
var TReferencedArtifact56 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor47)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor47))
      })
    )
  )
});
var TDefaultStatusCheck20 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck20 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration56 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow56 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow56 || {});
var TConcurrencyPool56 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow56) });
var LeaseState56 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState56 || {});
var TTiming75 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps75 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming75)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming75),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming75),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming75.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming75),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming75),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming75),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming75),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming75),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming75),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming75),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming75)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming75.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic56 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig21 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TResolvedImageConfig21 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2())
});
var TRetryAction72 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact83)
});
var TBaseLayer30 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig24 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer30,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit49 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit49 || {});
var TTTL49 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit49)
});
var TResolvedWriteCacheConfiguration34 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL49, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration34 = Object2({
  enabled: Boolean2()
});
var TTip60 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory30 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask56 = Object2({
  schemaVersion: Literal(ThisSchemaVersion56),
  taskId: TTaskOrGroupId84,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId57),
  generatorTaskId: Optional(TTaskOrGroupId84),
  definition: TTaskDefinition56,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus56),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus56),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus56),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus56),
  resultStatus: Enum(TaskResultStatus56),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason56)),
  attemptCounts: Record(TRetryCategory30, Number2()),
  resolvedAt: Optional(TDateString84),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString84),
  debugReadyAt: Optional(TDateString84),
  debugStartedAt: Optional(TDateString84),
  debugEndedAt: Optional(TDateString84),
  cancellationRequestedAt: Optional(TDateString84),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString84),
  cancelledAt: Optional(TDateString84),
  concurrencyPool: Optional(TConcurrencyPool56),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext56),
  usedSecrets: Optional(Array2(TUsedSecret56)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration34),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration34),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString57, cacheKey: Enum(EnvironmentVariableCacheKey81) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString57),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess56)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact56)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest83)),
  previousLayers: Optional(Array2(TLayerWithManifest83)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest83)),
  resolvedImageConfig: Optional(TResolvedImageConfig21),
  filesystemLayers: Optional(Array2(TLayerWithManifest83)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString57)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration56),
      baseConfig: TResolvedBaseConfig24,
      crossRunSource: Optional(TCrossRunSource46)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification56),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath54)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult83)),
  whiteoutLayer: Optional(TLayerWithManifest83),
  outputLayers: Optional(Array2(TLayerWithManifest83)),
  outputImageConfig: Optional(TOutputImageConfig21),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey81) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem83)),
  testResults: Optional(Array2(TTestResults83)),
  artifacts: Optional(Array2(TArtifact83)),
  outputBlobs: Optional(Array2(TOutputBlob7)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents46),
  tips: Array2(TTip60),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps75,
  networkTraffic: TNetworkTraffic56,
  outputRetryActions: Array2(TRetryAction72),
  retryAction: Optional(TRetryAction72),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest83),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString84),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2()),
  resolvedAutoCancel: Optional(Boolean2())
});
var TRetryManifestEntry56 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry56 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString84,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString84),
  mostRecentlyAttemptedAt: Optional(TDateString84),
  finishedAt: Optional(TDateString84),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory30
});
var TGraphRoots56 = Object2({ resolution: Array2(TGraphNodeId57), runtime: Array2(TGraphNodeId57) });
var TRunGraph56 = Object2({
  roots: TGraphRoots56,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId57, Array2(TGraphNodeId57)),
    runtime: Record(TGraphNodeId57, Array2(TGraphNodeId57))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId57, Array2(TGraphNodeId57)),
    runtime: Record(TGraphNodeId57, Array2(TGraphNodeId57))
  }),
  subgraphs: Record(TGraphNodeId57, Object2({ roots: TGraphRoots56 })),
  parents: Record(TGraphNodeId57, TGraphNodeId57),
  definitionOrders: Record(TGraphNodeId57, Number2())
});
var TActor56 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState56 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState56)
});
var ApprovalRequestState53 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState53 || {});
var TApprovalRequest53 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState53)
});
var TRun56 = Object2({
  schemaVersion: Literal(ThisSchemaVersion56),
  persistenceExpiresAtSeconds: TEpochSeconds57,
  runId: String2(),
  createdAt: TDateString84,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor56),
  mintDirectoryArtifact: Optional(TArtifact83),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck20,
  customStatusChecks: Array2(TCustomStatusCheck20),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool56),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration56),
  eventNumber: Number2(),
  retries: Array2(TRetry56),
  approvalRequests: Array2(TApprovalRequest53),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph56,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry56)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey57, TConcurrencyPoolState56),
  baseConfig: Optional(TResolvedBaseConfig24),
  crossRunSource: TCrossRunSource46,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus56),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus56),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus56),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus56),
  resultStatus: Enum(RunResultStatus56),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus12), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString84),
  waitingForManualStartAt: Optional(TDateString84),
  startedAt: Optional(TDateString84),
  cancellationRequestedAt: Optional(TDateString84),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString84),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/versioned/v94.ts
var ThisSchemaVersion57 = "v94" /* V94 */;
var TTaskOrGroupId85 = TBrandedString();
var TGraphNodeId58 = TBrandedString();
var TTemplateString58 = TBrandedString();
var TEvaluatedString58 = TBrandedString();
var TDateString85 = TBrandedString();
var TEpochSeconds58 = TBrandedNumber();
var TScopedTaskKey58 = TBrandedString();
var TaskType57 = /* @__PURE__ */ ((TaskType58) => {
  TaskType58["Command"] = "command";
  TaskType58["Leaf"] = "leaf";
  TaskType58["EmbeddedRun"] = "embedded-run";
  TaskType58["Parallel"] = "parallel";
  return TaskType58;
})(TaskType57 || {});
var TaskResultStatus57 = /* @__PURE__ */ ((TaskResultStatus58) => {
  TaskResultStatus58["Succeeded"] = "succeeded";
  TaskResultStatus58["Failed"] = "failed";
  TaskResultStatus58["NoResult"] = "no_result";
  return TaskResultStatus58;
})(TaskResultStatus57 || {});
var TaskExecutionStatus57 = /* @__PURE__ */ ((TaskExecutionStatus58) => {
  TaskExecutionStatus58["NotGenerated"] = "not_generated";
  TaskExecutionStatus58["Waiting"] = "waiting";
  TaskExecutionStatus58["Ready"] = "ready";
  TaskExecutionStatus58["Running"] = "running";
  TaskExecutionStatus58["Finished"] = "finished";
  TaskExecutionStatus58["Aborted"] = "aborted";
  TaskExecutionStatus58["Skipped"] = "skipped";
  TaskExecutionStatus58["UserError"] = "user_error";
  return TaskExecutionStatus58;
})(TaskExecutionStatus57 || {});
var TaskExecutionWaitingSubStatus57 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus58) => {
  TaskExecutionWaitingSubStatus58["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus58["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus58["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus58;
})(TaskExecutionWaitingSubStatus57 || {});
var TaskExecutionAbortedSubStatus57 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus58) => {
  TaskExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus58["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus58["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus58["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus58["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus58["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus58["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus58["SpotInterrupted"] = "spot_interrupted";
  TaskExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus58;
})(TaskExecutionAbortedSubStatus57 || {});
var TaskExecutionFinishedSubStatus57 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus58) => {
  TaskExecutionFinishedSubStatus58["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus58["Executed"] = "executed";
  TaskExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus58;
})(TaskExecutionFinishedSubStatus57 || {});
var TaskAttemptReason57 = /* @__PURE__ */ ((TaskAttemptReason58) => {
  TaskAttemptReason58["Unknown"] = "unknown";
  TaskAttemptReason58["Initial"] = "initial";
  TaskAttemptReason58["Retried"] = "retried";
  TaskAttemptReason58["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason58["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason58;
})(TaskAttemptReason57 || {});
var BackgroundProcessResultStatus84 = /* @__PURE__ */ ((BackgroundProcessResultStatus85) => {
  BackgroundProcessResultStatus85["Skipped"] = "skipped";
  BackgroundProcessResultStatus85["Finished"] = "finished";
  BackgroundProcessResultStatus85["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus85;
})(BackgroundProcessResultStatus84 || {});
var BackgroundProcessResultFinishedSubStatus84 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus85) => {
  BackgroundProcessResultFinishedSubStatus85["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus85["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus85["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus85;
})(BackgroundProcessResultFinishedSubStatus84 || {});
var RunResultStatus57 = /* @__PURE__ */ ((RunResultStatus58) => {
  RunResultStatus58["Succeeded"] = "succeeded";
  RunResultStatus58["Failed"] = "failed";
  RunResultStatus58["Debugged"] = "debugged";
  RunResultStatus58["NoResult"] = "no_result";
  return RunResultStatus58;
})(RunResultStatus57 || {});
var RunExecutionStatus57 = /* @__PURE__ */ ((RunExecutionStatus58) => {
  RunExecutionStatus58["Waiting"] = "waiting";
  RunExecutionStatus58["InProgress"] = "in_progress";
  RunExecutionStatus58["Finished"] = "finished";
  RunExecutionStatus58["Aborted"] = "aborted";
  return RunExecutionStatus58;
})(RunExecutionStatus57 || {});
var RunExecutionWaitingSubStatus57 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus58) => {
  RunExecutionWaitingSubStatus58["WaitingForManualStart"] = "waiting_for_manual_start";
  RunExecutionWaitingSubStatus58["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus58;
})(RunExecutionWaitingSubStatus57 || {});
var RunExecutionAbortedSubStatus57 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus58) => {
  RunExecutionAbortedSubStatus58["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus58["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus58["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus58["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus58;
})(RunExecutionAbortedSubStatus57 || {});
var RunExecutionFinishedSubStatus57 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus58) => {
  RunExecutionFinishedSubStatus58["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus58;
})(RunExecutionFinishedSubStatus57 || {});
var GitClonePatchStatus13 = /* @__PURE__ */ ((GitClonePatchStatus14) => {
  GitClonePatchStatus14["Pending"] = "pending";
  GitClonePatchStatus14["Succeeded"] = "succeeded";
  GitClonePatchStatus14["Failed"] = "failed";
  return GitClonePatchStatus14;
})(GitClonePatchStatus13 || {});
var TSource57 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey82 = /* @__PURE__ */ ((EnvironmentVariableCacheKey83) => {
  EnvironmentVariableCacheKey83["Included"] = "included";
  EnvironmentVariableCacheKey83["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey83;
})(EnvironmentVariableCacheKey82 || {});
var TExpandedEnvDescriptor57 = Object2({ value: Optional(TTemplateString58), cacheKey: Enum(EnvironmentVariableCacheKey82) });
var TEnvMergeStrategy57 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath84 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern84 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity84 = /* @__PURE__ */ ((Severity85) => {
  Severity85["Error"] = "error";
  Severity85["Warning"] = "warning";
  Severity85["Info"] = "info";
  return Severity85;
})(Severity84 || {});
var TProblemMatcher84 = Object2({ owner: String2(), severity: Optional(Enum(Severity84)), pattern: Array2(TProblemMatcherPattern84) });
var TProblemPath84 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath57 = Object2({ key: String2(), path: TTemplateString58 });
var TResolvedArtifactPath55 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck57 = Object2({ run: TTemplateString58, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess57 = Object2({
  key: String2(),
  command: TTemplateString58,
  readyCheck: Optional(TExpandedReadyCheck57),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType57 = /* @__PURE__ */ ((ParallelismType58) => {
  ParallelismType58["Matrix"] = "matrix";
  ParallelismType58["Total"] = "total";
  ParallelismType58["Values"] = "values";
  return ParallelismType58;
})(ParallelismType57 || {});
var TParallelismValue57 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification57 = Object2({
  cpus: Optional(TTemplateString58),
  memory: Optional(TTemplateString58),
  disk: Object2({ size: Optional(TTemplateString58) }),
  staticIps: Optional(TTemplateString58),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"])
});
var TResolvedAgentSpecification57 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2()),
  placement: TLiteralUnion(["spot", "standard"]),
  architecture: String2()
});
var TTaskDefinitionOutputs57 = Object2({
  values: Optional(Record(String2(), TTemplateString58)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor48 = Object2({ path: TTemplateString58, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor48 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet48 = Union([TTemplateString58, Array2(Union([TTemplateString58, TFilterDescriptor48]))]);
var TInputFilesystemFilter57 = Object2({
  workspace: Optional(TFilterSet48),
  artifacts: Optional(Record(TTemplateString58, TFilterSet48))
});
var TOutputFilesystemFilter57 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration50 = Object2({
  enabled: TTemplateString58,
  ttl: Optional(TTemplateString58)
});
var TTaskDefinitionWithoutParallel57 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification57),
  type: Optional(Enum(TaskType57)),
  after: Optional(TTemplateString58),
  if: Optional(TTemplateString58),
  source: Optional(TSource57),
  cacheConfiguration: TCacheConfiguration50,
  docker: Optional(TTemplateString58),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString58),
  filter: Optional(TInputFilesystemFilter57),
  backgroundProcesses: Optional(Array2(TBackgroundProcess57)),
  toolCache: Optional(TTemplateString58),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor57)),
  envMerge: Optional(Array2(TEnvMergeStrategy57)),
  timeout: Optional(TTemplateString58),
  healthTimeout: Optional(TTemplateString58),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath84)),
  artifactPaths: Optional(Array2(TArtifactPath57)),
  outputs: Optional(TTaskDefinitionOutputs57),
  problemMatchers: Optional(Array2(TProblemMatcher84)),
  problemPaths: Optional(Array2(TProblemPath84)),
  parallelismType: Optional(Enum(ParallelismType57)),
  parallelismValue: Optional(TParallelismValue57),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString58)),
  embeddedRunDefinitionTemplate: Optional(TTemplateString58),
  embeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionFromRun: Optional(Boolean2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  embeddedRunDefinitionInheritInit: Optional(Boolean2()),
  warningMessages: Array2(TUserMessage),
  deduplicateOutputFilesystem: Optional(TTemplateString58),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter57),
  bootstrapping: Optional(Boolean2()),
  automaticRetries: Optional(
    Object2({
      count: TTemplateString58,
      if: Optional(TTemplateString58),
      action: Optional(TTemplateString58)
    })
  ),
  autoCancel: TTemplateString58
});
var TCrossRunSource47 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents47 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource47,
  relativeScopedKey: String2()
});
var TTaskDefinition57 = Composite([
  TTaskDefinitionWithoutParallel57,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel57),
    parallelKey: Optional(TTemplateString58),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString58), TTemplateString58]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString58)), TTemplateString58])),
    parallelismTotal: Optional(TTemplateString58)
  })
]);
var TLayerWithManifest84 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestCliVersion: String2(),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId85,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext57 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret57 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess57 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString58,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString58,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult84 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus84),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus84),
  startedAt: Optional(TDateString85),
  completedAt: Optional(TDateString85),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem84 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity84),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResultsSummary51 = Object2({
  status: Union([
    Object2({ kind: Literal("canceled") }),
    Object2({ kind: Literal("failed") }),
    Object2({ kind: Literal("successful") }),
    Object2({ kind: Literal("timedOut") })
  ]),
  tests: Number2(),
  otherErrors: Number2(),
  retries: Number2(),
  canceled: Number2(),
  failed: Number2(),
  pended: Number2(),
  quarantined: Number2(),
  skipped: Number2(),
  successful: Number2(),
  timedOut: Number2(),
  todo: Number2(),
  flaky: Optional(Number2())
});
var TTestResults84 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  summary: Optional(TTestResultsSummary51),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TOutputBlob8 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TArtifactManifest74 = Object2({
  id: String2(),
  cliVersion: String2(),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact84 = Composite([
  TOutputBlob8,
  Object2({
    manifest: Union([TArtifactManifest74, Null()])
  })
]);
var TReferencedArtifact57 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedTaskKey: String2(),
  key: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor48)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedTaskKey: String2(),
        key: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor48))
      })
    )
  )
});
var TDefaultStatusCheck21 = Object2({
  enabled: Boolean2(),
  name: Optional(String2())
});
var TCustomStatusCheck21 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")]),
  computedDescription: Optional(String2())
});
var TRunToolCacheConfiguration57 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow57 = /* @__PURE__ */ ((OnOverflow58) => {
  OnOverflow58["CancelWaiting"] = "cancel-waiting";
  OnOverflow58["CancelRunning"] = "cancel-running";
  OnOverflow58["Queue"] = "queue";
  return OnOverflow58;
})(OnOverflow57 || {});
var TConcurrencyPool57 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow57) });
var LeaseState57 = /* @__PURE__ */ ((LeaseState58) => {
  LeaseState58["Requested"] = "requested";
  LeaseState58["Acquired"] = "acquired";
  LeaseState58["Revoked"] = "revoked";
  return LeaseState58;
})(LeaseState57 || {});
var TTiming76 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps76 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming76)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming76),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming76),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming76.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming76),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming76),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming76),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming76),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming76),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming76),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming76),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming76)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming76.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic57 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TOutputImageConfig22 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2()),
  workspace: Optional(String2())
});
var TResolvedImageConfig22 = Object2({
  user: Optional(String2()),
  shell: Optional(String2()),
  command: Optional(Union([String2(), Array2(String2()), Null()])),
  entrypoint: Optional(Union([String2(), Array2(String2()), Null()])),
  labels: Optional(Array2(Object2({ key: String2(), value: String2() }))),
  os: Optional(String2()),
  workspace: String2()
});
var TRetryAction73 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact84)
});
var TBaseLayer31 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64", "arm64"]),
  layerId: String2(),
  layerFile: String2(),
  layerSizeBytes: Number2(),
  user: Object2({
    name: String2()
  })
});
var TResolvedBaseConfig25 = Object2({
  image: Optional(String2()),
  config: Optional(String2()),
  prebuiltLayer: TBaseLayer31,
  bootstrappingKeys: Optional(Array2(String2()))
});
var TTLUnit50 = /* @__PURE__ */ ((TTLUnit51) => {
  TTLUnit51["Minutes"] = "minutes";
  TTLUnit51["Hours"] = "hours";
  TTLUnit51["Days"] = "days";
  return TTLUnit51;
})(TTLUnit50 || {});
var TTTL50 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit50)
});
var TResolvedWriteCacheConfiguration35 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Union([TTTL50, Null()])
  }),
  Object2({
    enabled: Literal(false),
    ttl: Null()
  })
]);
var TResolvedReadCacheConfiguration35 = Object2({
  enabled: Boolean2()
});
var TTip61 = Object2({
  key: String2(),
  details: TUserMessage
});
var TRetryCategory31 = TLiteralUnion(["user-initiated", "automatic", "spot-interruption", "setup-failure"]);
var TTask57 = Object2({
  schemaVersion: Literal(ThisSchemaVersion57),
  taskId: TTaskOrGroupId85,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId58),
  generatorTaskId: Optional(TTaskOrGroupId85),
  definition: TTaskDefinition57,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus57),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus57),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus57),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus57),
  resultStatus: Enum(TaskResultStatus57),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason57)),
  attemptCounts: Record(TRetryCategory31, Number2()),
  resolvedAt: Optional(TDateString85),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString85),
  debugReadyAt: Optional(TDateString85),
  debugStartedAt: Optional(TDateString85),
  debugEndedAt: Optional(TDateString85),
  cancellationRequestedAt: Optional(TDateString85),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString85),
  cancelledAt: Optional(TDateString85),
  concurrencyPool: Optional(TConcurrencyPool57),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  serializedCacheKeyComponents: Optional(String2()),
  parallelGroupCacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext57),
  usedSecrets: Optional(Array2(TUsedSecret57)),
  resolvedToolCache: Optional(String2()),
  resolvedWriteCacheConfiguration: Optional(TResolvedWriteCacheConfiguration35),
  resolvedReadCacheConfiguration: Optional(TResolvedReadCacheConfiguration35),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString58, cacheKey: Enum(EnvironmentVariableCacheKey82) }))),
  resolvedCommand: Optional(TEvaluatedString58),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess57)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact57)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest84)),
  previousLayers: Optional(Array2(TLayerWithManifest84)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest84)),
  resolvedImageConfig: Optional(TResolvedImageConfig22),
  filesystemLayers: Optional(Array2(TLayerWithManifest84)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString58)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration57),
      baseConfig: TResolvedBaseConfig25,
      crossRunSource: Optional(TCrossRunSource47)
    })
  ),
  resolvedAutomaticRetries: Optional(Number2()),
  resolvedAutomaticRetryAction: Optional(String2()),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification57),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath55)),
  resolvedDeduplicateOutputFilesystem: Optional(Boolean2()),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult84)),
  whiteoutLayer: Optional(TLayerWithManifest84),
  outputLayers: Optional(Array2(TLayerWithManifest84)),
  outputImageConfig: Optional(TOutputImageConfig22),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey82) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem84)),
  testResults: Optional(Array2(TTestResults84)),
  artifacts: Optional(Array2(TArtifact84)),
  outputBlobs: Optional(Array2(TOutputBlob8)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents47),
  tips: Array2(TTip61),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  infoMessages: Array2(TUserMessage),
  timestamps: TTimestamps76,
  networkTraffic: TNetworkTraffic57,
  outputRetryActions: Array2(TRetryAction73),
  retryAction: Optional(TRetryAction73),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest84),
  resolvedTimeoutMinutes: Optional(Number2()),
  resolvedTimeoutUserConfigured: Optional(Boolean2()),
  completedRuntimeSeconds: Number2(),
  oldestRunningTaskStartedAt: Optional(TDateString85),
  deepRunningExecutableTaskCount: Number2(),
  resolvedHealthTimeoutMinutes: Optional(Number2()),
  resolvedAutoCancel: Optional(Boolean2())
});
var TRetryManifestEntry57 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry57 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString85,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString85),
  mostRecentlyAttemptedAt: Optional(TDateString85),
  finishedAt: Optional(TDateString85),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2()),
  // must be undefined when kind != custom, must be defined when kind == custom
  category: TRetryCategory31
});
var TGraphRoots57 = Object2({ resolution: Array2(TGraphNodeId58), runtime: Array2(TGraphNodeId58) });
var TRunGraph57 = Object2({
  roots: TGraphRoots57,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId58, Array2(TGraphNodeId58)),
    runtime: Record(TGraphNodeId58, Array2(TGraphNodeId58))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId58, Array2(TGraphNodeId58)),
    runtime: Record(TGraphNodeId58, Array2(TGraphNodeId58))
  }),
  subgraphs: Record(TGraphNodeId58, Object2({ roots: TGraphRoots57 })),
  parents: Record(TGraphNodeId58, TGraphNodeId58),
  definitionOrders: Record(TGraphNodeId58, Number2())
});
var TActor57 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState57 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState57)
});
var ApprovalRequestState54 = /* @__PURE__ */ ((ApprovalRequestState55) => {
  ApprovalRequestState55["Pending"] = "pending";
  ApprovalRequestState55["Rescinded"] = "rescinded";
  ApprovalRequestState55["Approved"] = "approved";
  ApprovalRequestState55["Denied"] = "denied";
  return ApprovalRequestState55;
})(ApprovalRequestState54 || {});
var TApprovalRequest54 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState54)
});
var TRun57 = Object2({
  schemaVersion: Literal(ThisSchemaVersion57),
  persistenceExpiresAtSeconds: TEpochSeconds58,
  runId: String2(),
  createdAt: TDateString85,
  useCache: Boolean2(),
  initializationParameters: TInitializationParameters,
  actor: Optional(TActor57),
  mintDirectoryArtifact: Optional(TArtifact84),
  accessedVaultIds: Optional(Array2(String2())),
  hasTopLevelEmbeddedRun: Optional(Boolean2()),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  defaultStatusCheck: TDefaultStatusCheck21,
  customStatusChecks: Array2(TCustomStatusCheck21),
  trigger: String2(),
  concurrencyPool: Optional(TConcurrencyPool57),
  definition: Object2({
    path: String2(),
    contents: String2()
  }),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration57),
  eventNumber: Number2(),
  retries: Array2(TRetry57),
  approvalRequests: Array2(TApprovalRequest54),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph57,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry57)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey58, TConcurrencyPoolState57),
  baseConfig: Optional(TResolvedBaseConfig25),
  crossRunSource: TCrossRunSource47,
  triggerContextId: String2(),
  resetToolCache: Optional(Boolean2()),
  executionStatus: Enum(RunExecutionStatus57),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus57),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus57),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus57),
  resultStatus: Enum(RunResultStatus57),
  gitCloneContext: Optional(Object2({ patchApplied: Enum(GitClonePatchStatus13), patchTaskId: Optional(String2()) })),
  waitingForLeaseAt: Optional(TDateString85),
  waitingForManualStartAt: Optional(TDateString85),
  startedAt: Optional(TDateString85),
  cancellationRequestedAt: Optional(TDateString85),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString85),
  warningMessages: Array2(TUserMessage)
});

// packages/schema/persisted/index.ts
var TVersionedRun = Type.Union([
  TRun,
  TRun57,
  TRun56,
  TRun55,
  TRun54,
  TRun53,
  TRun52,
  TRun51,
  TRun50,
  TRun49,
  TRun48,
  TRun47,
  TRun46,
  TRun45,
  TRun44,
  TRun43,
  TRun42,
  TRun41,
  TRun40,
  TRun39,
  TRun38,
  TRun37,
  TRun36,
  TRun35,
  TRun34,
  TRun33,
  TRun32,
  TRun31,
  TRun30,
  TRun29,
  TRun28,
  TRun27,
  TRun26,
  TRun25,
  TRun24,
  TRun23,
  TRun22,
  TRun21,
  TRun20,
  TRun19,
  TRun18,
  TRun17,
  TRun16,
  TRun15,
  TRun14,
  TRun13,
  TRun12,
  TRun11,
  TRun10,
  TRun9,
  TRun8,
  TRun7,
  TRun6,
  TRun5,
  TRun4,
  TRun3,
  TRun2
]);
var TVersionedRunChecker = TypeCompiler.Compile(TVersionedRun);
var TVersionedTask = Type.Union([
  TTask,
  TTask57,
  TTask56,
  TTask55,
  TTask54,
  TTask53,
  TTask52,
  TTask51,
  TTask50,
  TTask49,
  TTask48,
  TTask47,
  TTask46,
  TTask45,
  TTask44,
  TTask43,
  TTask42,
  TTask41,
  TTask40,
  TTask39,
  TTask38,
  TTask37,
  TTask36,
  TTask35,
  TTask34,
  TTask33,
  TTask32,
  TTask31,
  TTask30,
  TTask29,
  TTask28,
  TTask27,
  TTask26,
  TTask25,
  TTask24,
  TTask23,
  TTask22,
  TTask21,
  TTask20,
  TTask19,
  TTask18,
  TTask17,
  TTask16,
  TTask15,
  TTask14,
  TTask13,
  TTask12,
  TTask11,
  TTask10,
  TTask9,
  TTask8,
  TTask7,
  TTask6,
  TTask5,
  TTask4,
  TTask3,
  TTask2
]);
var TVersionedTaskChecker = TypeCompiler.Compile(TVersionedTask);

// packages/schema/task-definition/task.ts
var TSource58 = Type.Object({
  definition: Type.String(),
  start: Type.Number(),
  end: Type.Number()
});
var TStandardDependencies = Type.Object({ type: Type.Literal("standard" /* Standard */), keys: Type.Array(Type.String()) });
var TDependencies = Type.Union([TStandardDependencies]);
var TEnvJoinMergeStrategy = Type.Object({
  strategy: Type.Literal("join"),
  by: Type.String()
});
var TEnvOverrideMergeStrategy = Type.Object({
  strategy: Type.Literal("override")
});
var TEnvMergeStrategy58 = Type.Union([TEnvJoinMergeStrategy, TEnvOverrideMergeStrategy]);
var TEnvInherit = Type.Union([Type.Literal("all-used-tasks"), Type.Array(Type.String())]);
var TEnvDescriptor = Type.Object({
  value: Type.Optional(TTemplateString2),
  cacheKey: Type.Enum(EnvironmentVariableCacheKey26)
});
var TTaskDefinitionEnv = Type.Object({
  inherit: Type.Optional(TEnvInherit),
  envVars: Type.Optional(Type.Record(Type.String(), TEnvDescriptor)),
  merge: Type.Optional(Type.Record(Type.String(), TEnvMergeStrategy58))
});
var TParallelismValue58 = Type.Record(Type.String(), Type.Union([Type.String(), Type.Number(), Type.Boolean()]));
var TAfterTask = Type.Object({ type: Type.Literal(0 /* Task */), task: Type.String() });
var TAfterTaskList = Type.Object({ type: Type.Literal(1 /* TaskList */), tasks: Type.Array(Type.String()) });
var TAfterTemplate = Type.Object({ type: Type.Literal(2 /* Template */), template: TTemplateString2 });
var TAfter = Type.Union([TAfterTask, TAfterTaskList, TAfterTemplate]);
var TCacheConfiguration51 = Type.Object({
  enabled: Type.Union([Type.Boolean(), TTemplateString2]),
  ttl: Type.Optional(TTemplateString2)
});
var TSharedTaskDefinition = Type.Object({
  key: Type.String(),
  filter: Type.Optional(TInputFilesystemFilter),
  dependencies: TDependencies,
  after: Type.Optional(TAfter),
  if: Type.Optional(TTemplateString2),
  rawSource: Type.Optional(TSource58),
  cacheConfiguration: Type.Optional(TCacheConfiguration51),
  warningMessages: Type.Array(TUserMessage)
});
var MAXIMUM_PARALLEL_TASKS_LIMIT = 256;
var TTotalParallelism = Type.Object({ type: Type.Literal("total" /* Total */), total: TTemplateString2 });
var TMatrixParallelism = Type.Object({
  type: Type.Literal("matrix" /* Matrix */),
  matrix: Type.Record(Type.String(), Type.Union([Type.Array(TTemplateString2), TTemplateString2]))
});
var TValuesParallelism = Type.Object({
  type: Type.Literal("values" /* Values */),
  values: Type.Union([TTemplateString2, Type.Array(Type.Record(Type.String(), TTemplateString2))])
});
var TParallelism = Type.Union([TTotalParallelism, TMatrixParallelism, TValuesParallelism]);
var TPartialParallelConfiguration = Type.Object({
  key: Type.Union([TTemplateString2, Type.Null()]),
  tasksLimit: Type.Optional(Type.Union([Type.Number(), Type.Null()])),
  parallelism: TParallelism,
  autoCancel: TTemplateString2
});
var TBackgroundProcessReadyCheck = Type.Object({ run: TTemplateString2, timeoutSeconds: Type.Optional(Type.Number()) });
var TBackgroundProcess58 = Type.Object({
  key: Type.String(),
  run: TTemplateString2,
  readyCheck: Type.Optional(TBackgroundProcessReadyCheck),
  terminateGracePeriodSeconds: Type.Optional(Type.Number()),
  after: Type.Optional(Type.Array(Type.String()))
});
var TAgentSpecification58 = Type.Object({
  memory: Type.Optional(TTemplateString2),
  cpus: Type.Optional(TTemplateString2),
  disk: Type.Object({
    size: Type.Optional(TTemplateString2)
  }),
  staticIps: Type.Optional(TTemplateString2),
  tmpfs: Type.Optional(Type.Boolean()),
  placement: TLiteralUnion(["spot", "standard"]),
  ipv6: Type.Optional(TTemplateString2)
});
var TCommandTaskDefinition = Type.Intersect([
  TSharedTaskDefinition,
  Type.Object({
    agent: TAgentSpecification58,
    type: Type.Literal("command" /* Command */),
    command: TTemplateString2,
    backgroundProcesses: Type.Array(TBackgroundProcess58),
    successExitCodes: Type.Array(Type.Number()),
    testResultsPaths: Type.Array(TTestResultsPath),
    artifactPaths: Type.Array(TArtifactPath),
    problemMatchers: Type.Array(TProblemMatcher),
    problemPaths: Type.Array(TProblemPath),
    env: Type.Optional(TTaskDefinitionEnv),
    timeout: Type.Optional(TTemplateString2),
    healthTimeout: TTemplateString2,
    autoCancel: TTemplateString2,
    terminateGracePeriodSeconds: Type.Optional(Type.Number()),
    toolCache: Type.Optional(TTemplateString2),
    parallel: Type.Optional(TPartialParallelConfiguration),
    docker: Type.Optional(Type.Union([Type.Boolean(), Type.Literal("preserve-data"), TTemplateString2])),
    deduplicateOutputFilesystem: TTemplateString2,
    outputFilesystemFilter: TOutputFilesystemFilter,
    bootstrapping: Type.Optional(Type.Boolean()),
    automaticRetries: Type.Optional(
      Type.Object({
        count: TTemplateString2,
        if: Type.Optional(TTemplateString2),
        action: Type.Optional(TTemplateString2)
      })
    )
  })
]);
var TLeafName = Type.Object({
  type: Type.Literal("name-version" /* NameVersion */),
  name: Type.String(),
  version: Type.String()
});
var TLeafDigest = Type.Object({
  type: Type.Literal("digest" /* Digest */),
  digest: Type.String()
});
var TLeafIdentifier = Type.Union([TLeafName, TLeafDigest]);
var TLeafTaskDefinition = Type.Intersect([
  TSharedTaskDefinition,
  Type.Object({
    type: Type.Literal("leaf" /* Leaf */),
    leaf: TLeafIdentifier,
    parameters: Type.Optional(Type.Record(Type.String(), TTemplateString2)),
    env: Type.Optional(TTaskDefinitionEnv),
    parallel: Type.Optional(TPartialParallelConfiguration),
    autoCancel: TTemplateString2
  })
]);
var TInMemoryMintDirEmbeddedRunDefinitionSource = Type.Object({
  type: Type.Literal("in-memory-mint-dir" /* InMemoryMintDir */),
  runDefinitionPath: Type.String()
});
var TTaskArtifactEmbeddedRunDefinitionSource = Type.Object({
  type: Type.Literal("task-artifact" /* TaskArtifact */),
  expression: TTemplateString2
});
var TEmbeddedRunDefinitionSource = Type.Union([TInMemoryMintDirEmbeddedRunDefinitionSource, TTaskArtifactEmbeddedRunDefinitionSource]);
var TEmbeddedRunTaskDefinition = Type.Intersect([
  Type.Omit(TSharedTaskDefinition, ["dependencies", "filter"]),
  Type.Object({
    type: Type.Literal("embedded-run" /* EmbeddedRun */),
    runDefinitionSource: TEmbeddedRunDefinitionSource,
    parameters: Type.Optional(Type.Record(Type.String(), TTemplateString2)),
    parallel: Type.Optional(TPartialParallelConfiguration),
    targets: Type.Optional(Type.Array(Type.String(), { minItems: 1 })),
    inheritInit: Type.Boolean(),
    autoCancel: TTemplateString2
  })
]);
var TPartialTaskDefinition = Type.Union([TCommandTaskDefinition, TLeafTaskDefinition, TEmbeddedRunTaskDefinition]);
var StartBehavior = /* @__PURE__ */ ((StartBehavior2) => {
  StartBehavior2["Manually"] = "manually";
  StartBehavior2["Automatically"] = "automatically";
  return StartBehavior2;
})(StartBehavior || {});
var TBaseTrigger = Type.Object({
  init: Type.Record(Type.String(), Type.String()),
  if: Type.Optional(Type.String()),
  target: Type.Optional(Type.Union([Type.String(), Type.Array(Type.String(), { minItems: 1 })])),
  title: Type.Optional(Type.String()),
  start: Type.Enum(StartBehavior),
  region: Type.Optional(Type.String())
});
var TStatusChecks = Type.Object({
  default: Type.Object({
    enabled: TTemplateString2,
    name: Type.Optional(TTemplateString2)
  }),
  custom: Type.Array(
    Type.Object({
      tasks: Type.Array(Type.String()),
      name: Type.Optional(TTemplateString2),
      status: Type.Literal("pending")
    })
  )
});
var TGithubPushTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    statusChecks: TStatusChecks
  })
]);
var TGitHubPullRequestTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    actions: Type.Optional(Type.Array(Type.String())),
    statusChecks: TStatusChecks
  })
]);
var TGitHubTriggers = Type.Object({
  push: Type.Array(TGithubPushTrigger),
  pullRequest: Type.Array(TGitHubPullRequestTrigger)
});
var TGitlabBaseTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    statusChecks: TStatusChecks
  })
]);
var TGitlabMergeRequestTrigger = Type.Intersect([
  TGitlabBaseTrigger,
  Type.Object({
    actions: Type.Optional(Type.Array(Type.String()))
  })
]);
var TGitlabTriggers = Type.Object({
  push: Type.Array(TGitlabBaseTrigger),
  tagPush: Type.Array(TGitlabBaseTrigger),
  mergeRequest: Type.Array(TGitlabMergeRequestTrigger)
});
var TCronTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    key: Type.String(),
    schedule: Type.String(),
    branch: Type.Optional(Type.String()),
    resetToolCache: Type.Optional(Type.Boolean())
  })
]);
var TCliTrigger = Type.Omit(TBaseTrigger, ["if", "target"]);
var TDispatchParam = Type.Object({
  key: Type.String(),
  name: Type.Optional(Type.String()),
  description: Type.Optional(Type.String()),
  default: Type.Optional(Type.String()),
  required: Type.Boolean()
});
var TDispatchTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    key: Type.String(),
    params: Type.Array(TDispatchParam)
  })
]);
var TCacheRebuildTrigger = Type.Intersect([TBaseTrigger, Type.Object({ ref: Type.Optional(Type.String()) })]);
var TWebhookTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    key: Type.String()
  })
]);
var TTriggers = Type.Object({
  github: TGitHubTriggers,
  gitlab: TGitlabTriggers,
  cron: Type.Array(TCronTrigger),
  cli: TCliTrigger,
  dispatch: Type.Array(TDispatchTrigger),
  cacheRebuild: Type.Array(TCacheRebuildTrigger),
  webhook: Type.Array(TWebhookTrigger)
});
var TPartialConcurrencyPool = Type.Object({
  id: TTemplateString2,
  if: Type.Optional(TTemplateString2),
  capacity: Type.Number({ minimum: 1 }),
  onOverflow: Type.Enum(OnOverflow)
});
var TPartialRunToolCache = Type.Object({
  vault: Type.String()
});
var TPartialBaseConfig = Type.Object({
  os: Type.Optional(TTemplateString2),
  image: Type.Optional(Type.String()),
  config: Type.Optional(Type.String()),
  tag: Type.Optional(TTemplateString2),
  arch: Type.Optional(TTemplateString2)
});
var _TPartialRunDefinition = Type.Object({
  concurrencyPools: Type.Optional(Type.Array(TPartialConcurrencyPool)),
  triggers: Type.Optional(TTriggers),
  toolCache: Type.Optional(TPartialRunToolCache),
  tasks: Type.Array(TPartialTaskDefinition),
  baseConfig: TPartialBaseConfig,
  warningMessages: Type.Array(TUserMessage)
});
var KEY_CHARSET = "[A-Za-z0-9_-]";
var KEY_INVALID_CHARSET = `[^A-Za-z0-9_-]`;
var KEY_PATTERN = `^${KEY_CHARSET}+$`;
var KEY_REGEXP = new RegExp(KEY_PATTERN);
var KEY_INVALID_CHARSET_REGEXP = new RegExp(KEY_INVALID_CHARSET);
var SAFE_TASK_KEY_DELIMITER = ".";
var RUN_SCOPE = getScopedKey({ scope: [], key: "" });
function getScopedKey({ key, scope }) {
  return scope.length > 0 ? `${scope.join(SAFE_TASK_KEY_DELIMITER)}${SAFE_TASK_KEY_DELIMITER}${key}` : key;
}

// packages/task-parser/yaml-dsl/parser2.ts
var YAML = __toESM(require_dist(), 1);

// packages/schema/non-empty-array.ts
var TNonEmptyArray = (schema) => Type.Array(schema, { minItems: 1 });
{
  const _BooleanArray = TNonEmptyArray(Type.Boolean());
  assertType(true);
}
function isNonEmptyArray(arr) {
  return arr.length > 0;
}

// packages/utils/set.ts
function setEqual(lhs, rhs) {
  if (lhs.size !== rhs.size) {
    return false;
  }
  for (const elem of lhs) {
    if (!rhs.has(elem)) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/lines-and-columns@2.0.4/node_modules/lines-and-columns/build/index.mjs
var LF = "\n";
var CR = "\r";
var LinesAndColumns = (
  /** @class */
  (function() {
    function LinesAndColumns2(string) {
      this.length = string.length;
      var offsets = [0];
      for (var offset = 0; offset < string.length; ) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;
          case CR:
            offset += CR.length;
            if (string[offset] === LF) {
              offset += LF.length;
            }
            offsets.push(offset);
            break;
          default:
            offset++;
            break;
        }
      }
      this.offsets = offsets;
    }
    LinesAndColumns2.prototype.locationForIndex = function(index) {
      if (index < 0 || index > this.length) {
        return null;
      }
      var line = 0;
      var offsets = this.offsets;
      while (offsets[line + 1] <= index) {
        line++;
      }
      var column = index - offsets[line];
      return { line, column };
    };
    LinesAndColumns2.prototype.indexForLocation = function(location) {
      var line = location.line, column = location.column;
      if (line < 0 || line >= this.offsets.length) {
        return null;
      }
      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }
      return this.offsets[line] + column;
    };
    LinesAndColumns2.prototype.lengthOfLine = function(line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.length : this.offsets[line + 1];
      return nextOffset - offset;
    };
    return LinesAndColumns2;
  })()
);

// packages/task-parser/matchers/schema.ts
var TNonValidatedMatcherPattern = Type.Object({
  /** the regex pattern that provides the groups to match against */
  regexp: Type.String(),
  /** a group number containing the file name */
  file: Type.Optional(Type.Integer()),
  /** a group number containing a filepath used to root the file (e.g. a project file) */
  fromPath: Type.Optional(Type.Integer()),
  /** a group number containing the line number */
  line: Type.Optional(Type.Integer()),
  /** a group number containing the column information */
  column: Type.Optional(Type.Integer()),
  /** a group number containing either the severity, case-insensitive. Defaults to `error` */
  severity: Type.Optional(Type.Integer()),
  /** a group number containing the error code */
  code: Type.Optional(Type.Integer()),
  /** a group number containing the error message. **required** at least one pattern must set the message */
  message: Type.Optional(Type.Integer()),
  /** whether to loop until a match is not found, only valid on the last pattern of a multipattern matcher */
  loop: Type.Optional(Type.Boolean())
});
var TNonValidatedProblemMatcher = Type.Object({
  owner: Type.String(),
  severity: Type.Optional(Type.String()),
  pattern: Type.Array(TNonValidatedMatcherPattern)
});
var TNonValidatedMatcherConfig = Type.Object({
  problemMatcher: Type.Array(TNonValidatedProblemMatcher)
});

// packages/schema/run-results.ts
assertType(false);

// packages/task-parser/matchers/validate.ts
var import_node_assert = __toESM(require("node:assert"), 1);
function invalid(errors) {
  return {
    valid: false,
    errors
  };
}
function valid(value) {
  return {
    valid: true,
    value
  };
}
function validateMatcherConfig(matcherConfig) {
  const { problemMatcher } = matcherConfig;
  const validatedMatchers = [];
  const errors = [];
  if (problemMatcher.length > 0) {
    for (const matcher of problemMatcher) {
      const validated = validateProblemMatcher(matcher);
      if (validated.valid) {
        validatedMatchers.push(validated.value);
      } else {
        errors.push(...validated.errors);
      }
    }
  }
  if (errors.length) {
    return invalid(errors);
  }
  return valid({
    problemMatcher: validatedMatchers
  });
}
function validateProblemMatcher(matcher) {
  const { owner, pattern: patterns, severity } = matcher;
  const errors = [];
  if (!owner) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`Found a problem matcher without an owner`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  let validatedSeverity;
  switch (severity?.toLowerCase()) {
    case void 0:
      break;
    case "error":
      validatedSeverity = "error" /* Error */;
      break;
    case "warning":
      validatedSeverity = "warning" /* Warning */;
      break;
    case "info":
      validatedSeverity = "info" /* Info */;
      break;
    default: {
      errors.push(
        buildMessage({
          type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
          message: [`The problem matcher "${owner}" contains unexpected default severity "${severity}"`],
          docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
        })
      );
      break;
    }
  }
  if (patterns.length === 0) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher "${owner}" does not contain any patterns`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  const validatedPatterns = [];
  const crossPatternsRegexpFields = {
    file: null,
    line: null,
    column: null,
    severity: null,
    code: null,
    message: null,
    fromPath: null
  };
  for (let i = 0; i < patterns.length; ++i) {
    const isFirst = i === 0;
    const isLast = i === patterns.length - 1;
    const pattern = verifyExists(patterns[i]);
    const validated = validateMatcherPattern(pattern, isFirst, isLast, crossPatternsRegexpFields);
    if (validated.valid) {
      validatedPatterns.push(validated.value);
    } else {
      errors.push(...validated.errors);
    }
  }
  if (crossPatternsRegexpFields.message === null) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher "${owner}" does not contain a pattern that sets a message`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (errors.length) {
    return invalid(errors);
  }
  (0, import_node_assert.default)(isNonEmptyArray(validatedPatterns));
  return valid({
    owner,
    pattern: validatedPatterns,
    severity: validatedSeverity
  });
}
var RE_CAPTURING_GROUPS = /\((?!\?)/g;
function validateMatcherPattern(pattern, isFirst, isLast, crossPatternsRegexpFields) {
  const errors = [];
  if (pattern.loop && (isFirst || !isLast)) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets 'loop' but is not the last pattern.`],
        advice: [`Only the last pattern in a multiline matcher may set 'loop'.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (pattern.loop && pattern.message === void 0) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets 'loop' but does not set 'message'.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  let regex;
  try {
    regex = new RegExp(pattern.regexp);
  } catch (e) {
    if (e instanceof SyntaxError) {
      errors.push(
        buildMessage({
          type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
          message: [`The problem matcher pattern '${pattern.regexp}' is not a valid regular expression.`],
          docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
        })
      );
      return invalid(errors);
    }
    throw e;
  }
  const groupCount = regex.source.match(RE_CAPTURING_GROUPS)?.length ?? 0;
  for (const key of Object.keys(crossPatternsRegexpFields)) {
    validateCrossPatternField(
      //
      crossPatternsRegexpFields,
      groupCount,
      pattern,
      key,
      errors
    );
  }
  if (errors.length) {
    return invalid(errors);
  }
  return valid(pattern);
}
function validateCrossPatternField(crossPatternsRegexpFields, groupCount, pattern, field, errors) {
  const newValue = pattern[field];
  if (newValue === void 0) {
    return;
  }
  if (crossPatternsRegexpFields[field] !== null) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets '${field}', but it is already set in another pattern.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (newValue < 0 || newValue > groupCount) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [
          `The problem matcher pattern '${pattern.regexp}' sets '${field}' to ${newValue}, but the pattern only has ${groupCount} capturing groups.`
        ],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  crossPatternsRegexpFields[field] = newValue;
}

// packages/task-parser/yaml-dsl/built-in-problem-matchers.ts
var BUILT_IN_PROBLEM_MATCHERS = {
  rubocop: {
    problemMatcher: [
      {
        owner: "rubocop",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): C: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "rubocop",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): W: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "rubocop",
        severity: "info",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): [I|R]: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  "rubocop-only-errors": {
    problemMatcher: [
      {
        owner: "rubocop",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): C: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  eslint: {
    problemMatcher: [
      {
        owner: "eslint",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.*)\\s\\s+(.*)$",
            line: 1,
            column: 2,
            severity: 3,
            message: 4,
            code: 5,
            loop: true
          }
        ]
      },
      {
        owner: "eslint",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s*(\\d+):(\\d+)\\s+(Error|Warning|Info):\\s+(.*)\\s\\s+(.*)$",
            line: 1,
            column: 2,
            severity: 3,
            message: 4,
            code: 5,
            loop: true
          }
        ]
      }
    ]
  },
  "eslint-only-errors": {
    problemMatcher: [
      {
        owner: "eslint",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+error\\s+(.*)\\s\\s+(.*)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4,
            loop: true
          }
        ]
      },
      {
        owner: "eslint",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s*(\\d+):(\\d+)\\s+Error:\\s+(.*)\\s\\s+(.*)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4,
            loop: true
          }
        ]
      }
    ]
  },
  tsc: {
    problemMatcher: [
      {
        owner: "tsc",
        pattern: [
          {
            regexp: "^([^\\s].*)[\\(:](\\d+)[,:](\\d+)(?:\\):\\s+|\\s+-\\s+)(error|warning|info)\\s+TS(\\d+)\\s*:\\s*(.*)$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            code: 5,
            message: 6
          }
        ]
      }
    ]
  },
  "erb-lint": {
    problemMatcher: [
      {
        owner: "erb-lint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): (.+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      },
      {
        owner: "erb-lint",
        severity: "error",
        pattern: [
          {
            regexp: "^$"
          },
          {
            regexp: "^(.+)$",
            message: 1
          },
          {
            regexp: "^In\\sfile:\\s(.+):(\\d+)$",
            file: 1,
            line: 2
          }
        ]
      }
    ]
  },
  shellcheck: {
    problemMatcher: [
      {
        owner: "shellcheck-tty",
        pattern: [
          {
            regexp: "^In\\s(.+)\\sline\\s(\\d+):$",
            file: 1,
            line: 2
          },
          {
            regexp: ".*"
          },
          {
            regexp: "SC(\\d+)(\\s\\((info|warning|error)\\))?:\\s(.+)$",
            code: 1,
            severity: 3,
            message: 4,
            loop: true
          }
        ]
      }
    ]
  },
  brakeman: {
    problemMatcher: [
      {
        owner: "brakeman",
        severity: "warning",
        pattern: [
          {
            regexp: "^Check:\\s(.+)$",
            code: 1
          },
          {
            regexp: "^Message:\\s(.+)$",
            message: 1
          },
          {
            regexp: ".*"
          },
          {
            regexp: "^File:\\s(.+)$",
            file: 1
          },
          {
            regexp: "^Line:\\s(.+)$",
            line: 1
          }
        ]
      }
    ]
  },
  jshint: {
    problemMatcher: [
      {
        owner: "jshint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), (.+)\\. \\((E\\d+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "jshint",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), (.+)\\. \\((W\\d+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "jshint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), (.+)\\.$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      }
    ]
  },
  htmlhint: {
    problemMatcher: [
      {
        owner: "htmlhint",
        severity: "error",
        pattern: [
          {
            regexp: "^\\s+([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+L(\\d+) \\|.+$",
            line: 1
          },
          {
            regexp: "^\\s+\\^(.+)\\. \\((.+)\\)$",
            message: 1,
            code: 2,
            loop: true
          }
        ]
      },
      {
        owner: "htmlhint",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), warning - (.+)\\. \\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "htmlhint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), error - (.+)\\. \\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      }
    ]
  },
  stylelint: {
    problemMatcher: [
      {
        owner: "stylelint",
        severity: "error",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: ".*"
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+\u2716\\s+(.+)\\s+(.+)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4,
            loop: true
          }
        ]
      },
      {
        owner: "stylelint",
        severity: "error",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+\u2716\\s+(.+)\\s+(.+)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4
          }
        ]
      },
      {
        owner: "stylelint",
        severity: "warning",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: ".*"
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+\u26A0\\s+(.+)\\s+(.+)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4,
            loop: true
          }
        ]
      },
      {
        owner: "stylelint",
        severity: "warning",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+\u26A0\\s+(.+)\\s+(.+)$",
            line: 1,
            column: 2,
            message: 3,
            code: 4
          }
        ]
      },
      {
        owner: "stylelint",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), warning - (.+) \\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "stylelint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+): line (\\d+), col (\\d+), error - (.+) \\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  sqlfluff: {
    problemMatcher: [
      {
        owner: "sqlfluff",
        severity: "error",
        pattern: [
          {
            regexp: "^== \\[(.+)\\] FAIL$",
            file: 1
          },
          {
            regexp: "^L:\\s+(\\d+) \\| P:\\s+(\\d+) \\|\\s+(.+)\\s+\\| (.+)\\.$",
            line: 1,
            column: 2,
            code: 3,
            message: 4
          }
        ]
      },
      {
        owner: "sqlfluff",
        severity: "error",
        pattern: [
          {
            regexp: "^== \\[(.+)\\] FAIL$",
            file: 1
          },
          {
            regexp: ".*"
          },
          {
            regexp: "^L:\\s+(\\d+) \\| P:\\s+(\\d+) \\|\\s+(.+)\\s+\\| (.+)\\.$",
            line: 1,
            column: 2,
            code: 3,
            message: 4,
            loop: true
          }
        ]
      }
    ]
  },
  pylint: {
    problemMatcher: [
      {
        owner: "pylint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): ([F|E]\\d+): (.+) \\(.+\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 5,
            code: 4
          }
        ]
      },
      {
        owner: "pylint",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): (W\\d+): (.+) \\(.+\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 5,
            code: 4
          }
        ]
      },
      {
        owner: "pylint",
        severity: "info",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): ([C|R|I]\\d+): (.+) \\(.+\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 5,
            code: 4
          }
        ]
      }
    ]
  },
  ruff: {
    problemMatcher: [
      {
        owner: "ruff",
        severity: "error",
        pattern: [
          {
            regexp: "^([A-Z]+\\d+) (.+)$",
            code: 1,
            message: 2
          },
          {
            regexp: "^\\s+--> (.+):(\\d+):(\\d+)$",
            file: 1,
            line: 2,
            column: 3
          }
        ]
      },
      {
        owner: "ruff",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): ([A-Z]+\\d+) (.+)$",
            file: 1,
            line: 2,
            column: 3,
            code: 4,
            message: 5
          }
        ]
      }
    ]
  },
  checkstyle: {
    problemMatcher: [
      {
        owner: "checkstyle",
        severity: "error",
        pattern: [
          {
            regexp: "^\\[(.+)\\] (.+):(\\d+):(\\d+): (.+)\\. \\[(.+)\\]$",
            severity: 1,
            file: 2,
            line: 3,
            column: 4,
            message: 5,
            code: 6
          }
        ]
      },
      {
        owner: "checkstyle",
        severity: "error",
        pattern: [
          {
            regexp: "^\\[(.+)\\] (.|[^:]+):(\\d+): (.+)\\. \\[(.+)\\]$",
            severity: 1,
            file: 2,
            line: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  roslyn: {
    problemMatcher: [
      {
        owner: "roslyn",
        severity: "error",
        pattern: [
          {
            regexp: "^\\s+(.+)\\((\\d+),(\\d+)\\): (\\w+) (.+): (.+)$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            code: 5,
            message: 6
          }
        ]
      }
    ]
  },
  nuget: {
    problemMatcher: [
      {
        owner: "nuget",
        pattern: [
          {
            regexp: "^(.+\\.csproj)\\s+:\\s+(error|warning)\\s+(NU\\d+):\\s+(.+?)\\s+\\[(.+)\\]$",
            file: 1,
            severity: 2,
            code: 3,
            message: 4
          }
        ]
      }
    ]
  },
  "clang-tidy": {
    problemMatcher: [
      {
        owner: "clang-tidy",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d): (.+): (.+) \\[(.+)\\]$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            message: 5,
            code: 6
          }
        ]
      }
    ]
  },
  cppcheck: {
    problemMatcher: [
      {
        owner: "cppcheck",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d): error: (.+) \\[(.+)\\]$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "cppcheck",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d): warning: (.+) \\[(.+)\\]$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "cppcheck",
        severity: "info",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d): (style|performance|portability|information): (.+) \\[((?!checkersReport).+)\\]$",
            file: 1,
            line: 2,
            column: 3,
            message: 5,
            code: 6
          }
        ]
      }
    ]
  },
  csharpier: {
    problemMatcher: [
      {
        owner: "csharpier",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+\\.cs)\\s+was not formatted$",
            file: 1,
            message: 1
          }
        ]
      },
      {
        owner: "csharpier",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+\\.cs)$",
            file: 1,
            message: 1
          }
        ]
      }
    ]
  },
  PSScriptAnalyzer: {
    problemMatcher: [
      {
        owner: "PSScriptAnalyzer",
        severity: "error",
        pattern: [
          {
            regexp: '^\\"(\\d+)\\",\\"(\\d+)\\",\\"(.+)\\",\\"(.+)\\",\\"(.+)\\",\\"(ParseError|Error)\\",\\"(.+)\\",\\"(.+)\\",(.*),(.*),\\"(.+)\\".*$',
            line: 1,
            column: 2,
            message: 3,
            code: 5,
            file: 8
          }
        ]
      },
      {
        owner: "PSScriptAnalyzer",
        severity: "warning",
        pattern: [
          {
            regexp: '^\\"(\\d+)\\",\\"(\\d+)\\",\\"(.+)\\",\\"(.+)\\",\\"(.+)\\",\\"Warning\\",\\"(.+)\\",\\"(.+)\\",(.*),(.*),\\"(.+)\\".*$',
            line: 1,
            column: 2,
            message: 3,
            code: 5,
            file: 7
          }
        ]
      },
      {
        owner: "PSScriptAnalyzer",
        severity: "info",
        pattern: [
          {
            regexp: '^\\"(\\d+)\\",\\"(\\d+)\\",\\"(.+)\\",\\"(.+)\\",\\"(.+)\\",\\"Information\\",\\"(.+)\\",\\"(.+)\\",(.*),(.*),\\"(.+)\\".*$',
            line: 1,
            column: 2,
            message: 3,
            code: 5,
            file: 7
          }
        ]
      }
    ]
  },
  php_codesniffer: {
    problemMatcher: [
      {
        owner: "php_codesniffer",
        pattern: [
          {
            regexp: "^FILE:\\s(.+)$",
            file: 1
          },
          { regexp: "^-+$" },
          { regexp: "^FOUND.+$" },
          { regexp: "^-+$" },
          {
            regexp: "^\\s+(\\d+)\\s+\\|\\s+(.+)\\s+\\|\\s+\\[.\\]\\s+(.+)$",
            line: 1,
            severity: 2,
            message: 3,
            loop: true
          }
        ]
      }
    ]
  },
  psalm: {
    problemMatcher: [
      {
        owner: "psalm",
        pattern: [
          {
            regexp: "^(.+):\\s(.+)\\s-\\s(.+):(\\d+):(\\d+)\\s-\\s(.+)$",
            severity: 1,
            code: 2,
            file: 3,
            line: 4,
            column: 5,
            message: 6
          }
        ]
      }
    ]
  },
  "golangci-lint": {
    problemMatcher: [
      {
        owner: "golangci-lint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+):\\s(.+)\\s\\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  clippy: {
    problemMatcher: [
      {
        owner: "clippy",
        pattern: [
          {
            regexp: "^(\\w+):\\s(.+)$",
            severity: 1,
            message: 2
          },
          {
            regexp: "^\\s-->\\s(.+):(\\d+):(\\d+)$",
            file: 1,
            line: 2,
            column: 3
          }
        ]
      }
    ]
  },
  ktlint: {
    problemMatcher: [
      {
        owner: "ktlint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+):\\s(.+)\\s\\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  detekt: {
    problemMatcher: [
      {
        owner: "detekt",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+):\\s(.+)\\s\\[(.+)\\]$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  luacheck: {
    problemMatcher: [
      {
        owner: "luacheck",
        pattern: [
          {
            regexp: "^Checking (.+)\\s+\\d+ ([^s]+)s?$",
            file: 1,
            severity: 2
          },
          {
            regexp: "^$"
          },
          {
            regexp: "^\\s+(.+):(\\d+):(\\d+):\\s(?!\\()(.+)$",
            line: 2,
            column: 3,
            message: 4,
            loop: true
          }
        ]
      },
      {
        owner: "luacheck",
        pattern: [
          {
            regexp: "^Checking (.+)\\s+\\d+ ([^s]+)s?$",
            file: 1,
            severity: 2
          },
          {
            regexp: "^$"
          },
          {
            regexp: "^\\s+(.+):(\\d+):(\\d+):\\s\\(([E|W]\\d+)\\)(.+)$",
            line: 2,
            column: 3,
            code: 4,
            message: 5,
            loop: true
          }
        ]
      }
    ]
  },
  dart: {
    problemMatcher: [
      {
        owner: "dart",
        pattern: [
          {
            regexp: "^\\s*(.+)\\s\u2022\\s(.+):(\\d+):(\\d+)\\s\u2022\\s(.+)\\s\u2022\\s(.+)$",
            severity: 1,
            file: 2,
            line: 3,
            column: 4,
            message: 5,
            code: 6
          }
        ]
      }
    ]
  },
  credo: {
    problemMatcher: [
      {
        owner: "credo",
        severity: "info",
        pattern: [
          {
            regexp: "^.+\\[[A-Z]\\]\\s\u2192\\s(.+)$",
            message: 1
          },
          {
            regexp: "^[^\\w]+(.+):(\\d+):(\\d+).+$",
            file: 1,
            line: 2,
            column: 3
          }
        ]
      },
      {
        owner: "credo",
        severity: "info",
        pattern: [
          {
            regexp: "^\\[\\w\\]\\s\u2192\\s(.+):(\\d+):(\\d+)\\s(.+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      },
      {
        owner: "credo",
        severity: "warning",
        pattern: [
          {
            regexp: "^.+\\[[A-Z]\\]\\s\u2197\\s(.+)$",
            message: 1
          },
          {
            regexp: "^[^\\w]+(.+):(\\d+):(\\d+).+$",
            file: 1,
            line: 2,
            column: 3
          }
        ]
      },
      {
        owner: "credo",
        severity: "warning",
        pattern: [
          {
            regexp: "^\\[\\w\\]\\s\u2197\\s(.+):(\\d+):(\\d+)\\s(.+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      },
      {
        owner: "credo",
        severity: "error",
        pattern: [
          {
            regexp: "^.+\\[[A-Z]\\]\\s\u2191\\s(.+)$",
            message: 1
          },
          {
            regexp: "^[^\\w]+(.+):(\\d+):(\\d+).+$",
            file: 1,
            line: 2,
            column: 3
          }
        ]
      },
      {
        owner: "credo",
        severity: "error",
        pattern: [
          {
            regexp: "^\\[\\w\\]\\s\u2191\\s(.+):(\\d+):(\\d+)\\s(.+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      }
    ]
  },
  swiftlint: {
    problemMatcher: [
      {
        owner: "swiftlint",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+):\\s(\\w+):\\s(.+)\\s\\((.+)\\)$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            message: 5,
            code: 6
          }
        ]
      }
    ]
  },
  tailor: {
    problemMatcher: [
      {
        owner: "tailor",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+):\\s+(\\w+):\\s\\[(.+)\\]\\s(.+)$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            code: 5,
            message: 6
          }
        ]
      }
    ]
  }
};
function isBuiltinProblemMatcher(key) {
  return key in BUILT_IN_PROBLEM_MATCHERS;
}

// packages/utils/debug-assert.ts
var import_node_assert2 = __toESM(require("node:assert"), 1);
function debugAssert(value, message) {
  if (process.env.NODE_ENV === "production") {
    return;
  }
  (0, import_node_assert2.default)(value(), message);
}

// node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib_esm/api_esm.mjs
var import_api = __toESM(require_api4(), 1);
var Alternation = import_api.default.Alternation;
var Alternative = import_api.default.Alternative;
var CstParser = import_api.default.CstParser;
var EMPTY_ALT = import_api.default.EMPTY_ALT;
var EOF = import_api.default.EOF;
var EarlyExitException = import_api.default.EarlyExitException;
var EmbeddedActionsParser = import_api.default.EmbeddedActionsParser;
var GAstVisitor = import_api.default.GAstVisitor;
var LLkLookaheadStrategy = import_api.default.LLkLookaheadStrategy;
var Lexer = import_api.default.Lexer;
var LexerDefinitionErrorType = import_api.default.LexerDefinitionErrorType;
var MismatchedTokenException = import_api.default.MismatchedTokenException;
var NoViableAltException = import_api.default.NoViableAltException;
var NonTerminal = import_api.default.NonTerminal;
var NotAllInputParsedException = import_api.default.NotAllInputParsedException;
var Option = import_api.default.Option;
var Parser = import_api.default.Parser;
var ParserDefinitionErrorType = import_api.default.ParserDefinitionErrorType;
var Repetition = import_api.default.Repetition;
var RepetitionMandatory = import_api.default.RepetitionMandatory;
var RepetitionMandatoryWithSeparator = import_api.default.RepetitionMandatoryWithSeparator;
var RepetitionWithSeparator = import_api.default.RepetitionWithSeparator;
var Rule = import_api.default.Rule;
var Terminal = import_api.default.Terminal;
var VERSION = import_api.default.VERSION;
var clearCache = import_api.default.clearCache;
var createSyntaxDiagramsCode = import_api.default.createSyntaxDiagramsCode;
var createToken = import_api.default.createToken;
var createTokenInstance = import_api.default.createTokenInstance;
var defaultLexerErrorProvider = import_api.default.defaultLexerErrorProvider;
var defaultParserErrorProvider = import_api.default.defaultParserErrorProvider;
var generateCstDts = import_api.default.generateCstDts;
var getLookaheadPaths = import_api.default.getLookaheadPaths;
var isRecognitionException = import_api.default.isRecognitionException;
var serializeGrammar = import_api.default.serializeGrammar;
var serializeProduction = import_api.default.serializeProduction;
var tokenLabel = import_api.default.tokenLabel;
var tokenMatcher = import_api.default.tokenMatcher;
var tokenName = import_api.default.tokenName;

// packages/task-parser/tokens.ts
var EXPR_START = "${{";
var EXPR_START_RE = /(\\{2})*\${{/;
var EXPR_END = "}}";
var EXPR_END_RE = /}}/;

// packages/task-parser/template-parser.ts
var AnyBeforeExpr = createToken({
  name: "AnyBeforeExpr",
  pattern: /(.|\n|\r)+?(?=\\*\${{)/
});
var AnyBeforeExprEnd = createToken({
  name: "AnyBeforeExprEnd",
  pattern: /(.|\n|\r)+?(?=}})/
});
var Any2 = createToken({
  name: "Any",
  pattern: /(.|\n|\r)+/
});
var WhiteSpace = createToken({
  name: "WhiteSpace",
  pattern: /\s+/,
  group: Lexer.SKIPPED
});
var EscapedExprStart = createToken({
  name: "EscapedExprStart",
  pattern: /(\\{2})*\\\${{/,
  label: `'\\+\${{'`,
  push_mode: "escapedExpression"
});
var ExprStart = createToken({
  name: "ExprStart",
  pattern: EXPR_START_RE,
  label: `'${EXPR_START}'`,
  push_mode: "expression"
});
var ExprEnd = createToken({
  name: "ExprEnd",
  pattern: EXPR_END_RE,
  label: `'${EXPR_END}'`,
  pop_mode: true
});
var IdentRegex = /[a-zA-Z_-][\w-]*/;
var Ident = createToken({
  name: "Ident",
  pattern: IdentRegex,
  label: `Identifier matching pattern '${IdentRegex.source}'`
});
var Dot = createToken({
  name: "Dot",
  pattern: /\./,
  label: `'.'`
});
var Comma = createToken({
  name: "Comma",
  pattern: /,/,
  label: `','`
});
var OpOr = createToken({
  name: "OrOp",
  pattern: /\|\|/,
  label: "||"
});
var OpAnd = createToken({
  name: "AndOp",
  pattern: /&&/,
  label: "&&"
});
var OpEq = createToken({
  name: "EqOp",
  pattern: /==/,
  label: "=="
});
var OpNotEq = createToken({
  name: "NotEqOp",
  pattern: /!=/,
  label: "!="
});
var OpMatch = createToken({
  name: "MatchOp",
  pattern: /=~/,
  label: "=~"
});
var OpNotMatch = createToken({
  name: "NotMatchOp",
  pattern: /!~/,
  label: "!~"
});
var OpGtEq = createToken({
  name: "GtEqOp",
  pattern: />=/,
  label: ">="
});
var OpLtEq = createToken({
  name: "LtEqOp",
  pattern: /<=/,
  label: "<="
});
var OpGt = createToken({
  name: "GtOp",
  pattern: />/,
  label: ">"
});
var OpLt = createToken({
  name: "LtOp",
  pattern: /</,
  label: "<"
});
var OpNegate = createToken({
  name: "NegateOp",
  pattern: /!/,
  label: "!"
});
var RE_SINGLE_QUOTE_STRING_LITERAL = /'[^']*'/y;
var RE_DOUBLE_QUOTE_STRING_LITERAL = /"[^"]*"/y;
var matchStringLiteralRe = (re) => (text, startOffset) => {
  re.lastIndex = startOffset;
  const execResult = re.exec(text);
  if (execResult !== null) {
    const fullMatch = execResult[0];
    const matchWithOutQuotes = fullMatch.substr(1, fullMatch.length - 2);
    execResult.payload = matchWithOutQuotes;
  }
  return execResult;
};
var SingleQuoteStringLiteral = createToken({
  name: "SingleQuoteStringLiteral",
  pattern: matchStringLiteralRe(RE_SINGLE_QUOTE_STRING_LITERAL),
  line_breaks: false,
  label: "single-quote string literal"
});
var DoubleQuoteStringLiteral = createToken({
  name: "DoubleQuoteStringLiteral",
  pattern: matchStringLiteralRe(RE_DOUBLE_QUOTE_STRING_LITERAL),
  line_breaks: false,
  label: "double-quote string literal"
});
var BooleanLiteral = createToken({
  name: "BooleanLiteral",
  pattern: /true|false/,
  label: `Boolean 'true' or 'false'`
});
var NumberLiteral = createToken({
  name: "NumberLiteral",
  pattern: /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/,
  label: "number"
});
var LParen = createToken({ name: "LParen", pattern: /\(/, label: "(" });
var RParen = createToken({ name: "RParen", pattern: /\)/, label: ")" });
var LBracket = createToken({ name: "LBracket", pattern: /\[/, label: "[" });
var RBracket = createToken({ name: "RBracket", pattern: /\]/, label: "]" });
var modes = {
  templateString: [
    // The ordering here is important since the lexer is backtracking.
    ExprStart,
    EscapedExprStart,
    AnyBeforeExpr,
    Any2
  ],
  expression: [
    WhiteSpace,
    BooleanLiteral,
    NumberLiteral,
    Ident,
    Dot,
    Comma,
    ExprEnd,
    OpAnd,
    OpOr,
    OpEq,
    OpNotEq,
    OpMatch,
    OpNotMatch,
    OpGtEq,
    OpLtEq,
    OpGt,
    OpLt,
    OpNegate,
    SingleQuoteStringLiteral,
    DoubleQuoteStringLiteral,
    LParen,
    RParen,
    LBracket,
    RBracket
  ],
  escapedExpression: [ExprEnd, AnyBeforeExprEnd]
};
var multiModeLexer = {
  modes,
  defaultMode: "templateString" /* TemplateString */
};
var TemplateLexer = new Lexer(multiModeLexer, { positionTracking: "onlyStart", recoveryEnabled: false });
var TemplateParser = class extends CstParser {
  parse = this.RULE("parse", () => {
    this.MANY(() => {
      this.SUBRULE(this.embeddedExpr);
    });
    this.OPTION(() => {
      this.CONSUME(Any2, { LABEL: "litAfter" });
    });
  });
  embeddedExpr = this.RULE("embeddedExpr", () => {
    this.OPTION(() => {
      this.CONSUME(AnyBeforeExpr, { LABEL: "litBefore" });
    });
    this.OR([
      {
        ALT: () => {
          this.CONSUME(EscapedExprStart, { LABEL: "escapedExprStart" });
          this.CONSUME(AnyBeforeExprEnd, { LABEL: "escapedExpr" });
        }
      },
      {
        ALT: () => {
          this.CONSUME(ExprStart, { LABEL: "exprStart" });
          this.SUBRULE(this.expr);
        }
      }
    ]);
    this.CONSUME(ExprEnd);
  });
  expr = this.RULE("expr", () => {
    this.SUBRULE(this.orExpr);
  });
  /** <expr> (|| <expr>)* */
  orExpr = this.RULE("orExpr", () => {
    this.SUBRULE(this.andExpr);
    this.MANY(() => {
      this.CONSUME(OpOr);
      this.SUBRULE2(this.andExpr);
    });
  });
  /** <expr> (&& <expr>)* */
  andExpr = this.RULE("andExpr", () => {
    this.SUBRULE(this.compareExpr);
    this.MANY(() => {
      this.CONSUME(OpAnd);
      this.SUBRULE2(this.compareExpr);
    });
  });
  /** <expr> ((==|!=|=~|!~) <expr>)? */
  compareExpr = this.RULE("compareExpr", () => {
    this.SUBRULE(this.atomicExpr);
    this.OPTION(() => {
      this.OR([
        { ALT: () => this.CONSUME(OpEq) },
        { ALT: () => this.CONSUME(OpNotEq) },
        { ALT: () => this.CONSUME(OpMatch) },
        { ALT: () => this.CONSUME(OpNotMatch) },
        { ALT: () => this.CONSUME(OpGt) },
        { ALT: () => this.CONSUME(OpLt) },
        { ALT: () => this.CONSUME(OpGtEq) },
        { ALT: () => this.CONSUME(OpLtEq) }
      ]);
      this.SUBRULE2(this.atomicExpr);
    });
  });
  atomicExpr = this.RULE("atomicExpr", () => {
    this.OPTION(() => this.CONSUME(OpNegate, { LABEL: "negate" }));
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.paranthesizedExpr, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.stringLiteral, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.booleanLiteral, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.numberLiteral, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.access, { LABEL: "expr" }) }
    ]);
  });
  paranthesizedExpr = this.RULE("paranthesizedExpr", () => {
    this.CONSUME(LParen);
    this.SUBRULE(this.expr);
    this.CONSUME(RParen);
  });
  stringLiteral = this.RULE("stringLiteral", () => {
    this.OR([
      //
      { ALT: () => this.CONSUME(SingleQuoteStringLiteral, { LABEL: "str" }) },
      { ALT: () => this.CONSUME(DoubleQuoteStringLiteral, { LABEL: "str" }) }
    ]);
  });
  booleanLiteral = this.RULE("booleanLiteral", () => {
    this.CONSUME(BooleanLiteral, { LABEL: "bool" });
  });
  numberLiteral = this.RULE("numberLiteral", () => {
    this.CONSUME(NumberLiteral, { LABEL: "num" });
  });
  access = this.RULE("access", () => {
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.functionCall, { LABEL: "functionCall" }) },
      { ALT: () => this.CONSUME(Ident, { LABEL: "ident" }) }
    ]);
    this.MANY(() => {
      this.SUBRULE(this.chainedAccess);
    });
  });
  chainedAccess = this.RULE("chainedAccess", () => {
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.dynamicAccess) },
      { ALT: () => this.SUBRULE(this.functionAccess) },
      { ALT: () => this.SUBRULE(this.staticAccess) }
    ]);
  });
  dynamicAccess = this.RULE("dynamicAccess", () => {
    this.CONSUME(LBracket);
    this.SUBRULE(this.expr);
    this.CONSUME(RBracket);
  });
  functionAccess = this.RULE("functionAccess", () => {
    this.CONSUME(Dot);
    this.SUBRULE(this.functionCall);
  });
  staticAccess = this.RULE("staticAccess", () => {
    this.CONSUME(Dot);
    this.OR([
      //
      { ALT: () => this.CONSUME(Ident, { LABEL: "ident" }) },
      { ALT: () => this.CONSUME(BooleanLiteral, { LABEL: "ident" }) }
    ]);
  });
  functionCall = this.RULE("functionCall", () => {
    this.CONSUME(Ident, { LABEL: "functionName" });
    this.CONSUME(LParen);
    this.OPTION(() => {
      this.SUBRULE(this.expr, { LABEL: "firstArg" });
      this.MANY(() => {
        this.SUBRULE(this.commaArg);
      });
    });
    this.CONSUME(RParen);
  });
  commaArg = this.RULE("commaArg", () => {
    this.CONSUME(Comma);
    this.SUBRULE(this.expr, { LABEL: "arg" });
  });
  constructor() {
    super(multiModeLexer, {
      recoveryEnabled: false
    });
    this.performSelfAnalysis();
  }
};
var templateParser = new TemplateParser();
function getTemplateParser(input) {
  templateParser.input = input;
  return templateParser;
}

// packages/task-parser/template.ts
var import_node_assert4 = __toESM(require("node:assert"), 1);

// packages/task-parser/errors.ts
var import_node_assert3 = __toESM(require("node:assert"), 1);
var ParsingError = class _ParsingError extends UserError {
  messages;
  constructor(messages) {
    (0, import_node_assert3.default)(messages.length);
    const { fileName: _fileName, line: _line, column: _column, stackTrace: _stackTrace, ...rest } = verifyExists(messages[0]);
    const combinedMessage = messages.map((um) => messageWithFileLocation(um)).join("\n\n");
    super({ ...rest, message: combinedMessage });
    this.messages = messages;
    Object.setPrototypeOf(this, _ParsingError.prototype);
  }
  static fromString(message) {
    return new this([{ type: "parse-error" /* ParseError */, message }]);
  }
  asMessages() {
    return this.messages;
  }
};

// packages/task-parser/template.ts
function parseTemplate(template) {
  const lexer = TemplateLexer.tokenize(template);
  const parser = getTemplateParser(lexer.tokens);
  const ast = parser.parse();
  if (parser.errors.length > 0) {
    throw ParsingError.fromString(`Failed to parse template "${template}"
${parser.errors.map((e) => e.message).join("\n")}`);
  }
  return normalizeAst(ast);
}
function normalizeAst({ children }) {
  const literalParts = [];
  const expressions = [];
  const { embeddedExpr, litAfter } = { embeddedExpr: [], ...children };
  for (const {
    children: { escapedExpr, escapedExprStart, expr, exprStart, litBefore }
  } of embeddedExpr) {
    const literalBefore = litBefore ? extractStringImage(litBefore) : "";
    literalParts.push(literalBefore);
    if (escapedExpr) {
      (0, import_node_assert4.default)(escapedExprStart, "escapedExprStart must be present to have an escaped expr");
      (0, import_node_assert4.default)(escapedExpr.length === 1, "escapedExpr must have exactly one node");
      const escapeCharacters = extractStringImage(escapedExprStart).replaceAll("\\${{", "").replaceAll("\\\\", "\\");
      if (escapeCharacters !== "") {
        literalParts.push(escapeCharacters);
      }
      literalParts.push(EXPR_START);
      literalParts.push(extractStringImage(escapedExpr));
      literalParts.push(EXPR_END);
    } else if (expr) {
      (0, import_node_assert4.default)(exprStart, "exprStart must be present to have an expr");
      (0, import_node_assert4.default)(expr.length === 1, "expr must have exactly one node");
      const escapeCharacters = extractStringImage(exprStart).replaceAll("${{", "").replaceAll("\\\\", "\\");
      if (escapeCharacters !== "") {
        literalParts.push(escapeCharacters);
      }
      expressions.push({ insertAfter: literalParts.length - 1, expression: normalizeExpression(verifyExists(expr[0])) });
    } else {
      throw new Error("must have either an expr or escaped expr");
    }
  }
  literalParts.push(litAfter ? extractStringImage(litAfter) : "");
  const template = { literalParts, expressions };
  return template;
}
function normalizeExpression(expr) {
  const {
    children: { orExpr }
  } = expr;
  (0, import_node_assert4.default)(orExpr.length === 1, "orExpr must have exactly one node");
  return normalizeOrExpr(verifyExists(orExpr[0]));
}
function normalizeOrExpr(orExpr) {
  const {
    children: { andExpr: andExprs }
  } = verifyExists(orExpr);
  (0, import_node_assert4.default)(andExprs.length > 0, "orExprs must have at least one node");
  const normalized = andExprs.map((andExpr) => normalizeAndExpr(andExpr));
  const last = verifyExists(normalized[normalized.length - 1]);
  const rest = normalized.slice(0, normalized.length - 1);
  return rest.reverse().reduce((acc, curr) => {
    return { type: "Or" /* Or */, left: curr, right: acc };
  }, verifyExists(last));
}
function normalizeAndExpr(andExpr) {
  const {
    children: { compareExpr: compareExprs }
  } = verifyExists(andExpr);
  (0, import_node_assert4.default)(compareExprs.length > 0, "orExprs must have at least one node");
  const normalized = compareExprs.map((compareExpr) => normalizeCompareOrSingleExpr(compareExpr));
  const last = verifyExists(normalized[normalized.length - 1]);
  const rest = normalized.slice(0, normalized.length - 1);
  return rest.reverse().reduce((acc, curr) => {
    return { type: "And" /* And */, left: curr, right: acc };
  }, verifyExists(last));
}
function normalizeCompareOrSingleExpr(compareExpr) {
  const {
    children: {
      atomicExpr: atomicExprs,
      EqOp: eqOp,
      NotEqOp: notEqOp,
      MatchOp: matchOp,
      NotMatchOp: notMatchOp,
      GtOp: gtOp,
      LtOp: ltOp,
      GtEqOp: gtEqOp,
      LtEqOp: ltEqOp
    }
  } = compareExpr;
  (0, import_node_assert4.default)(atomicExprs.length > 0, "atomicExprs must have at least one node");
  (0, import_node_assert4.default)(atomicExprs.length <= 2, "atomicExprs must have at most two nodes");
  const [left, maybeRight] = atomicExprs.map((atomicExpr) => normalizeAtomicExpr(atomicExpr));
  (0, import_node_assert4.default)(left, "left must be defined");
  if (!maybeRight) {
    return left;
  }
  (0, import_node_assert4.default)(eqOp || notEqOp || matchOp || notMatchOp || gtOp || ltOp || gtEqOp || ltEqOp, "Must have a comparison operator if there is a right atomic expr");
  if (eqOp) {
    return { type: "Eq" /* Eq */, left, right: maybeRight };
  }
  if (notEqOp) {
    return { type: "NotEq" /* NotEq */, left, right: maybeRight };
  }
  if (matchOp) {
    return { type: "Match" /* Match */, left, right: maybeRight };
  }
  if (notMatchOp) {
    return { type: "NotMatch" /* NotMatch */, left, right: maybeRight };
  }
  if (gtOp) {
    return { type: "Gt" /* Gt */, left, right: maybeRight };
  }
  if (ltOp) {
    return { type: "Lt" /* Lt */, left, right: maybeRight };
  }
  if (gtEqOp) {
    return { type: "GtEq" /* GtEq */, left, right: maybeRight };
  }
  if (ltEqOp) {
    return { type: "LtEq" /* LtEq */, left, right: maybeRight };
  }
  throw new Error("Unhandled operation");
}
function normalizeAtomicExpr(atomicExpr) {
  const {
    children: { negate, expr }
  } = atomicExpr;
  (0, import_node_assert4.default)(expr && expr.length === 1, "expr must have exactly one node");
  const innerExpr = verifyExists(expr[0]);
  let expression;
  switch (innerExpr.name) {
    case "paranthesizedExpr":
      expression = normalizeParanthesizedExpr(innerExpr);
      break;
    case "access":
      expression = normalizeAccess(innerExpr);
      break;
    case "stringLiteral":
      expression = normalizeString(innerExpr);
      break;
    case "booleanLiteral":
      expression = normalizeBoolean(innerExpr);
      break;
    case "numberLiteral":
      expression = normalizeNumber(innerExpr);
      break;
  }
  if (negate) {
    return { type: "Negate" /* Negate */, expr: expression };
  } else {
    return expression;
  }
}
function normalizeParanthesizedExpr(paranthesizedExpr) {
  const {
    children: { expr }
  } = paranthesizedExpr;
  (0, import_node_assert4.default)(expr.length === 1, "expr must have exactly one node");
  return normalizeExpression(verifyExists(expr[0]));
}
function normalizeAccess(access) {
  const {
    children: { functionCall: headFunctionCall, ident: headIdent, chainedAccess }
  } = access;
  let head;
  if (headFunctionCall) {
    (0, import_node_assert4.default)(headFunctionCall.length === 1, "functionCall must have exactly one node");
    head = normalizeFunctionCall(verifyExists(headFunctionCall[0]));
  } else if (headIdent) {
    (0, import_node_assert4.default)(headIdent.length === 1, "ident must have exactly one node");
    head = { type: "StaticAccess" /* StaticAccess */, name: verifyExists(headIdent[0]).image };
  } else {
    throw new Error("access must be either an identifier or a function call");
  }
  const accesses = (chainedAccess ?? []).map(({ children: { staticAccess, dynamicAccess, functionAccess } }) => {
    return normalizeChainedAccess({ staticAccess, dynamicAccess, functionAccess });
  });
  return {
    type: "Access" /* Access */,
    path: [head, ...accesses]
  };
}
function normalizeChainedAccess({
  staticAccess: maybeStaticAccess,
  dynamicAccess: maybeDynamicAccess,
  functionAccess: maybeFunctionAccess
}) {
  if (maybeStaticAccess) {
    (0, import_node_assert4.default)(maybeStaticAccess.length === 1, "chained access must have only one static access");
    const {
      children: { ident: maybeIdent }
    } = verifyExists(maybeStaticAccess[0]);
    (0, import_node_assert4.default)(maybeIdent && maybeIdent.length === 1, "static access must have exactly one ident");
    return { type: "StaticAccess" /* StaticAccess */, name: verifyExists(maybeIdent[0]).image };
  } else if (maybeDynamicAccess) {
    (0, import_node_assert4.default)(maybeDynamicAccess.length === 1, "chained access must have only one dynamic access");
    const {
      children: { expr: maybeExpr }
    } = verifyExists(maybeDynamicAccess[0]);
    (0, import_node_assert4.default)(maybeExpr.length === 1, "dynamic access must have exactly one expr");
    return { type: "DynamicAccess" /* DynamicAccess */, arg: normalizeExpression(verifyExists(maybeExpr[0])) };
  } else if (maybeFunctionAccess) {
    (0, import_node_assert4.default)(maybeFunctionAccess.length === 1, "chained access must have only one function access");
    const {
      children: { functionCall: maybeFunctionCall }
    } = verifyExists(maybeFunctionAccess[0]);
    (0, import_node_assert4.default)(maybeFunctionCall.length === 1, "function access must have exactly one function call");
    return normalizeFunctionCall(verifyExists(maybeFunctionCall[0]));
  } else {
    throw new Error("access must be either an identifier or a function call");
  }
}
function normalizeFunctionCall(functionCall) {
  (0, import_node_assert4.default)(functionCall.children.functionName.length === 1, "function calls must have exactly one ");
  const functionName = verifyExists(functionCall.children.functionName[0]);
  const args = normalizeFunctionArgs(functionCall.children.firstArg, functionCall.children.commaArg);
  return { type: "FunctionCall" /* FunctionCall */, name: functionName.image, args };
}
function normalizeFunctionArgs(maybeFirstArg, maybeCommaArg) {
  if (!maybeFirstArg) return [];
  (0, import_node_assert4.default)(maybeFirstArg.length === 1, "Function calls can only have 1 first arg");
  const firstArg = verifyExists(maybeFirstArg[0]);
  const additionalArgs = (maybeCommaArg ?? []).map(({ children: { arg } }) => {
    (0, import_node_assert4.default)(arg.length === 1, "Comma arg can only have one argument");
    return normalizeExpression(verifyExists(arg[0]));
  });
  return [normalizeExpression(firstArg), ...additionalArgs];
}
function normalizeString(stringLiteral) {
  const {
    children: { str }
  } = stringLiteral;
  (0, import_node_assert4.default)(str?.length === 1, "str must have exactly one node");
  return { type: "String" /* String */, value: extractInnerString(str) };
}
function extractStringImage(token) {
  debugAssert(() => token.length === 1);
  return verifyExists(token[0]).image;
}
function extractInnerString(token) {
  const tok = token[0];
  (0, import_node_assert4.default)(tok && typeof tok.payload === "string", "token must be a string");
  return tok.payload;
}
function normalizeBoolean(booleanLiteral) {
  const {
    children: { bool }
  } = booleanLiteral;
  (0, import_node_assert4.default)(bool.length === 1, "bool must have exactly one node");
  return { type: "Boolean" /* Boolean */, value: extractInnerBoolean(bool) };
}
function normalizeNumber(numberLiteral) {
  const {
    children: { num }
  } = numberLiteral;
  (0, import_node_assert4.default)(num.length === 1, "num must have exactly one node");
  return { type: "Number" /* Number */, value: extractStringImage(num) };
}
function extractInnerBoolean(token) {
  const tok = token[0];
  (0, import_node_assert4.default)(tok && (tok.image === "true" || tok.image === "false"), "token must be a boolean");
  return tok.image === "true";
}
var TEMPLATE_FALSE = "${{ false }}";

// packages/task-parser/yaml-dsl/parser2.ts
var import_node_assert6 = __toESM(require("node:assert"), 1);

// packages/task-parser/yaml-dsl/common.ts
var import_path = require("path");
var TStringable = Type.Union([Type.String(), Type.Number(), Type.Boolean()], {
  errorMessage: `Expected a string, number, or boolean.`
});
function formatTypeErrors(schema, value, syntaxDescription) {
  const errors = Array.from(value_exports2.Errors(schema, value));
  return formatTypeErrorsHelp(errors, syntaxDescription);
}
function formatError(err) {
  switch (err.type) {
    case ValueErrorType.ObjectAdditionalProperties:
      return indent(`Unexpected property "${(0, import_path.basename)(err.path)}"`);
    case ValueErrorType.ObjectRequiredProperty:
      return indent(`The property "${(0, import_path.basename)(err.path)}" is required`);
    default:
      if (!err.path.length) {
        return indent(err.message);
      }
      return indent(`At "${err.path}":
` + indent(err.message));
  }
}
function formatTypeErrorsHelp(errors, context) {
  const formattedErrors = errors.map(formatError);
  return `Syntax error ${context}:
${formattedErrors.join("\n")}`;
}

// packages/logger/index.ts
var import_winston = __toESM(require_winston(), 1);

// packages/logger/test.ts
var import_winston_transport = __toESM(require_winston_transport(), 1);

// packages/utils/singleton.ts
var Singleton = class {
  constructor(instanceName, initially = void 0) {
    this.instanceName = instanceName;
    this.#instance = initially;
  }
  #instance = void 0;
  set(instance) {
    this.#instance = instance;
  }
  get() {
    if (!this.#instance) throw new Error(`${this.instanceName} is not set.`);
    return this.#instance;
  }
  tryGet() {
    return this.#instance;
  }
  reset() {
    this.#instance = void 0;
  }
};

// packages/logger/tags.ts
var Tags = new Singleton("log tags", {});

// packages/logger/test.ts
var logs = [];
var TestTransport = class extends import_winston_transport.default {
  constructor(opts = {}) {
    super(opts);
  }
  log(info, callback) {
    const taggedInfo = { ...info, ...Tags.get() };
    setImmediate(() => {
      this.emit("logged", taggedInfo);
    });
    logs.push(taggedInfo);
    if (callback) {
      callback();
    }
  }
  logv(info, next) {
    this.log(info, next);
  }
  cleanup() {
    logs.splice(0);
  }
};

// packages/logger/index.ts
var MintLoggerTransport = /* @__PURE__ */ ((MintLoggerTransport2) => {
  MintLoggerTransport2["ConsoleJson"] = "console-json";
  MintLoggerTransport2["ConsoleText"] = "console-text";
  MintLoggerTransport2["Test"] = "test";
  return MintLoggerTransport2;
})(MintLoggerTransport || {});
var logger;
function createLogger(context = {}) {
  if (!logger) {
    logger = makeLogger();
  }
  return logger.child(context);
}
function makeLogger() {
  const logLevel = process.env.MINT_LOGGER_LEVEL ?? "info";
  const enabledTransports = determineTransports();
  const transports = enabledTransports.map((t) => makeTransport(t, logLevel));
  return (0, import_winston.createLogger)({
    format: import_winston.format.timestamp(),
    transports
  });
}
function determineTransports() {
  const specifiedStrings = (process.env.MINT_LOGGER_TRANSPORTS ?? "").split(new RegExp("\\s*,\\s*"));
  const specifiedTransports = [];
  for (const string of specifiedStrings) {
    if (Object.values(MintLoggerTransport).includes(string)) {
      specifiedTransports.push(string);
    }
  }
  let enabledTransports = [];
  if (specifiedTransports.length > 0) {
    enabledTransports = specifiedTransports;
  } else if (process.env.NODE_ENV === "production") {
    enabledTransports.push("console-json" /* ConsoleJson */);
  } else if (process.env.NODE_ENV === "test") {
    enabledTransports.push("test" /* Test */);
  } else {
    enabledTransports.push("console-text" /* ConsoleText */);
  }
  return enabledTransports;
}
function jsonFriendlyErrorReplacer(_, value) {
  if (value instanceof Error) {
    return Object.assign({}, value, {
      name: value.name,
      message: value.message,
      stack: value.stack
    });
  }
  return value;
}
function makeTransport(mintTransport, logLevel) {
  switch (mintTransport) {
    case "console-json" /* ConsoleJson */:
      return new import_winston.transports.Console({
        level: logLevel,
        format: import_winston.format.combine(includeGlobalTags(), import_winston.format.errors(), import_winston.format.json({ replacer: jsonFriendlyErrorReplacer }))
      });
    case "console-text" /* ConsoleText */: {
      const formats = [import_winston.format.errors()];
      if (!process.env.MINT_LOGGER_SUPPRESS_COLORS) {
        formats.push(import_winston.format.colorize({ level: true }));
      }
      formats.push(
        import_winston.format.printf(({ level, message, timestamp, package: label, ...rest }) => {
          let timestampPart = "";
          if (timestamp) {
            timestampPart = `[${timestamp}] `;
          }
          const labelPart = label ? `(${label}) ` : "";
          const levelPart = level ? `[${level}]: ` : "";
          const messagePart = message ? message : "";
          let restPart = ` ${JSON.stringify(rest, jsonFriendlyErrorReplacer)}`;
          if (restPart === " {}") {
            restPart = "";
          }
          return timestampPart + labelPart + levelPart + messagePart + restPart;
        })
      );
      return new import_winston.transports.Console({
        level: logLevel,
        format: import_winston.format.combine(includeGlobalTags(), ...formats)
      });
    }
    case "test" /* Test */:
      return new TestTransport({ level: logLevel });
    default:
      assertExhaustive(mintTransport);
  }
}
var includeGlobalTags = (0, import_winston.format)((info) => {
  for (const [key, value] of Object.entries(Tags.get())) {
    info[key] = value;
  }
  return info;
});

// packages/task-parser/logger.ts
var logger2 = createLogger({ package: "bigtest" });
var logger_default = logger2;

// packages/utils/did-you-mean.ts
var import_damerau_levenshtein = __toESM(require_damerau_levenshtein(), 1);
function didYouMean(str, candidates) {
  const bestMatch = candidates.map((candidate) => ({
    candidate,
    ...(0, import_damerau_levenshtein.default)(str, candidate)
  })).filter((match) => match.similarity > 0.6).sort((a, b) => b.similarity - a.similarity)[0];
  if (!bestMatch) {
    return void 0;
  }
  return bestMatch.candidate;
}

// packages/containers/base-layer/index.ts
var import_node_assert5 = __toESM(require("node:assert"), 1);

// packages/containers/base-layer/data.json
var data_default = [
  {
    os: "ubuntu 24.04",
    tag: "1.2",
    user: {
      name: "ubuntu"
    },
    arch: "x86_64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "4c9939bcc4dd6221da328d43ef2dfb6516962e47d2aa098d6cb99833b2cfb706",
    layerFile: "4c9939bcc4dd6221da328d43ef2dfb6516962e47d2aa098d6cb99833b2cfb706.tar",
    layerSizeBytes: 997582336,
    mintRunId: "4a87ba7803f14e60bf9a68b3ee84add9",
    mintGitCommitSha: "4546be99a6e96839f7faf49e9fe22a778478a8ef"
  },
  {
    os: "ubuntu 24.04",
    tag: "1.2",
    user: {
      name: "ubuntu"
    },
    arch: "arm64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "7a872802a6366093a56d37df7bcdb6d12b9f849a417c578bfc58763e353141b7",
    layerFile: "7a872802a6366093a56d37df7bcdb6d12b9f849a417c578bfc58763e353141b7.tar",
    layerSizeBytes: 990777856,
    mintRunId: "4a87ba7803f14e60bf9a68b3ee84add9",
    mintGitCommitSha: "4546be99a6e96839f7faf49e9fe22a778478a8ef"
  },
  {
    os: "ubuntu 24.04",
    tag: "1.1",
    user: {
      name: "ubuntu"
    },
    arch: "x86_64",
    env: {},
    layerId: "558dd0267c1281b9df666ee7a6e0d5e15a042d90f7bf667fe3069d1feccf6783",
    layerFile: "558dd0267c1281b9df666ee7a6e0d5e15a042d90f7bf667fe3069d1feccf6783.tar",
    layerSizeBytes: 997495808,
    mintRunId: "4ca7dce46e954afc835efb5d65574a15",
    mintGitCommitSha: "070d1ea6d3a85fcfaff3123b3da7a4de5a73745a"
  },
  {
    os: "ubuntu 24.04",
    tag: "1.1",
    user: {
      name: "ubuntu"
    },
    arch: "arm64",
    env: {},
    layerId: "66433cffa6e2322bd7805627fc6904295e2e0c826b373d4870d2037babe9dbc2",
    layerFile: "66433cffa6e2322bd7805627fc6904295e2e0c826b373d4870d2037babe9dbc2.tar",
    layerSizeBytes: 990699520,
    mintRunId: "26b3f6ab2c0b4feaad62ab9f3281e8cb",
    mintGitCommitSha: "48f3c8983b54a7c035cf6f7bfa16d680df588644"
  },
  {
    os: "ubuntu 24.04",
    tag: "1.0",
    user: {
      name: "ubuntu"
    },
    arch: "x86_64",
    env: {},
    layerId: "3736a44d7912a995a2c57758e3b1e43b2b8bc0350805535fcd9b8b90a0efe608",
    layerFile: "3736a44d7912a995a2c57758e3b1e43b2b8bc0350805535fcd9b8b90a0efe608.tar",
    layerSizeBytes: 997433856,
    mintRunId: "0c6d49a3d1654e08bbc3799e61ecdac4",
    mintGitCommitSha: "16e756a470e8ca77c5830289a77a89693c56fbab"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.2",
    user: {
      name: "ubuntu"
    },
    arch: "x86_64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "66474a37e2dfcb32ecfb47517558bcba8a2159b1af70e1ac82082ab81599c665",
    layerFile: "66474a37e2dfcb32ecfb47517558bcba8a2159b1af70e1ac82082ab81599c665.tar",
    layerSizeBytes: 921620480,
    rwxRunId: "27ac16f99f6549e884cf64bb9f213cc0",
    rwxGitCommitSha: "deed165a6cf74ee61c627be4731577f2f2dec6b0"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.2",
    user: {
      name: "ubuntu"
    },
    arch: "arm64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "7a95e30746f564f66c1208bccebac337b9dee7dd6dc687f6f6e2d46689616d8d",
    layerFile: "7a95e30746f564f66c1208bccebac337b9dee7dd6dc687f6f6e2d46689616d8d.tar",
    layerSizeBytes: 835253760,
    rwxRunId: "b0e888455577403ca84ac06923ed37c2",
    rwxGitCommitSha: "b9d8fe5427e1c47237238d556b457df7a457000e"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.1",
    user: {
      name: "ubuntu"
    },
    arch: "x86_64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "897a138a2c8b98b6915dd055af27a7ce9f20ef7295e97615cdd0ab1223ce80e0",
    layerFile: "897a138a2c8b98b6915dd055af27a7ce9f20ef7295e97615cdd0ab1223ce80e0.tar",
    layerSizeBytes: 921601536,
    mintRunId: "d18a934e015e497d8ee0204b68bd2063",
    mintGitCommitSha: "0e3954be1ea8b9268f83a3bd567c686e6106c1f7"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.1",
    user: {
      name: "ubuntu"
    },
    arch: "arm64",
    env: {
      LANG: "C.UTF-8"
    },
    layerId: "0948ab0f6ad4c13fc8f2f8520cf0bb96c26fa09dc97c494f430e3fce456918f2",
    layerFile: "0948ab0f6ad4c13fc8f2f8520cf0bb96c26fa09dc97c494f430e3fce456918f2.tar",
    layerSizeBytes: 835238912,
    mintRunId: "d18a934e015e497d8ee0204b68bd2063",
    mintGitCommitSha: "0e3954be1ea8b9268f83a3bd567c686e6106c1f7"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.0",
    arch: "x86_64",
    layerId: "ee9b1c14b0f12fb29997cee03cd70544678097b6389d3182e8243688ca7fa315",
    layerFile: "ee9b1c14b0f12fb29997cee03cd70544678097b6389d3182e8243688ca7fa315.tar",
    layerSizeBytes: 921597952,
    user: {
      name: "ubuntu"
    },
    env: {},
    mintRunId: "",
    mintGitCommitSha: ""
  },
  {
    os: "ubuntu 22.04",
    tag: "1.0",
    user: {
      name: "ubuntu"
    },
    arch: "arm64",
    env: {},
    layerId: "a3042e39807ec1ad2dc9fd1a830baf29c51c74313d9f6d23ed14c2217ad25690",
    layerFile: "a3042e39807ec1ad2dc9fd1a830baf29c51c74313d9f6d23ed14c2217ad25690.tar",
    layerSizeBytes: 835237888,
    mintRunId: "2d2f19708b9d43be8d26d0f953dd8039",
    mintGitCommitSha: "ef275c839c606b8bc3702b3cdcb8b4c016300011"
  }
];

// packages/containers/base-layer/index.ts
var architectures = ["x86_64", "arm64"];
var defaultArchitecture = "x86_64";
var BaseLayers = new Singleton(
  "BaseLayers",
  data_default.map((base) => {
    (0, import_node_assert5.default)(architectures.includes(base.arch), `Invalid architecture: ${base.arch}`);
    const { mintRunId: _mintRunId, mintGitCommitSha: _mintGitCommitSha, env, ...rest } = base;
    (0, import_node_assert5.default)(typeof env === "object", "env must be an object");
    const untypedEnv = env;
    return {
      ...rest,
      env: untypedEnv,
      arch: base.arch
    };
  })
);
var BaseLayerSpecifications = new Singleton(
  "BaseLayerSpecifications",
  BaseLayers.get().map(({ os, tag, arch }) => ({ os, tag, arch }))
);
function findBaseLayer(spec) {
  if ("layerId" in spec) {
    return BaseLayers.get().find((base) => base.layerId === spec.layerId) ?? null;
  } else if ("os" in spec && "tag" in spec) {
    const specWithArch = { ...spec, arch: spec.arch ?? defaultArchitecture };
    return BaseLayers.get().find((base) => base.os === specWithArch.os && base.tag === specWithArch.tag && base.arch === specWithArch.arch) ?? null;
  } else {
    return findBaseLayerForArch(spec.arch) ?? null;
  }
}
function mustFindBaseLayer(spec) {
  const baseLayer = findBaseLayer(spec);
  if (!baseLayer) throw new Error(`Base layer for '${JSON.stringify(spec)}' not found`);
  return baseLayer;
}
function findBaseLayerForArch(arch) {
  switch (arch) {
    case "x86_64":
      return findBaseLayer({ os: "ubuntu 22.04", tag: "1.1", arch: "x86_64" });
    case "arm64":
      return findBaseLayer({ os: "ubuntu 24.04", tag: "1.1", arch: "arm64" });
    default:
      assertExhaustive(arch);
  }
}
var defaultBaseLayerSpecification = { os: "ubuntu 24.04", tag: "1.2", arch: defaultArchitecture };
var defaultBaseLayer = (() => mustFindBaseLayer(defaultBaseLayerSpecification))();
var defaultBaseConfigForTesting = (() => {
  const layer = mustFindBaseLayer(defaultBaseLayerSpecification);
  return {
    image: void 0,
    prebuiltLayer: layer
  };
})();

// packages/server/models/run-definition/index.ts
function defaultBaseLayerSpecificationWithTemplateStrings() {
  return {
    os: defaultBaseLayerSpecification.os,
    tag: defaultBaseLayerSpecification.tag,
    arch: defaultBaseLayerSpecification.arch
  };
}

// packages/task-parser/yaml-dsl/cron-parser.ts
var import_cron_parser = __toESM(require_dist2(), 1);
var cronErrorMessage = `
Valid cron schedule syntax is:

\`\`\`
*    *    *    *    *   [TZ]
\u252C    \u252C    \u252C    \u252C    \u252C    \u252C
\u2502    \u2502    \u2502    \u2502    \u2502    \u2502
\u2502    \u2502    \u2502    \u2502    \u2502    \u2514\u2500 IANA Timezone (ex: Etc/UTC, America/New_York, optional)
\u2502    \u2502    \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500 day of week (0-7, 1L-7L) (0 or 7 is Sun)
\u2502    \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1-12, JAN-DEC)
\u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1-31, L)
\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0-23)
\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0-59)
\`\`\``;
function fail(message) {
  return {
    success: false,
    errorReason: message ? `${message}
${cronErrorMessage}` : `
${cronErrorMessage}`
  };
}
function validateCron(schedule) {
  let cron = schedule;
  let maybeTz;
  const fields = schedule.trim().split(/\s+/);
  let parsed;
  if (fields.length < 5 || fields.length > 6) {
    return fail();
  }
  try {
    parsed = import_cron_parser.CronExpressionParser.parse(cron);
  } catch {
    maybeTz = fields.pop();
    cron = fields.join(" ");
    const revalidate = validateCron(cron);
    if (!revalidate.success) {
      return revalidate;
    }
    if (maybeTz) {
      if (maybeTz.startsWith("US/")) {
        return fail(`\`${maybeTz}\` is not a valid IANA timezone. Try using the \`America/*\` equivalent.`);
      }
      if (!Intl.supportedValuesOf("timeZone").includes(maybeTz)) {
        let message = `\`${maybeTz}\` is not a valid IANA timezone.`;
        const suggestion = didYouMean(maybeTz, Intl.supportedValuesOf("timeZone"));
        if (suggestion) {
          message += ` Did you mean \`${suggestion}\`?`;
        }
        return fail(message);
      }
      parsed = import_cron_parser.CronExpressionParser.parse(cron);
      const result2 = validateDST(parsed, maybeTz);
      if (!result2.success) {
        return result2;
      }
    }
    return { success: true };
  }
  if (fields.length > 5 && !maybeTz) {
    return fail("Cron schedules do not support seconds. Schedules are evaluated each minute.");
  }
  const result = validateEndOfMonth(parsed);
  if (!result.success) {
    return result;
  }
  return { success: true };
}
function validateEndOfMonth(cron) {
  if (cron.fields.month.isWildcard) {
    if (cron.fields.dayOfMonth.values.every((day) => [31].includes(day))) {
      return fail("This schedule will skip February and any 30-day month. Did you mean to use `L` or explicitly specify months instead?");
    }
    if (cron.fields.dayOfMonth.values.every((day) => [30, 31].includes(day))) {
      return fail("This schedule will skip February. Did you mean to use `L` or explicitly specify months instead?");
    }
  }
  return { success: true };
}
function validateDST(cron, tz) {
  if (!cron.fields.month.isWildcard) {
    return { success: true };
  }
  if (!cron.fields.dayOfMonth.isWildcard) {
    return { success: true };
  }
  const notObserved = ["America/Phoenix", "America/Puerto_Rico", "Pacific/Honolulu"];
  if (notObserved.includes(tz)) {
    return { success: true };
  }
  if (!tz.startsWith("America/")) {
    return { success: true };
  }
  if (cron.fields.hour.values.every((day) => [2].includes(day))) {
    return fail("This schedule will skip during the daylight savings transition. Try scheduling in `Etc/UTC` or adjusting the hour.");
  }
  return { success: true };
}

// packages/task-parser/yaml-dsl/parser2.ts
var FRIENDLY_YAML_MESSAGES = {
  ALIAS_PROPS: "When using an alias, you cannot add an anchor or a YAML tag before the alias.",
  BAD_ALIAS: "In YAML, values starting with `*` are aliases, and aliases must have a valid name. If you intended to use this as a value, wrap it in quotes.",
  BAD_COLLECTION_TYPE: void 0,
  // This one should be impossible in a workflow file since we don't resolve tags
  BAD_DIRECTIVE: "You started a value with a `%`, but in YAML `%` indicates a directive, not a value. Try wrapping your value in quotes instead.",
  BAD_DQ_ESCAPE: "This escape sequence is invalid. Backslashes inside of a double-quoted string must be followed by a valid character such as `\n`, `	`, or `\\`.",
  BAD_INDENT: "This line is incorrectly indented. Check the spacing and alignment of your YAML.",
  BAD_PROP_ORDER: "In YAML, anchors and tags must be after the ? indicator. If you intended this to be a string value, try wrapping it in quotes.",
  BAD_SCALAR_START: "This is a reserved character in YAML. Try wrapping it in quotes.",
  BLOCK_AS_IMPLICIT_KEY: "This line either is incorrectly indented or is ambiguous about what is the key and what is the value; try quoting the value.",
  BLOCK_IN_FLOW: "In YAML, when declaring an array with `[]`, you cannot use dashes. If you intended to include a value that starts with a dash, wrap the value in quotes.",
  DUPLICATE_KEY: "You cannot declare the same key twice in a YAML map or object.",
  IMPOSSIBLE: void 0,
  // This by definition should not happen
  KEY_OVER_1024_CHARS: "Keys in YAML cannot be longer than 1024 characters.",
  MISSING_CHAR: void 0,
  // These are explicitly handled based on the mssage because there are many different cases
  MULTILINE_IMPLICIT_KEY: "This line is incorrectly indented. Check the spacing and alignment of your YAML.",
  MULTIPLE_ANCHORS: "You can only specify one YAML anchor at a time.",
  MULTIPLE_DOCS: "You cannot declare multiple documents with `---`",
  MULTIPLE_TAGS: "You can only specify one YAML tag at a time.",
  NON_STRING_KEY: "Keys in YAML maps or objects must be strings. Try wrapping this value in quotes.",
  TAB_AS_INDENT: "You must use spaces, not tabs, for indentation.",
  TAG_RESOLVE_FAILED: void 0,
  // We don't resolve tags at all
  UNEXPECTED_TOKEN: "This character was unexpected here."
};
var FRIENDLY_YAML_MESSAGES_FOR_MISSING_CHAR = {
  "Block collection cannot start on same line with directives-end marker": "This list must start on a new line after the '---' or '...' marker.",
  "Comments must be separated from other tokens by white space characters": "In YAML, you must include a space before starting a comment with '#'.",
  "Tags and anchors must be separated from the next token by white space": "There must be a space between an anchor and the value after it. If you didn't intend to make a YAML anchor, wrap this value in quotes.",
  "Missing space after : in flow map": "When using `{`, a space is required after each colon (`:`).",
  "Missing space after : in flow sequence": "In inline lists (using `[`), a space is required after each colon (`:`) used in maps or objects inside the list.",
  "Missing closing 'quote": "Expected to find a closing single quote (').",
  'Missing closing "quote': 'Expected to find a closing double quote (").',
  "Implicit map keys need to be followed by map values": "This line is incorrectly indented or formatted. Make sure keys are followed by values (key: value).",
  "Sequence item without - indicator": "Each item in a list must start with a dash and a space (e.g., '- item').",
  "Block scalars with more-indented leading empty lines must use an explicit indentation indicator": "For multi-line text (`|` or `>`), if empty lines are indented more than the content, you must specify the indentation after the `|` or `>` (e.g., `|2`).",
  "Missing newline after block sequence props": "Each list item (starting with -) must be followed by a newline or a space before the value.",
  "Missing directives-end/doc-start indicator line": "YAML expects a '---' to mark the start of a document here.",
  "Missing directives-end indicator line": "YAML expects a '---' marker to separate directives from content.",
  "Missing , or : between flow sequence items": "In an inline list (using [ ]), items must be separated by commas.",
  "Missing , or : between flow map items": "In an inline map or object (using { }), key-value pairs must be separated by commas, and keys must have colons.",
  "Flow map must end with a }": "An inline map or object (using { }) is missing its closing '}'.",
  "Flow sequence must end with a ]": "An inline list (using [ ]) is missing its closing ']'.",
  "Flow map in block collection must be sufficiently indented and end with a }": "An inline map or object inside your YAML needs to be indented properly and closed with '}'.",
  "Flow sequence in block collection must be sufficiently indented and end with a ]": "An inline list inside your YAML needs to be indented properly and closed with ']'."
};
var YamlParser = class _YamlParser {
  constructor(fileName, fileSource, doc, snippets, errorOnMissingBase = true) {
    this.doc = doc;
    this.snippets = snippets;
    this.errorOnMissingBase = errorOnMissingBase;
    this.stack = [];
    this.currentFileName = fileName;
    this.linesMap = { [fileName]: new LinesAndColumns(fileSource) };
    this.sourceMap = { [fileName]: fileSource };
    for (const snippet of snippets.values()) {
      this.linesMap[snippet.filePath] = new LinesAndColumns(snippet.fileContents);
      this.sourceMap[snippet.filePath] = snippet.fileContents;
    }
    for (const error of doc.errors) {
      const message = this.getUserFriendlyYamlMessage(error);
      const start = this.locationOfIndex(error.pos[0], fileName);
      const end = this.locationOfIndex(error.pos[1], fileName);
      this.messages.push({
        message,
        severity: "error",
        stackTrace: [{ fileName, line: start.line, column: start.column, endLine: end.line, endColumn: end.column }]
      });
    }
    for (const warning of doc.warnings) {
      const start = this.locationOfIndex(warning.pos[0], fileName);
      const end = this.locationOfIndex(warning.pos[1], fileName);
      if (warning.code === "TAG_RESOLVE_FAILED") {
        const tagName = warning.message.match(/Unresolved tag: (.*)/)?.[1];
        if (tagName) {
          this.messages.push({
            message: `You started a value with a \`!\`, but in YAML \`!\` indicates a tag, not a value. Try wrapping your value in quotes instead: \`"${tagName}"\``,
            severity: "error",
            stackTrace: [{ fileName, line: start.line, column: start.column, endLine: end.line, endColumn: end.column }]
          });
        } else {
          logger_default.warn(`Tag resolve failure did not match expected regex`, {
            codeFrame: this.generateCodeFrame({ fileName, line: start.line, column: start.column }),
            message: warning.message
          });
          this.messages.push({
            message: warning.message,
            severity: "error",
            stackTrace: [{ fileName, line: start.line, column: start.column, endLine: end.line, endColumn: end.column }]
          });
        }
      } else {
        logger_default.warn(`Detected unhandled YAML parsing warning code: ${warning.code}`, {
          codeFrame: this.generateCodeFrame({ fileName, line: start.line, column: start.column })
        });
      }
    }
    if (doc.contents === null) {
      this.rootNode = null;
    } else {
      for (const [source, startIndex] of this.detectCircularAliases(doc.contents).entries()) {
        const start = this.locationOfIndex(startIndex, fileName);
        this.messages.push({
          message: `Circular alias detected ${codeQuote(source)}`,
          severity: "error",
          stackTrace: [{ fileName, line: start.line, column: start.column }]
        });
      }
      this.rootNode = this.synchronousDealias(doc.contents)[0];
    }
  }
  messages = [];
  linesMap;
  sourceMap;
  rootNode;
  warnedAboutUsingCacheInsteadOfCacheKey = false;
  currentFileName;
  stack;
  getUserFriendlyYamlMessage(error) {
    let friendlyMessage = FRIENDLY_YAML_MESSAGES[error.code];
    if (!friendlyMessage && error.code === "MISSING_CHAR") {
      friendlyMessage = FRIENDLY_YAML_MESSAGES_FOR_MISSING_CHAR[error.message];
    }
    if (friendlyMessage) {
      return friendlyMessage;
    }
    logger_default.warn("Unexpected YAML error encountered while parsing", { message: error.message, code: error.code });
    return `Error while parsing YAML: ${error.message}`;
  }
  detectCircularAliases(document) {
    const circularAliases = /* @__PURE__ */ new Map();
    YAML.visit(document, {
      Alias(_key, aliasNode, path) {
        const anchor = path.find((node) => YAML.isNode(node) && node.anchor && node.anchor === aliasNode.source);
        if (YAML.isNode(anchor)) {
          (0, import_node_assert6.default)(anchor.range);
          circularAliases.set(aliasNode.source, anchor.range[0]);
        }
      }
    });
    return circularAliases;
  }
  static async parseRun(fileName, source, snippets) {
    const parser = _YamlParser.createParser(fileName, source, snippets);
    const partialRunDefinition = await parser.parseRun();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return partialRunDefinition;
  }
  static async safelyParseRun(fileName, source, snippets) {
    try {
      const parser = _YamlParser.createParser(fileName, source, snippets, false);
      const partialRunDefinition = await parser.parseRun();
      const { errors } = parser.formatMessages();
      return { partialRunDefinition, errors };
    } catch (error) {
      if (error instanceof ParsingError) {
        return {
          partialRunDefinition: { tasks: [], warningMessages: [], baseConfig: defaultBaseLayerSpecificationWithTemplateStrings() },
          errors: error.asMessages()
        };
      }
      throw error;
    }
  }
  static async parseTaskOrTaskList(fileName, source, snippets) {
    const parser = _YamlParser.createParser(fileName, source, snippets);
    const partialTaskDefinitions = await parser.parseTaskOrTaskList();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return partialTaskDefinitions;
  }
  static async parseLeafSpec(fileName, source) {
    const parser = _YamlParser.createParser(fileName, source, /* @__PURE__ */ new Map());
    const leafSpec = await parser.parseLeafSpec();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return leafSpec;
  }
  static createParser(fileName, source, snippets, errorOnMissingBase = true) {
    const schemaOptions = { merge: true, prettyErrors: false, stringKeys: true };
    const doc = YAML.parseDocument(source, schemaOptions);
    const parser = new _YamlParser(fileName, source, doc, snippets, errorOnMissingBase);
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return parser;
  }
  dealias = async (node, callback) => {
    const [dealiasedNode, didDealias, aliasName] = this.synchronousDealias(node);
    if (didDealias) {
      (0, import_node_assert6.default)(YAML.isAlias(node));
      const { line, column } = this.locationOfIndex(node.range[0], this.currentFileName);
      this.stack.push({ fileName: this.currentFileName, line, column, name: aliasName });
    }
    const result = await callback(dealiasedNode);
    if (didDealias) {
      this.stack.pop();
    }
    return result;
  };
  synchronousDealias = (node) => {
    let didDealias = false;
    let aliasName;
    if (YAML.isAlias(node)) {
      didDealias = true;
      aliasName = `*${node.source}`;
      const newNode = node.resolve(this.doc);
      const { line, column, endLine, endColumn } = this.locationRangeOfNode(node, this.currentFileName);
      if (newNode === void 0) {
        throw new ParsingError([
          this.formatMessage({
            message: `Unresolved alias (the anchor must be set before the alias)`,
            severity: "error",
            stackTrace: [...this.stack, { fileName: this.currentFileName, line, column, endLine, endColumn }]
          })
        ]);
      }
      node = newNode;
    }
    return [node, didDealias, aliasName];
  };
  parseRun = async () => {
    const warningCollector = [];
    if (this.rootNode === null) {
      this.error([`A run definition must include at least a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [], baseConfig: defaultBaseLayerSpecificationWithTemplateStrings() };
    }
    const { fields } = await this.parseObject(
      this.rootNode,
      {
        "concurrency-pools": this.parseRunConcurrenyPools,
        on: this.parseRunOn,
        "tool-cache": this.parseRunToolCache,
        tasks: this.parseTasksList,
        base: this.parseBaseConfig,
        aliases: () => {
        }
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A run definition must contain a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [], baseConfig: defaultBaseLayerSpecificationWithTemplateStrings() };
    }
    if (fields.base === void 0) {
      const allTasksAreEmbeddedRuns = fields.tasks.every((task) => task.type === "embedded-run" /* EmbeddedRun */);
      if (this.errorOnMissingBase && !allTasksAreEmbeddedRuns) {
        this.error(
          [
            `A run definition must contain a ${codeQuote("base")} configuration.`,
            `See ${"https://www.rwx.com/docs/mint/base" /* Base */} to learn about configuring the ${codeQuote("base")} layer.`
          ],
          this.doc
        );
        return { tasks: [], warningMessages: [], baseConfig: defaultBaseLayerSpecificationWithTemplateStrings() };
      }
      if (!allTasksAreEmbeddedRuns) {
        this.warning({ warningCollector, message: `A run definition must contain a ${codeQuote("base")} configuration.`, node: this.rootNode });
      }
      fields.base = defaultBaseLayerSpecificationWithTemplateStrings();
    }
    return {
      concurrencyPools: fields["concurrency-pools"],
      toolCache: fields["tool-cache"],
      triggers: fields.on,
      tasks: fields.tasks,
      baseConfig: fields.base,
      warningMessages: warningCollector
    };
  };
  parseTaskOrTaskList = async () => {
    if (this.rootNode === null) {
      this.error([`Expected a task, or a list of tasks`], this.doc);
      return [];
    }
    if (YAML.isSeq(this.rootNode)) {
      return this.parseTasksList(this.rootNode, [], this.doc.range[0]);
    }
    if (YAML.isMap(this.rootNode)) {
      const task = await this.parseTask(this.rootNode, [], this.doc.range[0]);
      return [task];
    }
    this.error([`Expected a task, or a list of tasks`], this.rootNode);
    return [];
  };
  parseLeafSpec = async () => {
    const warningCollector = [];
    if (this.rootNode === null) {
      this.error([`A package spec must include at least a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [] };
    }
    const { fields } = await this.parseObject(
      this.rootNode,
      {
        name: this.parseLeafName,
        version: this.parseLeafVersion,
        description: this.parseString,
        source_code_url: this.parseString,
        issue_tracker_url: this.parseString,
        parameters: this.parseLeafSpecParameters,
        outputs: this.parseLeafSpecOutputs,
        tasks: this.parseTasksList
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A package spec must contain a ${codeQuote("tasks")} key`], this.doc);
      fields.tasks = [];
    }
    const start = 0;
    const end = this.rootNode.range[1];
    return {
      tasks: fields.tasks,
      description: fields.description,
      sourceCodeUrl: fields.source_code_url,
      issueTrackerUrl: fields.issue_tracker_url,
      name: fields.name,
      parameters: fields.parameters,
      outputs: fields.outputs,
      version: fields.version,
      rawSource: { definition: verifyExists(this.sourceMap[this.currentFileName]).slice(start, end), start, end },
      warningMessages: warningCollector
    };
  };
  parseRunConcurrenyPools = async (node, warningCollector) => {
    return this.parseList(node, this.parseRunConcurrenyPool, warningCollector);
  };
  parseRunConcurrenyPool = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        id: this.parseStringTemplate,
        if: this.parseExactExpression,
        capacity: (node2) => this.parseNumber(node2, { minimum: 1 }),
        "on-overflow": (node2) => this.parseTypeBox(node2, Type.Enum(OnOverflow))
      },
      warningCollector
    );
    if (fields.id === void 0) {
      this.error([`A concurrency pool must have an ${codeQuote("id")} key`], node);
      fields.id = "";
    }
    if (fields["on-overflow"] === void 0) {
      this.error([`A concurrency pool must have an ${codeQuote("on-overflow")} key`], node);
      fields["on-overflow"] = "queue" /* Queue */;
    }
    const concurrencyPool = {
      id: fields.id,
      if: fields.if,
      capacity: fields.capacity ?? 1,
      onOverflow: fields["on-overflow"]
    };
    return concurrencyPool;
  };
  parseBaseConfig = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        os: this.parseStringableTemplate,
        image: this.parseStringableNoExpression,
        config: this.parseStringableNoExpression,
        tag: this.parseStringableTemplate,
        arch: this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.os !== void 0 && fields.image !== void 0) {
      this.error([`A base layer can have an ${codeQuote("os")} or an ${codeQuote("image")} key, but not both`], node);
    }
    if (fields.os === void 0 && fields.image === void 0) {
      this.error([`A base layer must have an ${codeQuote("os")} or an ${codeQuote("image")} key`], node);
    }
    if (fields.os !== void 0 && fields.tag === void 0) {
      this.error([`A base layer must have a ${codeQuote("tag")} key if it has an ${codeQuote("os")} key`], node);
    }
    if (fields.image !== void 0 && fields.config === void 0) {
      this.error([`A base layer must have a ${codeQuote("config")} key if it has an ${codeQuote("image")} key`], node);
    }
    if (fields.tag !== void 0 && /^\d+$/.test(fields.tag)) {
      fields.tag = `${fields.tag}.0`;
    }
    return fields;
  };
  parseRunOn = async (node, warningCollector) => {
    if (YAML.isScalar(node) && node.value === null) {
      return void 0;
    }
    const { fields } = await this.parseObject(
      node,
      {
        github: this.parseGithubTriggers,
        gitlab: this.parseGitlabTriggers,
        cron: this.parseCronTriggers,
        cli: this.parseCliTrigger,
        dispatch: this.parseDispatchTriggers,
        "cache-rebuild": this.parseCacheRebuildTriggers,
        webhook: this.parseWebhookTriggers
      },
      warningCollector
    );
    return {
      github: fields.github ?? { pullRequest: [], push: [] },
      gitlab: fields.gitlab ?? { push: [], tagPush: [], mergeRequest: [] },
      cron: fields.cron ?? [],
      // For compatibility with the old parser. Can be removed later.
      cli: fields.cli ?? { title: void 0, init: {}, start: "automatically" /* Automatically */ },
      dispatch: fields.dispatch ?? [],
      cacheRebuild: fields["cache-rebuild"] ?? [],
      webhook: fields.webhook ?? []
    };
  };
  parseGithubTriggers = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        push: this.parseGithubPushTriggers,
        pull_request: this.parseGithubPullRequestTriggers
      },
      warningCollector
    );
    return {
      push: fields.push ?? [],
      pullRequest: fields.pull_request ?? []
    };
  };
  parseGithubPushTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGithubPushTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGithubPushTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGithubPullRequestTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGithubPullRequestTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGithubPullRequestTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGithubPushTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        "status-checks": this.parseStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      statusChecks: fields["status-checks"] ?? { default: { enabled: "true", name: void 0 }, custom: [] }
    };
  };
  parseGithubPullRequestTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        actions: (actionList) => this.parseList(actionList, this.parseString, warningCollector),
        "status-checks": this.parseStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      actions: fields.actions,
      statusChecks: fields["status-checks"] ?? { default: { enabled: "true", name: void 0 }, custom: [] }
    };
  };
  parseStatusChecks = async (node, warningCollector, start) => {
    if (YAML.isSeq(node)) {
      return {
        default: { enabled: "true", name: void 0 },
        custom: await this.parseList(node, this.parseCustomStatusCheck, warningCollector)
      };
    } else if (YAML.isMap(node)) {
      const statusCheckFields = await this.parseGenericRecord(node, (n) => n.toString(), []);
      if ("default" in statusCheckFields || "custom" in statusCheckFields) {
        const { fields } = await this.parseObject(
          node,
          {
            default: this.parseDefaultStatusCheck,
            custom: (customList) => this.parseList(customList, this.parseCustomStatusCheck, warningCollector)
          },
          warningCollector
        );
        return {
          default: fields.default ?? { enabled: "true", name: void 0 },
          custom: fields.custom ?? []
        };
      } else {
        return {
          default: await this.parseDefaultStatusCheck(node, warningCollector, start),
          custom: []
        };
      }
    } else if (YAML.isScalar(node)) {
      return {
        default: await this.parseDefaultStatusCheck(node, warningCollector, start),
        custom: []
      };
    } else {
      this.error([`Expected a list of status checks, a status check object, true, or false.`], node);
      return {
        default: { enabled: "true", name: void 0 },
        custom: []
      };
    }
  };
  parseDefaultStatusCheck = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return { enabled: await this.parseStringableTemplate(node), name: void 0 };
    }
    if (YAML.isMap(node)) {
      const { fields } = await this.parseObject(
        node,
        {
          enabled: this.parseStringableTemplate,
          name: this.parseStringableTemplate
        },
        warningCollector
      );
      if (fields.enabled === void 0) {
        fields.enabled = "true";
      }
      return {
        enabled: fields.enabled,
        name: fields.name
      };
    }
    this.error([`Expected true, false, or an object.`], node);
    return { enabled: "true", name: void 0 };
  };
  parseCustomStatusCheck = async (node, warningCollector, start) => {
    const { fields } = await this.parseObject(
      node,
      {
        tasks: (taskListOrTask) => this.parseListOrValue(taskListOrTask, this.parseString, warningCollector, start),
        name: this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A custom status check must specify the ${codeQuote("tasks")} it reports.`], node);
      fields.tasks = [];
    }
    if (typeof fields.tasks === "string") {
      fields.tasks = [fields.tasks];
    }
    return {
      tasks: fields.tasks,
      name: fields.name,
      status: "pending"
    };
  };
  parseGitlabTriggers = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        push: this.parseGitlabPushOrTagPushTriggers,
        "tag-push": this.parseGitlabPushOrTagPushTriggers,
        "merge-request": this.parseGitlabMergeRequestTriggers
      },
      warningCollector
    );
    return {
      push: fields.push ?? [],
      tagPush: fields["tag-push"] ?? [],
      mergeRequest: fields["merge-request"] ?? []
    };
  };
  parseGitlabPushOrTagPushTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGitlabPushOrTagPushTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGitlabPushOrTagPushTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGitlabMergeRequestTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGitlabMergeRequestTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGitlabMergeRequestTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGitlabPushOrTagPushTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        "status-checks": this.parseStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      statusChecks: fields["status-checks"] ?? { default: { enabled: "true", name: void 0 }, custom: [] }
    };
  };
  parseGitlabMergeRequestTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        actions: (actionList) => this.parseList(actionList, this.parseString, warningCollector),
        "status-checks": this.parseStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      actions: fields.actions,
      statusChecks: fields["status-checks"] ?? { default: { enabled: "true", name: void 0 }, custom: [] }
    };
  };
  parseCronTriggers = async (node, warningCollector) => {
    if (isYamlNull(node)) {
      return [];
    }
    const seenKeys = /* @__PURE__ */ new Set();
    const cronTriggerParser = this.parseCronTrigger(seenKeys);
    return this.parseList(node, cronTriggerParser, warningCollector);
  };
  parseCronTrigger = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        key: this.parseKey,
        schedule: this.parseString,
        branch: this.parseString,
        "reset-tool-cache": this.parseBoolean
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A cron trigger must have a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(keyNodes.key);
      this.error([`Duplicate cron ${codeQuote(fields.key)} found. Cron keys must be unique within a run definition.`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.schedule === void 0) {
      this.error([`A cron trigger must have a ${codeQuote("schedule")} key`], node);
      fields.schedule = "";
    } else {
      const keyNode = verifyExists(keyNodes.schedule);
      const resp = validateCron(fields.schedule);
      if (!resp.success) {
        this.error([`Invalid cron schedule ${codeQuote(fields.schedule)} found. ${resp.errorReason}`], keyNode);
      }
    }
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      key: fields.key,
      schedule: fields.schedule,
      branch: fields.branch,
      resetToolCache: fields["reset-tool-cache"]
    };
    return trigger;
  };
  parseCliTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        title: this.parseString,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region
    };
  };
  parseDispatchTriggers = async (node, warningCollector) => {
    if (isYamlNull(node)) {
      return [];
    }
    const seenKeys = /* @__PURE__ */ new Set();
    const dispatchTriggerParser = this.parseDispatchTrigger(seenKeys);
    return this.parseList(node, dispatchTriggerParser, warningCollector);
  };
  parseDispatchTrigger = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        key: this.parseKey,
        params: (node2) => this.parseList(node2, this.parseDispatchParam, warningCollector)
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A dispatch trigger must have a globally unique ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate dispatch ${codeQuote(fields.key)} found. Dispatch keys must be globally unique.`], keyNode);
    }
    seenKeys.add(fields.key);
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      key: fields.key,
      params: fields.params ?? []
    };
    return trigger;
  };
  parseDispatchParam = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return {
        key,
        name: void 0,
        description: void 0,
        default: void 0,
        required: false
      };
    }
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        name: this.parseString,
        description: this.parseString,
        default: this.parseString,
        required: this.parseBoolean
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A dispatch param must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    return {
      key: fields.key,
      name: fields.name,
      description: fields.description,
      default: fields.default,
      required: fields.required ?? false
    };
  };
  parseCacheRebuildTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseCacheRebuildTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseCacheRebuildTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseCacheRebuildTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        ref: this.parseString
      },
      warningCollector
    );
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      ref: fields.ref
    };
    return trigger;
  };
  parseWebhookTriggers = async (node, warningCollector) => {
    if (isYamlNull(node)) {
      return [];
    }
    const seenKeys = /* @__PURE__ */ new Set();
    const webhookTriggerParser = this.parseWebhookTrigger(seenKeys);
    return this.parseList(node, webhookTriggerParser, warningCollector);
  };
  parseWebhookTrigger = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        start: this.parseStartBehavior,
        region: this.parseStringTemplate,
        key: this.parseKey
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A webhook trigger must have a globally unique ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate webhook ${codeQuote(fields.key)} found. Webhook keys must be globally unique.`], keyNode);
    }
    seenKeys.add(fields.key);
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      start: fields.start ?? "automatically" /* Automatically */,
      region: fields.region,
      key: fields.key
    };
    return trigger;
  };
  parseTriggerTarget = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return [key];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseKey, warningCollector, { minimumItems: 1 });
    }
    this.error(["Expected a task key, or a list of task keys"], node);
    return [];
  };
  parseRunToolCache = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        vault: this.parseString
      },
      warningCollector
    );
    if (fields.vault === void 0) {
      this.error([`Tool cache configurations must have a ${codeQuote("vault")} key`], node);
      fields.vault = "";
    }
    const toolCache = {
      vault: fields.vault
    };
    return toolCache;
  };
  parseTasksList = async (node, warningCollector, listStart) => {
    return this.parseList(node, this.parseTask, warningCollector, { listStart, minimumItems: 1 });
  };
  static FAKE_TASK = {
    type: "leaf" /* Leaf */,
    key: "#fake",
    dependencies: { type: "standard" /* Standard */, keys: [] },
    leaf: { type: "digest" /* Digest */, digest: "" },
    warningMessages: [],
    autoCancel: TEMPLATE_FALSE
  };
  parseTask = async (node, _, start) => {
    const warningCollector = [];
    const errorMessage = `Expected a task with a ${codeQuote("run")} key, a ${codeQuote("call")} key using a package, or a ${codeQuote(
      "call"
    )} key for an embedded run`;
    if (!YAML.isMap(node)) {
      this.error([errorMessage], node);
      return _YamlParser.FAKE_TASK;
    }
    const taskFields = await this.parseGenericRecord(node, (n) => n.toString(), []);
    let task;
    if ("run" in taskFields) {
      task = await this.parseCommandTask(node, warningCollector, start);
    } else if ("call" in taskFields) {
      if (taskFields.call.trim().startsWith("${{")) {
        task = await this.parseEmbeddedRunTask(node, warningCollector, start);
      } else {
        task = await this.parseLeafTask(node, warningCollector, start);
      }
    } else {
      this.error([errorMessage], node);
      return _YamlParser.FAKE_TASK;
    }
    const end = node.range[1];
    task.rawSource = { definition: verifyExists(this.sourceMap[this.currentFileName]).slice(start, end), start, end };
    return task;
  };
  parseCommandTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        agent: this.parseAgent,
        key: this.parseKey,
        use: this.parseUse,
        after: this.parseAfter,
        if: this.parseExactExpression,
        filter: this.parseCommandFilter,
        cache: this.parseCache({ command: true }),
        run: this.parseCommand,
        "background-processes": this.parseBackgroundProcesses,
        outputs: this.parseOutputs,
        env: this.parseEnv,
        "env-config": this.parseEnvConfig,
        "timeout-minutes": (n) => this.parseNumber(n),
        timeout: this.parseStringTemplate,
        "health-timeout": this.parseStringTemplate,
        "auto-cancel": this.parseStringableTemplate,
        "terminate-grace-period-seconds": (node2) => this.parseNumber(node2, { minimum: 0 }),
        "tool-cache": this.parseStringableTemplate,
        parallel: this.parseParallel,
        docker: this.parseDocker,
        retry: this.parseRetry
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.run === void 0) {
      this.error([`A command task must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    let env = void 0;
    if (fields.env || fields["env-config"]) {
      env = {
        envVars: fields.env,
        inherit: fields["env-config"]?.inherit,
        merge: fields["env-config"]?.merge
      };
    }
    let timeout = fields.timeout;
    if (fields["timeout-minutes"] !== void 0 && fields.timeout !== void 0) {
      this.error([`Cannot specify both ${codeQuote("timeout")} and ${codeQuote("timeout-minutes")}. Use ${codeQuote("timeout")} instead.`], node);
    }
    if (fields["timeout-minutes"] !== void 0) {
      const timeoutMinutes = fields["timeout-minutes"];
      timeout = `${timeoutMinutes}m`;
      let suggestion = codeQuote("timeout");
      if (timeoutMinutes > 0) {
        suggestion = codeQuote(`timeout: ${timeoutMinutes}m`);
      }
      this.warning({
        warningCollector,
        node,
        message: `The ${codeQuote("timeout-minutes")} field is deprecated. Use ${suggestion} instead.`,
        docs: `See ${"https://www.rwx.com/docs/mint/timeouts" /* TimeoutMinutes */}.`
      });
    }
    return {
      type: "command" /* Command */,
      agent: fields.agent ?? { disk: {}, placement: "standard" },
      key: fields.key,
      command: fields.run,
      dependencies: fields.use ?? { type: "standard" /* Standard */, keys: [] },
      backgroundProcesses: fields["background-processes"] ?? [],
      artifactPaths: fields.outputs?.artifactPaths ?? [],
      problemMatchers: fields.outputs?.problemMatchers ?? [],
      problemPaths: fields.outputs?.problemPaths ?? [],
      successExitCodes: fields.outputs?.successExitCodes ?? [],
      testResultsPaths: fields.outputs?.testResultsPaths ?? [],
      values: fields.outputs?.values ?? [],
      after: fields.after,
      cacheConfiguration: fields.cache,
      docker: fields.docker,
      env,
      filter: fields.filter,
      if: fields.if,
      parallel: fields.parallel,
      timeout,
      healthTimeout: fields["health-timeout"] ?? "auto",
      autoCancel: fields["auto-cancel"] ?? TEMPLATE_FALSE,
      terminateGracePeriodSeconds: fields["terminate-grace-period-seconds"],
      toolCache: fields["tool-cache"],
      warningMessages: warningCollector,
      deduplicateOutputFilesystem: fields.outputs?.filesystem?.deduplicate ?? "false",
      outputFilesystemFilter: fields.outputs?.filesystem?.filter ?? {},
      automaticRetries: fields.retry
    };
  };
  parseLeafTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        use: this.parseUse,
        after: this.parseAfter,
        if: this.parseExactExpression,
        filter: this.parseWorkspaceFilter,
        cache: this.parseCache({ command: false }),
        call: this.parseLeafIdentifier,
        with: this.parseInit,
        env: this.parseEnv,
        "env-config": this.parseEnvConfig,
        parallel: this.parseParallel,
        "auto-cancel": this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.call === void 0) {
      this.error([`Missing a ${codeQuote("call")} key with the name of the package or path to an embedded run definition`], node);
      fields.call = { type: "digest" /* Digest */, digest: "" };
    }
    let env = void 0;
    if (fields.env || fields["env-config"]) {
      env = {
        envVars: fields.env,
        inherit: fields["env-config"]?.inherit,
        merge: fields["env-config"]?.merge
      };
    }
    return {
      type: "leaf" /* Leaf */,
      key: fields.key,
      dependencies: fields.use ?? { type: "standard" /* Standard */, keys: [] },
      after: fields.after,
      if: fields.if,
      cacheConfiguration: fields.cache,
      parallel: fields.parallel,
      leaf: fields.call,
      filter: fields.filter ? { workspace: fields.filter } : void 0,
      parameters: fields.with,
      env,
      warningMessages: warningCollector,
      autoCancel: fields["auto-cancel"] ?? TEMPLATE_FALSE
    };
  };
  parseLeafName = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_NAME = new RegExp("^\\s*([a-z0-9-]+\\/[a-z0-9-]+)\\s*$");
    if (parsed.match(RE_LEAF_NAME) === null) {
      this.error(
        [`Invalid package name; a package name must match the regex ${codeQuote(RE_LEAF_NAME.source)} (for example, ${codeQuote("git/clone")})`],
        node
      );
    }
    return parsed;
  };
  parseLeafVersion = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_VERSION = new RegExp("^\\s*([0-9]+\\.[0-9]+\\.[0-9]+)\\s*$");
    if (parsed.match(RE_LEAF_VERSION) === null) {
      this.error(
        [`Invalid package version; a package version must match the regex ${codeQuote(RE_LEAF_VERSION.source)} (for example, ${codeQuote("1.0.2")})`],
        node
      );
    }
    return parsed;
  };
  parseLeafIdentifier = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_NAME_VERSION = new RegExp("^\\s*([a-z0-9-]+\\/[a-z0-9-]+)\\s+([0-9]+\\.[0-9]+\\.[0-9]+)\\s*$");
    const RE_LEAF_DIGEST = new RegExp("^[a-f0-9]{64}$");
    const matchNameVersion = parsed.match(RE_LEAF_NAME_VERSION);
    if (matchNameVersion) {
      const [name, version] = matchNameVersion.slice(1);
      (0, import_node_assert6.default)(name && version, `Missing name or version after checking regex on "${parsed}"`);
      return { type: "name-version" /* NameVersion */, name, version };
    }
    const matchDigest = parsed.match(RE_LEAF_DIGEST);
    if (matchDigest) {
      return { type: "digest" /* Digest */, digest: parsed };
    }
    this.error([`Expected a package with a name and version (like ${codeQuote("git/clone 1.0.0")}), or its digest.`], node);
    return { type: "digest" /* Digest */, digest: "" };
  };
  parseEmbeddedRunTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        after: this.parseAfter,
        if: this.parseExactExpression,
        cache: this.parseCache({ command: false }),
        parallel: this.parseParallel,
        call: this.parseEmbeddedRunDefinitionSource,
        init: this.parseEmbeddedRunInit,
        "inherit-init": this.parseBoolean,
        target: this.parseTriggerTarget,
        "auto-cancel": this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.call === void 0) {
      this.error([`An embedded run must have a ${codeQuote("call")} key with the source of the embedded run`], node);
      fields.call = { type: "in-memory-mint-dir" /* InMemoryMintDir */, runDefinitionPath: "" };
    }
    if (fields["inherit-init"] === false && fields.init === "inherit") {
      this.error([`An embedded run cannot specify both ${codeQuote("inherit-init: false")} and ${codeQuote("init: inherit")}.`], node);
    }
    return {
      type: "embedded-run" /* EmbeddedRun */,
      key: fields.key,
      after: fields.after,
      cacheConfiguration: fields.cache,
      if: fields.if,
      parallel: fields.parallel,
      runDefinitionSource: fields.call,
      inheritInit: fields["inherit-init"] ?? fields.init === "inherit",
      parameters: fields.init === "inherit" ? void 0 : fields.init,
      warningMessages: warningCollector,
      targets: typeof fields.target === "string" ? [fields.target] : fields.target,
      autoCancel: fields["auto-cancel"] ?? TEMPLATE_FALSE
    };
  };
  parseEmbeddedRunDefinitionSource = (node) => {
    const value = this.parseString(node);
    const RE_IN_MEMORY_RUN_DEFINITION_PATH = new RegExp("^\\s*\\${{\\s*run\\.(mint-dir|dir)\\s*}}\\/(?<path>.+\\.[yY][aA]?[mM][lL])\\s*$");
    const matchInMemoryPath = value.match(RE_IN_MEMORY_RUN_DEFINITION_PATH);
    if (matchInMemoryPath) {
      const path = matchInMemoryPath.groups?.path;
      if (path === void 0) {
        throw new Error(`Did not expect to fail to match ${RE_IN_MEMORY_RUN_DEFINITION_PATH.source} against ${value} at this point`);
      }
      return { type: "in-memory-mint-dir" /* InMemoryMintDir */, runDefinitionPath: path };
    } else {
      const expression = this.parseExactExpression(node);
      return { type: "task-artifact" /* TaskArtifact */, expression };
    }
  };
  parseEmbeddedRunInit = (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const stringValue = this.parseString(node);
      if (stringValue !== "inherit") {
        this.error([`Expected an object with string properties, or the value "inherit"`], node);
        return {};
      }
      return stringValue;
    }
    return this.parseInit(node, warningCollector, start);
  };
  parseAgent = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        disk: this.parseAgentDisk,
        memory: this.parseStringTemplate,
        // this one is string, not stringable, because we expect [0-9]+gb
        cpus: this.parseStringableTemplate,
        // this one is stringable, not string, because we support a number
        "static-ips": this.parseStringTemplate,
        tmpfs: this.parseBoolean,
        spot: this.parseBoolean,
        ipv6: this.parseStringableTemplate
      },
      warningCollector
    );
    return {
      memory: fields.memory,
      cpus: fields.cpus,
      disk: fields.disk ?? {},
      staticIps: fields["static-ips"],
      tmpfs: fields.tmpfs,
      placement: fields.spot ? "spot" : "standard",
      ipv6: fields.ipv6
    };
  };
  parseAgentDisk = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return { size: await this.parseStringTemplate(node) };
    }
    const { fields } = await this.parseObject(
      node,
      {
        size: this.parseStringTemplate
      },
      warningCollector
    );
    return { size: fields.size };
  };
  parseUse = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      return this.parseUseTask(node, warningCollector, start);
    } else if (YAML.isSeq(node)) {
      return this.parseUseTaskList(node, warningCollector, start);
    }
    this.error([`Expected a task key or a list of task keys`], node);
    return { type: "standard" /* Standard */, keys: [] };
  };
  parseUseTask = async (node, warningCollector, start) => {
    const key = await this.parseKey(node, warningCollector, start);
    return { type: "standard" /* Standard */, keys: [key] };
  };
  parseUseTaskList = async (node, warningCollector) => {
    const keys = await this.parseList(node, this.parseKey, warningCollector);
    return { type: "standard" /* Standard */, keys };
  };
  parseAfter = async (node, warningCollector, start) => {
    if (YAML.isScalar(node) && node.toString().trim().startsWith("${{")) {
      return this.parseAfterExpression(node, warningCollector, start);
    } else if (YAML.isScalar(node)) {
      return this.parseAfterTask(node, warningCollector, start);
    } else if (YAML.isSeq(node)) {
      return this.parseAfterTaskList(node, warningCollector, start);
    }
    this.error([`Expected a task key, a list of task keys, or an expression`], node);
    return { type: 2 /* Template */, template: "true" };
  };
  parseAfterTask = async (node, warningCollector, start) => {
    const task = await this.parseKey(node, warningCollector, start);
    return { type: 0 /* Task */, task };
  };
  parseAfterTaskList = async (node, warningCollector) => {
    const tasks = await this.parseList(node, this.parseKey, warningCollector);
    return { type: 1 /* TaskList */, tasks };
  };
  parseAfterExpression = (node) => {
    const template = this.parseExactExpression(node);
    return { type: 2 /* Template */, template };
  };
  parseRetry = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return { count: await this.parseStringableTemplate(node) };
    }
    if (YAML.isMap(node)) {
      const { fields } = await this.parseObject(
        node,
        {
          count: this.parseStringableTemplate,
          if: this.parseExactExpression,
          action: this.parseStringableTemplate
        },
        warningCollector
      );
      if (fields.count === void 0) {
        this.error([`${codeQuote("retry")} must specify the ${codeQuote("count")} field`], node);
        return { count: "0" };
      }
      return {
        count: fields.count,
        if: fields.if,
        action: fields.action
      };
    }
    this.error([`Expected a number, expression, or object with the ${codeQuote("count")} and ${codeQuote("action")} fields.`], node);
    return { count: "0" };
  };
  parseCommandFilter = async (node, warningCollector, start) => {
    if (!YAML.isMap(node)) {
      const workspace2 = await this.parseWorkspaceFilter(node, warningCollector, start);
      return { workspace: workspace2, artifacts: void 0 };
    }
    const { workspace, ...artifacts } = await this.parseGenericRecord(node, this.parseWorkspaceFilter, warningCollector, {
      keyParser: (node2) => {
        const key = this.parseString(node2);
        if (key === "" || key === "workspace") return key;
        if (key.startsWith("${{") && key.endsWith("}}")) {
          const checkedTemplate = this.checkTemplate(node2, key);
          if (checkedTemplate === "") return key;
          return checkedTemplate;
        }
        this.error([`Must be either ${codeQuote("workspace")} or an expression referencing an artifact.`], node2);
        return key;
      }
    });
    return { workspace, artifacts };
  };
  parseWorkspaceFilter = (node, warningCollector) => {
    if (YAML.isScalar(node) && node.toString().trim().startsWith("${{")) {
      return this.parseStringTemplate(node);
    }
    return this.parseList(node, this.parseFilterEntry, warningCollector);
  };
  parseFilterEntry = async (node, warningCollector) => {
    if (YAML.isMap(node)) {
      const { fields } = await this.parseObject(
        node,
        {
          path: this.parseStringTemplate,
          "cache-key": this.parseString
        },
        warningCollector
      );
      let cacheKey = fields["cache-key"];
      if (!cacheKey) {
        cacheKey = "included";
      }
      if (cacheKey !== "included" && cacheKey !== "excluded") {
        this.error(["`cacheKey` must either be `included` or `excluded`"], node);
        return "";
      }
      if (!fields.path) {
        this.error(["Expected an object with the fields `path` and `cacheKey`."], node);
        return "";
      }
      if (fields.path.startsWith("/") || fields.path.startsWith("!/")) {
        this.error(["Starting a filter entry path with `/` is forbidden. All filter entries are relative to the workspace."], node);
      }
      return { path: fields.path, cacheKey };
    }
    const filterEntry = await this.parseStringTemplate(node);
    if (filterEntry.startsWith("/") || filterEntry.startsWith("!/")) {
      this.warning({
        warningCollector,
        node,
        message: "Starting a filter entry with `/` is deprecated. All filter entries are relative to the workspace."
      });
    }
    return filterEntry;
  };
  parseCache = ({ command }) => async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      if (typeof node.value === "boolean") {
        return { enabled: node.value, ttl: void 0 };
      }
      return { enabled: this.parseExactExpression(node), ttl: void 0 };
    } else if (YAML.isMap(node)) {
      const configuration = await this.parseObject(
        node,
        {
          enabled: (node2) => {
            if (!YAML.isScalar(node2)) {
              this.error([`Expected a boolean or an expression`], node2);
              return true;
            }
            if (typeof node2.value === "boolean") {
              return node2.value;
            }
            return this.parseExactExpression(node2);
          },
          ttl: this.parseStringableTemplate
        },
        warningCollector
      );
      if (configuration.fields.enabled === void 0) {
        if (configuration.fields.ttl === void 0) {
          this.error([`The ${codeQuote("enabled")} field is required.`], node);
        }
        configuration.fields.enabled = true;
      }
      if (!command && configuration.fields.ttl !== void 0) {
        this.error([`The ${codeQuote("ttl")} field is only configurable for commands.`], node);
        configuration.fields.ttl = void 0;
      }
      return { enabled: configuration.fields.enabled, ttl: configuration.fields.ttl };
    }
    if (command) {
      this.error([`Expected a boolean, an expression, or an object with ${codeQuote("enabled")} and ${codeQuote("ttl")} keys`], node);
    } else {
      this.error([`Expected a boolean, an expression, or an object with an ${codeQuote("enabled")} key`], node);
    }
    return { enabled: true, ttl: void 0 };
  };
  parseCommand = async (node, warningCollector) => {
    if (YAML.isSeq(node)) {
      const templateList = await this.parseList(node, this.parseStringableTemplate, warningCollector);
      return templateList.join("\n");
    }
    const template = await this.parseStringableTemplate(node);
    if (template.trim() === "") {
      this.error([`The ${codeQuote("run")} field must contain the command to run and must not be empty`], node);
    }
    return template;
  };
  parseDocker = (node) => {
    if (!YAML.isScalar(node)) {
      this.error([`Expected a boolean, 'preserve-data', or an expression`], node);
      return true;
    }
    if (typeof node.value === "boolean" || node.value === "preserve-data") {
      return node.value;
    }
    if (node.toString().startsWith("${{")) {
      return this.parseExactExpression(node);
    }
    this.error([`Expected a boolean, 'preserve-data', or an expression`], node);
    return true;
  };
  parseBackgroundProcesses = async (node, warningCollector) => {
    const seenKeys = /* @__PURE__ */ new Set();
    const backgroundProcessesParser = this.parseBackgroundProcess(seenKeys);
    return this.parseList(node, backgroundProcessesParser, warningCollector);
  };
  parseBackgroundProcessAfter = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return [key];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseKey, warningCollector);
    }
    this.error(["Expected a background process key, or a list of background process keys"], node);
    return [];
  };
  parseBackgroundProcess = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        run: this.parseCommand,
        "ready-check": this.parseReadyCheck,
        after: this.parseBackgroundProcessAfter,
        "terminate-grace-period-seconds": (node2) => this.parseNumber(node2, { minimum: 0 })
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A background process must have a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate background process ${codeQuote(fields.key)}`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.run === void 0) {
      this.error([`A background process must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    return {
      key: fields.key,
      run: fields.run,
      readyCheck: fields["ready-check"],
      terminateGracePeriodSeconds: fields["terminate-grace-period-seconds"],
      after: fields.after
    };
  };
  parseReadyCheck = async (node, ...args) => {
    if (YAML.isMap(node)) {
      return this.parseReadyCheckObject(node, ...args);
    } else if (YAML.isScalar(node) || YAML.isSeq(node)) {
      const run = await this.parseCommand(node, ...args);
      return { run };
    }
    this.error([`Expected a command to run, or an object with ${codeQuote("run")} and ${codeQuote("timeout-seconds")} keys`], node);
    return { run: "" };
  };
  parseReadyCheckObject = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        run: this.parseCommand,
        "timeout-seconds": (node2) => this.parseNumber(node2, { minimum: 1 })
      },
      warningCollector
    );
    if (fields.run === void 0) {
      this.error([`A ready check must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    return {
      run: fields.run,
      timeoutSeconds: fields["timeout-seconds"]
    };
  };
  parseOutputs = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        "execution-status": this.parseOutputExecutionStatus,
        "test-results": this.parseOutputTestResults,
        values: this.parseOutputValues,
        problems: this.parseOutputProblems,
        artifacts: this.parseOutputArtifacts,
        filesystem: this.parseOutputFilesystem
      },
      warningCollector
    );
    return {
      successExitCodes: fields["execution-status"],
      testResultsPaths: fields["test-results"],
      values: fields.values,
      problemMatchers: fields.problems?.problemMatchers,
      problemPaths: fields.problems?.problemPaths,
      artifactPaths: fields.artifacts,
      filesystem: fields.filesystem
    };
  };
  parseOutputExecutionStatus = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        "success-exit-codes": (node2) => this.parseList(node2, (n) => this.parseNumber(n), warningCollector)
      },
      warningCollector
    );
    return fields["success-exit-codes"];
  };
  parseOutputTestResults = (node, warningCollector) => {
    return this.parseList(node, this.parseOutputTestResult, warningCollector);
  };
  parseOutputTestResult = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        path: this.parseString,
        options: this.parseOutputTestResultOptions
      },
      warningCollector
    );
    if (fields.path === void 0) {
      this.error([`A test result output must include a ${codeQuote("path")} key indicating the test result file`], node);
      fields.path = "";
    }
    return {
      path: fields.path,
      options: fields.options
    };
  };
  parseOutputTestResultOptions = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        framework: this.parseString,
        language: this.parseString
      },
      warningCollector
    );
    if (fields.framework === void 0) {
      this.error([`Options configured for a test result output must include ${codeQuote("framework")}`], node);
      fields.framework = "";
    }
    if (fields.language === void 0) {
      this.error([`Options configured for a test result output must include ${codeQuote("language")}`], node);
      fields.language = "";
    }
    return {
      framework: fields.framework,
      language: fields.language
    };
  };
  parseOutputValues = async (node, warningCollector) => {
    return this.parseList(node, this.parseString, warningCollector);
  };
  parseOutputProblems = async (node, warningCollector) => {
    const problemOutputs = await this.parseList(node, this.parseProblemMatcherOrProblemPath, warningCollector);
    const problemMatchers = [];
    const problemPaths = [];
    for (const problemOutput of problemOutputs) {
      if (Array.isArray(problemOutput)) {
        problemMatchers.push(...problemOutput);
      } else {
        problemPaths.push(problemOutput);
      }
    }
    return { problemMatchers, problemPaths };
  };
  parseProblemMatcherOrProblemPath = async (node, warningCollector, start) => {
    const errorMessage = `Expected a problem matcher with a ${codeQuote("matcher")} key, a problems path with a ${codeQuote("path")} key`;
    if (!YAML.isMap(node)) {
      this.error([errorMessage], node);
      return [];
    }
    const matcherField = node.items.find((field) => field.key.toString() === "matcher");
    const pathField = node.items.find((field) => field.key.toString() === "path");
    if (matcherField) {
      return this.parseProblemMatcher(node, warningCollector, start);
    }
    if (pathField) {
      return this.parseProblemPath(node, warningCollector, start);
    }
    this.error([errorMessage], node);
    return [];
  };
  parseProblemMatcher = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        matcher: this.parseString
      },
      warningCollector
    );
    const { matcher } = fields;
    if (matcher === void 0) {
      this.error([`A problem matcher must include a ${codeQuote("matcher")} key indicating the name or URL of the matcher`], node);
      return [];
    }
    const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "matcher"))[1];
    let nonValidatedMatcherConfig;
    if (isBuiltinProblemMatcher(matcher)) {
      nonValidatedMatcherConfig = BUILT_IN_PROBLEM_MATCHERS[matcher];
    } else if (URL.canParse(matcher)) {
      try {
        nonValidatedMatcherConfig = await fetch(matcher).then((res) => res.json());
      } catch (_) {
        this.warning({ warningCollector, message: `Failed to load problem matcher config from the URL ${matcher}`, node: keyNode });
        return [];
      }
    } else {
      this.warning({ warningCollector, message: `Invalid problem matcher URL ${matcher}`, node: keyNode });
      return [];
    }
    if (!value_exports2.Check(TNonValidatedMatcherConfig, nonValidatedMatcherConfig)) {
      const errorMessage = formatTypeErrors(TNonValidatedMatcherConfig, nonValidatedMatcherConfig, "parsing problem matcher");
      this.warning({ warningCollector, message: errorMessage, node: keyNode });
      return [];
    }
    const validated = validateMatcherConfig(nonValidatedMatcherConfig);
    if (!validated.valid) {
      this.warning({
        warningCollector,
        message: [`Invalid problem matcher config:`, ...validated.errors.map((s) => s.message)].join("\n"),
        node: keyNode
      });
      return [];
    }
    return validated.value.problemMatcher;
  };
  parseProblemPath = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        path: this.parseString,
        format: (node2) => this.parseTypeBox(
          node2,
          Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
        )
      },
      warningCollector
    );
    if (fields.path === void 0) {
      this.error([`A problem path must include a ${codeQuote("path")} key with the filename the problems are in`], node);
      fields.path = "";
    }
    return {
      path: fields.path,
      format: fields.format ?? "auto"
    };
  };
  parseOutputArtifacts = async (node, warningCollector) => {
    const seenKeys = /* @__PURE__ */ new Set();
    const parser = this.parseOutputArtifact(seenKeys);
    return await this.parseList(node, parser, warningCollector);
  };
  parseOutputFilesystem = async (node, warningCollector) => {
    if (YAML.isScalar(node) && node.value === false) {
      return {
        deduplicate: "false",
        filter: {
          workspace: [],
          system: []
        }
      };
    }
    const { fields } = await this.parseObject(
      node,
      {
        deduplicate: this.parseStringableTemplate,
        filter: this.parseOutputFilesystemFilter
      },
      warningCollector
    );
    return {
      deduplicate: fields.deduplicate,
      filter: fields.filter
    };
  };
  parseOutputFilesystemFilter = async (node, warningCollector) => {
    if (YAML.isSeq(node)) {
      return {
        workspace: await this.parseList(node, this.parseOutputFilesystemWorkspaceFilterEntry, warningCollector)
      };
    }
    const { fields } = await this.parseObject(
      node,
      {
        workspace: (node2, warningCollector2) => this.parseList(node2, this.parseOutputFilesystemWorkspaceFilterEntry, warningCollector2),
        system: (node2, warningCollector2) => this.parseList(node2, this.parseOutputFilesystemSystemFilterEntry, warningCollector2)
      },
      warningCollector
    );
    return {
      workspace: fields.workspace,
      system: fields.system
    };
  };
  parseOutputFilesystemWorkspaceFilterEntry = (node) => {
    const filterEntry = this.parseString(node);
    if (filterEntry.startsWith("/") || filterEntry.startsWith("!/")) {
      const filterEntryWithoutLeadingSlash = filterEntry.startsWith("/") ? filterEntry.slice(1) : filterEntry.slice(2);
      this.error(
        [
          "Filter entries for the workspace cannot start with `/`. All workspace filter entries are relative to the workspace. Try `" + filterEntryWithoutLeadingSlash + "` instead."
        ],
        node
      );
    }
    return filterEntry;
  };
  parseOutputFilesystemSystemFilterEntry = (node) => {
    const filterEntry = this.parseString(node);
    const startsWithSlashOrAsterisk = /!?[/|*]/.test(filterEntry);
    if (!startsWithSlashOrAsterisk) {
      const filterEntryWithLeadingSlash = filterEntry.startsWith("!") ? "!/" + filterEntry.slice(1) : "/" + filterEntry;
      this.error(["Filter entries for the system must start with `/` or `*`. Try `" + filterEntryWithLeadingSlash + "` instead."], node);
    }
    return filterEntry;
  };
  parseOutputArtifact = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        key: this.parseOutputArtifactKey,
        path: this.parseStringTemplate
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`An artifact must include a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`The artifact ${codeQuote(fields.key)} is duplicate`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.path === void 0) {
      this.error([`An artifact must include a ${codeQuote("path")}`], node);
      fields.path = "";
    }
    return { key: fields.key, path: fields.path };
  };
  parseOutputArtifactKey = (node) => {
    const pattern = "^[^/]+$";
    const TKeyDsl = Type.Union([Type.String({ pattern }), Type.Boolean()], {
      errorMessage: `A valid key must be a string matching the pattern ${pattern}`
    });
    return String(this.parseTypeBox(node, TKeyDsl));
  };
  parseEnv = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseEnvDescriptor, warningCollector);
  };
  parseEnvDescriptor = async (node, warningCollector, start) => {
    const errorMessage = `Expected a value for this environment variable, or an object with a ${codeQuote("value")} key and optional ${codeQuote(
      "cache-key"
    )} key, or an object with a ${codeQuote("cache-key")} key`;
    if (YAML.isScalar(node)) {
      return this.parseEnvValue(node, warningCollector, start);
    }
    if (YAML.isMap(node)) {
      return this.parseEnvObject(node, warningCollector, start);
    }
    this.error([errorMessage], node);
    return { value: void 0, cacheKey: "included" /* Included */ };
  };
  parseEnvValue = async (node) => {
    const value = await this.parseStringableTemplate(node);
    return { value, cacheKey: "included" /* Included */ };
  };
  parseEnvObject = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        value: this.parseStringableTemplate,
        cache: this.parseBoolean,
        "cache-key": (node2) => this.parseTypeBox(node2, this.TEnvCacheKey)
      },
      warningCollector
    );
    if (fields.cache !== void 0) {
      if (!this.warnedAboutUsingCacheInsteadOfCacheKey) {
        const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "cache"))[1];
        this.warning({
          warningCollector,
          message: `The ${codeQuote("cache")} property in ${codeQuote("env")} is deprecated.`,
          advice: `Use ${codeQuote("cache-key")} instead.`,
          docs: `See ${"https://www.rwx.com/docs/mint/environment-variables#affecting-the-cache-key" /* EnvironmentVariablesCacheKey */} to learn about configuring the cache key for environment variables`,
          node: keyNode
        });
      }
      if (fields["cache-key"] !== void 0) {
        const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "cache"))[1];
        this.error([`Cannot specify both ${codeQuote("cache")} and ${codeQuote("cache-key")}`], keyNode);
      }
      if (fields.value === void 0) {
        this.error([`An environment variable must have a ${codeQuote("value")}`], node);
      }
      const cacheKey2 = fields.cache ? "included" /* Included */ : "excluded" /* Excluded */;
      return { value: fields.value, cacheKey: cacheKey2 };
    }
    if (fields.value === void 0 && fields["cache-key"] === void 0) {
      this.error([`Must provide the property ${codeQuote("value")}, ${codeQuote("cache-key")}, or both.`], node);
    }
    fields["cache-key"] = fields["cache-key"] ?? "included";
    const cacheKey = this.mapEnvironmentVariableCacheKey(fields["cache-key"]);
    return { value: fields.value, cacheKey };
  };
  TEnvCacheKey = Type.Union([Type.Literal("included"), Type.Literal("excluded")]);
  mapEnvironmentVariableCacheKey(cacheKey) {
    switch (cacheKey) {
      case "included":
        return "included" /* Included */;
      case "excluded":
        return "excluded" /* Excluded */;
    }
  }
  parseEnvConfig = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        inherit: this.parseEnvInherit,
        merge: this.parseEnvMerge
      },
      warningCollector
    );
    return {
      inherit: fields.inherit,
      merge: fields.merge
    };
  };
  parseEnvInherit = async (node, warningCollector) => {
    if (YAML.isScalar(node) && node.value === "all-used-tasks") {
      return "all-used-tasks";
    } else if (YAML.isSeq(node)) {
      const tasks = await this.parseList(node, this.parseKey, warningCollector);
      return tasks;
    }
    this.error([`Expected the string ${codeQuote("all-used-tasks")} or a list of task keys to inherit from`], node);
    return [];
  };
  parseEnvMerge = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseEnvMergeStrategy, warningCollector);
  };
  parseEnvMergeStrategy = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        strategy: (node2) => this.parseTypeBox(node2, Union([Literal("join"), Literal("override")])),
        by: this.parseString
      },
      warningCollector
    );
    const { strategy, by } = fields;
    if (strategy === void 0) {
      this.error([`An merge configuration must include a ${codeQuote("strategy")} key with value ${codeQuote("join")} or ${codeQuote("override")}`], node);
      return { strategy: "override" };
    }
    const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "strategy"))[1];
    switch (strategy) {
      case "join": {
        if (by === void 0) {
          this.error(
            [`The ${codeQuote("join")} strategy requires a ${codeQuote("by")} key with the string to join environment variable values by`],
            keyNode
          );
        }
        return { strategy, by: by ?? "" };
      }
      case "override": {
        if (by !== void 0) {
          this.error([`The ${codeQuote("override")} strategy cannot include any additional properties`], keyNode);
        }
        return { strategy };
      }
    }
  };
  parseParallel = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const parallelism = await this.parseParallelismTotal(node, warningCollector, start);
      return { key: null, tasksLimit: null, parallelism, autoCancel: TEMPLATE_FALSE };
    }
    if (YAML.isMap(node)) {
      return this.parseParallelObject(node, warningCollector, start);
    }
    this.error(
      ["Expected a positive number, an expression, an object specifying the total, an object specifying the matrix, or an object specifying the values."],
      node
    );
    return {
      key: null,
      tasksLimit: null,
      parallelism: { type: "total" /* Total */, total: "1" },
      autoCancel: TEMPLATE_FALSE
    };
  };
  parseParallelismTotal = (node) => {
    let total;
    if (YAML.isScalar(node) && typeof node.value === "number") {
      const number = this.parseNumber(node, { minimum: 1 });
      total = String(number);
    } else if (node.toString().startsWith("${{")) {
      total = this.parseExactExpression(node);
    } else {
      this.error([`Expected a positive number or an expression`], node);
      total = "";
    }
    return { type: "total" /* Total */, total };
  };
  parseParallelObject = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseStringTemplate,
        "tasks-limit": this.parseParallelismTasksLimit,
        "auto-cancel": this.parseStringableTemplate,
        total: this.parseParallelismTotal,
        matrix: this.parseParallelismMatrix,
        values: this.parseParallelismValues
      },
      warningCollector
    );
    const parallelConfigurationsProvided = [];
    if (fields.total) {
      parallelConfigurationsProvided.push("total");
    }
    if (fields.matrix) {
      parallelConfigurationsProvided.push("matrix");
    }
    if (fields.values) {
      parallelConfigurationsProvided.push("values");
    }
    if (parallelConfigurationsProvided.length > 1) {
      const list = parallelConfigurationsProvided.map(codeQuote).join(", ");
      this.error([`The properties ${list} are mutually exclusive. Please provide only one.`], node);
    }
    let parallelism = fields.total ?? fields.matrix ?? fields.values;
    if (parallelism === void 0) {
      this.error([`One of the properties ${codeQuote("total")}, ${codeQuote("matrix")}, or ${codeQuote("values")} must be provided`], node);
      parallelism = { type: "total" /* Total */, total: "1" };
    }
    return {
      key: fields.key ?? null,
      tasksLimit: fields["tasks-limit"] ?? null,
      parallelism,
      autoCancel: fields["auto-cancel"] ?? TEMPLATE_FALSE
    };
  };
  parseParallelismMatrix = async (node, warningCollector) => {
    const matrix = await this.parseGenericRecord(node, this.parseMatrixValue, warningCollector);
    return { type: "matrix" /* Matrix */, matrix };
  };
  parseMatrixValue = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return this.parseStringableTemplate(node);
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseStringableTemplate, warningCollector);
    }
    this.error([`Expected a template string, or a list of template strings`], node);
    return [];
  };
  parseParallelismValues = async (node, warningCollector) => {
    let values;
    if (node.toString().startsWith("${{")) {
      values = this.parseExactExpression(node);
    } else if (YAML.isSeq(node)) {
      values = await this.parseList(node, this.parseParallelismValueObject, warningCollector, { minimumItems: 1 });
      let expectedKeys;
      for (const value of values) {
        const currentKeys = new Set(Object.keys(value));
        if (expectedKeys === void 0) {
          expectedKeys = currentKeys;
        }
        if (!setEqual(expectedKeys, currentKeys)) {
          this.error([`All parallel values must have the same keys`], node);
          break;
        }
        if (currentKeys.size === 0) {
          this.error([`${codeQuote("values")} cannot include an empty object`], node);
          break;
        }
      }
    } else {
      this.error([`Expected an expression or a list of objects`], node);
      values = "";
    }
    return { type: "values" /* Values */, values };
  };
  parseParallelismTasksLimit = (node) => {
    return this.parseNumber(node, { minimum: 1, maximum: MAXIMUM_PARALLEL_TASKS_LIMIT });
  };
  parseParallelismValueObject = (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseStringableTemplate, warningCollector);
  };
  parseKey = (node) => {
    const TKeyDsl = Type.Union([Type.String({ pattern: KEY_PATTERN }), Type.Boolean()], {
      errorMessage: `A valid key must be a string matching the pattern ${KEY_PATTERN}`
    });
    return String(this.parseTypeBox(node, TKeyDsl));
  };
  parseInit = (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseStringableTemplate, warningCollector);
  };
  parseLeafSpecParameters = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseLeafSpecParameter, warningCollector);
  };
  parseLeafSpecParameter = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        description: this.parseString,
        required: this.parseBoolean,
        default: this.parseStringableNoExpression
      },
      warningCollector
    );
    if (fields.description === void 0) {
      this.error([`A description for this package is required`], node);
      fields.description = "";
    }
    return {
      description: fields.description,
      default: fields.default,
      required: fields.required
    };
  };
  parseLeafSpecOutputs = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        values: this.parseLeafSpecOutputValues,
        "values-from": (valuesFrom) => this.parseList(valuesFrom, this.parseString, warningCollector)
      },
      warningCollector
    );
    return {
      values: fields.values,
      valuesFrom: fields["values-from"]
    };
  };
  parseLeafSpecOutputValues = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseLeafSpecOutputValue, warningCollector);
  };
  parseLeafSpecOutputValue = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        description: this.parseString,
        value: this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.value === void 0) {
      this.error([`A value for this package output is required`], node);
      fields.value = "";
    }
    return {
      description: fields.description,
      value: fields.value
    };
  };
  parseObject = async (map3, parsers, warningCollector, hiddenKeys) => {
    let parserKeys = Object.keys(parsers);
    if (hiddenKeys) {
      parserKeys = parserKeys.filter((key) => !hiddenKeys.has(key));
    }
    const expectedKeys = parserKeys.sort().map(codeQuote).join(", ");
    if (YAML.isScalar(map3) && map3.value === null) {
      return { fields: {}, keyNodes: {} };
    }
    if (!YAML.isMap(map3)) {
      this.error([`Expected an object with properties ${expectedKeys}`], map3);
      return { fields: {}, keyNodes: {} };
    }
    let fields = {};
    let keyNodes = {};
    for (const { key: maybeAliasedKey, value } of map3.items) {
      const [key] = this.synchronousDealias(maybeAliasedKey);
      if (value === null) {
        this.error([`Unexpected "null" value`], key);
        continue;
      } else {
        await this.dealias(value, async (value2) => {
          if (YAML.isScalar(key) && key.value === "<<") {
            if (YAML.isSeq(value2)) {
              for (const item of value2.items) {
                const anchorKeyResults = await this.dealias(item, (item2) => this.parseObject(item2, parsers, warningCollector));
                fields = { ...fields, ...anchorKeyResults.fields };
                keyNodes = { ...keyNodes, ...anchorKeyResults.keyNodes };
              }
            } else {
              const anchoredObjectResults = await this.parseObject(value2, parsers, warningCollector);
              fields = { ...fields, ...anchoredObjectResults.fields };
              keyNodes = { ...keyNodes, ...anchoredObjectResults.keyNodes };
            }
          } else {
            if (!YAML.isScalar(key) || typeof key.value !== "string") {
              this.error([`Unexpected property ${codeQuote(key.toString())}`, `Expected one of the following keys: ${expectedKeys}`], key);
              return void 0;
            }
            const keyName = key.value;
            const parser = parsers[keyName];
            if (parser === void 0) {
              const errorMessageLines = [`Unexpected property ${codeQuote(key.toString())}`, `Expected one of the following keys: ${expectedKeys}`];
              const bestMatch = didYouMean(key.toString(), parserKeys);
              if (bestMatch) {
                errorMessageLines.push(`Did you mean ${codeQuote(bestMatch)}?`);
              }
              (0, import_node_assert6.default)(isNonEmptyArray(errorMessageLines));
              this.error(errorMessageLines, key);
              return void 0;
            }
            const parsed = await parser(value2, warningCollector, key.range[1]);
            fields[keyName] = parsed;
            keyNodes[keyName] = key;
          }
        });
      }
    }
    return { fields, keyNodes };
  };
  parseGenericRecord = async (node, valueParser, warningCollector, { minimumKeys = 0, keyParser = this.parseString } = {}) => {
    if (!YAML.isMap(node)) {
      this.error([`Expected an object with string properties`], node);
      return {};
    }
    if (node.items.length < minimumKeys) {
      this.error([`Expected at least ${minimumKeys} ${minimumKeys === 1 ? "key" : "keys"}`], node);
    }
    let result = {};
    for (const { key: maybeAliasedKey, value } of node.items) {
      const [key] = this.synchronousDealias(maybeAliasedKey);
      const keyName = keyParser(key);
      if (value === null) {
        this.error([`Unexpected "null" value`], key);
        continue;
      }
      await this.dealias(value, async (value2) => {
        if (YAML.isScalar(key) && key.value === "<<") {
          if (YAML.isSeq(value2)) {
            for (const item of value2.items) {
              const anchorKeyValue = await this.dealias(item, (item2) => this.parseGenericRecord(item2, valueParser, warningCollector, { minimumKeys }));
              result = { ...result, ...anchorKeyValue };
            }
          } else {
            const anchorKeyValue = await this.parseGenericRecord(value2, valueParser, warningCollector, { minimumKeys });
            result = { ...result, ...anchorKeyValue };
          }
        } else {
          const keyValue = await valueParser(value2, warningCollector, key.range[1]);
          result[keyName] = keyValue;
        }
      });
    }
    return result;
  };
  parseListOrValue = (node, parser, warningCollector, start) => {
    if (YAML.isSeq(node)) {
      return this.parseList(node, parser, warningCollector);
    }
    return parser(node, warningCollector, start);
  };
  parseList = async (seq, parser, warningCollector, { listStart = seq.range[0], minimumItems = 0, seenSnippets } = {}) => {
    if (!YAML.isSeq(seq)) {
      this.error([`Expected a list`], seq);
      return [];
    }
    if (seq.items.length < minimumItems) {
      this.error([`Expected at least ${minimumItems} ${minimumItems === 1 ? "item" : "items"}`], seq);
      return [];
    }
    const result = [];
    let previousEnd = listStart;
    const previousFileName = this.currentFileName;
    for (let item of seq.items) {
      const itemEnd = item.range[1];
      const snippetsSeenInThisCycle = seenSnippets || /* @__PURE__ */ new Set();
      const { node, snippetFileName, success } = await this.dealias(item, (item2) => this.parseSnippetInclude(item2));
      if (!success) {
        continue;
      }
      if (snippetFileName) {
        if (snippetsSeenInThisCycle.has(snippetFileName)) {
          if (snippetFileName === this.currentFileName) {
            this.error(["A snippet cannot include itself"], item, snippetFileName);
          } else {
            this.error([`Snippet include cycle detected: ${snippetFileName} -> ${this.currentFileName} -> ${snippetFileName}`], item, snippetFileName);
          }
          continue;
        }
        snippetsSeenInThisCycle.add(snippetFileName);
        const { line, column } = this.locationOfIndex(item.range[0], previousFileName);
        this.stack.push({ fileName: previousFileName, line, column, name: "include" });
        item = node;
        this.currentFileName = snippetFileName;
        previousEnd = item.range[0];
      }
      await this.dealias(item, async (item2) => {
        if (YAML.isSeq(item2)) {
          const nestedResults = await this.parseList(item2, parser, warningCollector, { seenSnippets: snippetsSeenInThisCycle });
          result.push(...nestedResults);
        } else {
          result.push(await parser(item2, warningCollector, previousEnd));
        }
        previousEnd = itemEnd;
        if (snippetFileName) {
          this.currentFileName = previousFileName;
          this.stack.pop();
        }
      });
    }
    return result;
  };
  parseSnippetInclude = (node) => {
    if (!YAML.isMap(node)) {
      return { node, success: true };
    }
    const includePair = node.items.find((pair) => YAML.isScalar(pair.key) && pair.key.value === "include");
    if (!includePair) {
      return { node, success: true };
    }
    if (!YAML.isScalar(includePair.value) || typeof includePair.value.value !== "string") {
      this.error(["The value of `include` must be the filename of the snippet you want to include."], node);
      return { node, success: false };
    }
    const snippetName = includePair.value.value;
    if (!snippetName.startsWith("_")) {
      this.error(["The filename of a snippet must start with `_`"], node);
      return { node, success: false };
    }
    const snippet = this.snippets.get(snippetName);
    if (snippet) {
      return { node: snippet.yamlNode, snippetFileName: snippet.filePath, success: true };
    } else {
      const availableSnippets = [...this.snippets.keys()];
      const availableSnippetsText = availableSnippets.length > 0 ? `Available snippets: ${availableSnippets.join(", ")}` : "No snippets are available.";
      this.error([`Snippet file not found: ${snippetName}. ${availableSnippetsText}`], node);
      return { node, success: false };
    }
  };
  parseString = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "string") {
      this.error([`Expected a string`], node);
      return "";
    }
    return node.value;
  };
  parseBoolean = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "boolean") {
      this.error([`Expected a boolean`], node);
      return false;
    }
    return node.value;
  };
  parseStartBehavior = (node) => {
    const value = this.parseString(node);
    if (value === "manually") {
      return "manually" /* Manually */;
    } else if (value === "automatically") {
      return "automatically" /* Automatically */;
    } else {
      this.error([`Expected ${codeQuote("manually")} or ${codeQuote("automatically")}, but got ${codeQuote(value)}`], node);
      return "automatically" /* Automatically */;
    }
  };
  parseNumber = (node, { minimum, maximum } = {}) => {
    if (!YAML.isScalar(node) || typeof node.value !== "number") {
      this.error([`Expected a number`], node);
      return -1;
    }
    const num = node.value;
    if (minimum !== void 0 && num < minimum) {
      this.error([`Expected a minimum of ${codeQuote(String(minimum))}`], node);
    }
    if (maximum !== void 0 && num > maximum) {
      this.error([`Expected a maximum of ${codeQuote(String(maximum))}`], node);
    }
    return num;
  };
  parseStringable = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "boolean" && typeof node.value !== "string" && typeof node.value !== "number") {
      this.error([`Expected a string, number, or boolean read as a string.`], node);
      return "fake";
    }
    return String(node.value);
  };
  parseStringTemplate = async (node) => {
    const templateString = this.parseString(node);
    return Promise.resolve(this.checkTemplate(node, templateString));
  };
  parseStringableTemplate = async (node) => {
    const templateString = this.parseStringable(node);
    return Promise.resolve(this.checkTemplate(node, templateString));
  };
  parseStringableNoExpression = async (node) => {
    const templateString = this.parseStringable(node);
    return Promise.resolve(this.checkNoExpression(node, templateString));
  };
  parseExactExpression = (node) => {
    const TExactExpression = TBrandedString({
      pattern: "^\\$\\{\\{.*\\}\\}$",
      errorMessage: `Expected an expression like ${codeQuote("${{ run.id }}")}.`
    });
    const template = this.parseTypeBox(node, TExactExpression);
    return this.checkTemplate(node, template);
  };
  checkTemplate = (node, value) => {
    try {
      parseTemplate(value);
      return value;
    } catch (e) {
      if (e instanceof ParsingError) {
        this.error([e.messageWithAdvice], node);
        return "";
      }
      throw e;
    }
  };
  checkNoExpression = (node, value) => {
    let isTemplate;
    try {
      const { expressions } = parseTemplate(value);
      isTemplate = expressions.length > 0;
    } catch (_e) {
      isTemplate = false;
    }
    if (isTemplate) {
      this.error(["This value includes expressions, but expressions are not allowed in this context"], node);
    }
    return value;
  };
  parseTypeBox = (node, schema) => {
    const value = node.toJSON();
    if (!value_exports2.Check(schema, value)) {
      if (typeof schema.errorMessage === "string") {
        this.error([schema.errorMessage], node);
      } else {
        const errorMessage = formatTypeErrors(schema, value, "parsing value");
        this.error([errorMessage], node);
      }
    }
    return value;
  };
  locationOfIndex(index, fileName) {
    const location = verifyExists(this.linesMap[fileName]).locationForIndex(index);
    if (location === null) return { line: 0, column: 0 };
    const { line, column } = location;
    return { line: line + 1, column: column + 1 };
  }
  locationRangeOfNode(node, fileName) {
    if (!fileName) {
      fileName = this.currentFileName;
    }
    const start = this.locationOfIndex(node.range[0], fileName);
    const end = this.locationOfIndex(node.range[1], fileName);
    return { line: start.line, column: start.column, endLine: end.line, endColumn: end.column };
  }
  error(messageLines, node, fileName) {
    if (!fileName) {
      fileName = this.currentFileName;
    }
    const { line, column, endLine, endColumn } = this.locationRangeOfNode(node, fileName);
    this.messages.push({
      message: messageLines.join("\n"),
      severity: "error",
      stackTrace: [...this.stack, { fileName, line, column, endLine, endColumn }]
    });
  }
  warning({
    warningCollector,
    message,
    node,
    advice,
    docs
  }) {
    const { line, column, endLine, endColumn } = this.locationRangeOfNode(node, this.currentFileName);
    const stackEntry = { fileName: this.currentFileName, line, column, endLine, endColumn };
    warningCollector.push(
      buildMessage({
        type: "warning" /* Warning */,
        message: [message],
        advice: advice ? [advice] : [],
        docs: docs ?? null,
        stackTrace: [...this.stack, stackEntry],
        frame: this.generateCodeFrame(stackEntry)
      })
    );
  }
  generateCodeFrame({ line, column, fileName, endLine, endColumn }) {
    const frameLines = verifyExists(this.sourceMap[fileName]).split("\n");
    const lineNumbers = [line - 2, line - 1, line, line + 1, line + 2].filter((l) => !!frameLines[l - 1]);
    const maxLineNumberLength = Math.max(...lineNumbers.map((l) => l.toString().length));
    return lineNumbers.map((lineNumber) => {
      const lineString = `${lineNumber.toString().padStart(maxLineNumberLength, " ")} | ${frameLines[lineNumber - 1]}`;
      if (lineNumber === line) {
        let caretCount = 1;
        if (endLine !== void 0 && endColumn !== void 0 && endLine === line && endColumn > column) {
          caretCount = endColumn - column;
        }
        const carets = "^".repeat(caretCount);
        return `> ${lineString}
  ${"".padStart(maxLineNumberLength, " ")} | ${"".padStart(column - 1, " ")}${carets}`;
      } else {
        return `  ${lineString}`;
      }
    }).join("\n");
  }
  formatMessages() {
    const errors = [];
    for (const message of this.messages) {
      const formatted = this.formatMessage(message);
      switch (message.severity) {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        case "error": {
          errors.push(formatted);
          break;
        }
      }
    }
    return { errors };
  }
  formatMessage(parserMessage) {
    const lastStackEntry = verifyExists(parserMessage.stackTrace.findLast((e) => e));
    return {
      type: "parse-error" /* ParseError */,
      message: parserMessage.message,
      stackTrace: parserMessage.stackTrace,
      line: lastStackEntry.line,
      column: lastStackEntry.column,
      fileName: lastStackEntry.fileName,
      frame: this.generateCodeFrame(lastStackEntry)
    };
  }
};
function isYamlNull(node) {
  return YAML.isScalar(node) && node.value === null;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  YamlParser
});
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
