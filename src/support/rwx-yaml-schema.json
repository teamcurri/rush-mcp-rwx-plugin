{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://rwx.com/docs/rwx-ci-yaml-v1.json",
  "title": "RWX YAML Configuration Schema",
  "description": "YAML Schema for RWX CI/CD YAML configuration files. RWX is a distributed build system and CI/CD platform that orchestrates task execution across containerized environments with sophisticated caching, artifact management, and agent-based distributed execution.",
  "type": "object",
  "properties": {
    "tasks": {
      "type": "array",
      "minItems": 1,
      "description": "An array of task definitions that form the core execution units of your workflow. Each task represents a discrete unit of work that executes in an isolated containerized environment. Tasks can execute shell commands, call reusable packages, or embed other run definitions. Tasks support sophisticated dependency management through 'use' (inherits outputs and filesystem) and 'after' (ordering only), enabling complex workflows with parallel execution, content-based caching, and flexible artifact management.",
      "items": {
        "oneOf": [
          { "$ref": "#/$defs/CommandTask" },
          { "$ref": "#/$defs/PackageTask" },
          { "$ref": "#/$defs/EmbeddedRunTask" }
        ]
      }
    },
    "on": {
      "$ref": "#/$defs/Triggers",
      "description": "Trigger configuration that defines when and how this run should execute. RWX supports five trigger types: GitHub events (push, pull_request, merge_group), GitLab events (push, tag-push, merge-request), scheduled cron runs, manual CLI execution, and API dispatch triggers. Each trigger provides rich event context accessible via template expressions (e.g., ${{ event.git.branch }}, ${{ event.github.push.head_commit.message }}). Triggers can specify conditions (if), initialization parameters (init), target tasks (target), and custom run titles (title). Event data flows into tasks through initialization parameters, enabling dynamic workflow behavior based on trigger context."
    },
    "concurrency-pools": {
      "type": "array",
      "description": "Configuration for concurrency pools that limit the number of concurrent runs executing based on pool identifiers. Pools are global to your organization (not repository-scoped) and help manage resource contention. When capacity is exceeded, you can configure whether additional runs should queue, cancel waiting runs, or cancel currently running runs. Concurrency pools are commonly used for ordering deployments, cancelling feature branch workflows when a newer commit is pushed, and managing shared resource access. The best practice is to include the repository name in pool ID to avoid conflicts (e.g., 'my-org/my-repo:deployment').",
      "items": { "$ref": "#/$defs/ConcurrencyPool" }
    },
    "tool-cache": {
      "$ref": "#/$defs/ToolCache",
      "description": "Global tool cache configuration that enables incremental caching for tasks across runs. Tool caches preserve filesystem contents from previous task executions, allowing tasks like dependency installations to perform incremental updates instead of starting from scratch. When a task has a cache miss, the tool cache provides the filesystem state from the most recent execution. Tool caches are evicted after 48 hours and must be configured with a vault for security. Tool caches are useful for package managers (npm, yarn, bundle), Docker builds, compilation tasks, and other tasks that benefit from incremental updates."
    },
    "base": {
      "$ref": "#/$defs/BaseLayer",
      "description": "Base container layer configuration that defines the operating system, version, and RWX configuration tag for task execution. All tasks in the run use this base layer. The currently supported base layers are Ubuntu 22.04 (tag 1.1) and Ubuntu 24.04 (tag 1.2). The base layer determines available system packages, pre-installed Docker version, and tool cache compatibility. Different embedded runs can specify different base layers than their parent run."
    }
  },
  "required": ["tasks"],
  "unevaluatedProperties": false,

  "$defs": {
    "PrimitiveValue": {
      "oneOf": [
        { "type": "string" },
        { "type": "number" },
        { "type": "boolean" }
      ],
      "description": "A primitive value that can be a string, number, or boolean. All values are cast to strings by the RWX system."
    },
    "CommandTask": {
      "type": "object",
      "description": "A task that executes shell commands in a containerized environment. Command tasks are the most common task type and can run any shell command, script, or executable. They support sophisticated features like parallel execution, background processes, rich semantic outputs, and environment variable management.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "A unique identifier for the task used both for referencing the task and for display purposes. Must start with a letter, number, or underscore, followed by any combination of letters, numbers, underscores, or hyphens. Keys serve as display names in the UI and logs and must be unique within the run definition. Kebab-case and nouns are recommended (e.g. `frontend-build`, `gems`, `dependencies`, `unit-tests`. Avoid using verbs like `install-system-packages`, instead preferring just `system-packages`, since `use: [system-packages]` is more straightforward to read than `use: [install-system-packages]"
        },
        "run": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "The shell command(s) to execute in the task container. The run command can be a single command string, a multi-line string using YAML's pipe (|) operator, or an array of command strings executed sequentially. Commands run in a bash shell with full access to environment variables, pipes, and redirects, and they support template expressions like ${{ init.parameter }} for dynamic command generation. Multi-line strings preserve formatting and are ideal for complex scripts."
        },
        "use": {
          "$ref": "#/$defs/Dependencies",
          "description": "The dependencies of this task. Used tasks provide both execution ordering and inheritance of file system contents and environment variables. Files from dependency tasks are merged into this task's workspace in the order specified. If multiple dependencies produce the same file, the last dependency in the list takes precedence. Environment variables exported by dependencies (via $RWX_ENV) are automatically available in this task."
        },
        "after": {
          "$ref": "#/$defs/Dependencies",
          "description": "The tasks that must run before this task will execute. Unlike 'use', no files or environment variables are inherited from the specified tasks. `after` supports expressions for conditional execution based on task status (e.g., `${{ task.failed && other-task.succeeded }}`). When tasks are referenced without a status (e.g. `after: [task-one, task-two]`), this task will only execute if the referenced tasks completed successfully. If the tasks fail or are skipped, this task will also be skipped."
        },
        "if": {
          "type": "string",
          "description": "A boolean expression that determines whether the task executes. If false, the task is skipped along with any dependent tasks. Supports template expressions with boolean operators (&&, ||), comparison operators (==, !=), regex matching (=~, !~), and utility functions (starts-with, contains, etc.)."
        },
        "agent": {
          "$ref": "#/$defs/AgentSpecification",
          "description": "The compute resource requirements for the task execution agent. The  default agent is 2 CPUs, 8GB memory, and 50GB disk. Agent memory (with units like 'gb'), CPU count, disk space (in 50GB increments), and special features like static IPs or tmpfs can all be configured. Choose agent specifications based on task requirements - use larger agents for compilation or data processing, smaller agents for simple operations. Different tasks within a run can use different agent specifications for cost optimization, so a dependency install can use a large agent while a test task using those dependencies can use a small one.."
        },
        "docker": {
          "oneOf": [
            { "type": "boolean" },
            { "type": "string", "enum": ["preserve-data"] }
          ],
          "description": "The docker daemon configuration for container operations within the task. Options: 'true' (basic Docker with cleanup), 'preserve-data' (Docker with persistence for images, volumes, build cache), or 'false' (disabled). The preserve-data option is useful for pre-pulling and caching large container images, sharing Docker volumes between dependent tasks, enabling incremental Docker builds with build cache, and setting up persistent database containers for testing."
        },
        "parallel": {
          "$ref": "#/$defs/ParallelConfiguration",
          "description": "Parallelism configuration for generating multiple task instances with different parameters. Types: 'total' (numeric value creating indexed parallel tasks), 'matrix' (all combinations of specified variable arrays), 'values' (explicit array of parameter objects). Generated tasks receive context variables like parallel.index, parallel.total, and parallel.<variable-name>."
        },
        "env": {
          "$ref": "#/$defs/EnvironmentVariables",
          "description": "Environment variable configuration for task execution context. Formats: simple key-value pairs or advanced objects with 'value' and 'cache-key' properties. Cache behavior: 'included' (default, variable value affects cache key), 'excluded' (variable ignored for caching, enabling cache hits with ephemeral values like credentials). Tasks can export variables to $RWX_ENV for use in dependent tasks. Variables from 'use' dependencies are automatically inherited."
        },
        "env-config": {
          "$ref": "#/$defs/EnvironmentConfiguration",
          "description": "Configuration for how environment variables from dependency tasks are merged. Default behavior: later tasks in 'use' array overwrite earlier values. Special case: PATH is automatically joined with ':' separator. Merge configuration: 'strategy: join' concatenates values with specified separator. Primarily used for PATH-like variables that need combining rather than replacement."
        },
        "cache": {
          "$ref": "#/$defs/CacheConfiguration",
          "description": "Configure content-based caching behavior for the task. Mint automatically caches tasks based on their inputs, but you can control caching with boolean values or TTL (time-to-live) settings. When disabled, tasks will always execute. TTL formats: '1 min/minute', '1 hr/hour', '1 day' for automatic cache expiration. When configured with a TTL, caches will automatically expire after the specified duration."
        },
        "tool-cache": {
          "type": "string",
          "description": "Reference to a named tool cache for incremental caching. The tool cache preserves the filesystem contents from previous executions of this task, enabling incremental updates when the task has a cache miss. Particularly effective for dependency installation tasks like npm install, bundle install, or yarn install. Tool cache names should be unique within the vault and descriptive of their purpose. The global tool-cache vault configuration must be set for task-level tool caches to function."
        },
        "filter": {
          "oneOf": [
            { "type": "string" },
            { 
              "type": "array", 
              "items": { 
                "oneOf": [
                  { "type": "string" },
                  { "type": "array", "items": { "type": "string" } }
                ]
              }
            },
            { "$ref": "#/$defs/InputFilesystemFilter" }
          ],
          "description": "Specify which files from the workspace should be present for the task execution. Filters use glob patterns and improve cache hit rates by ensuring tasks only depend on relevant files. Only affects the workspace directory (/var/mint-workspace), not system files. Supports patterns: '*' (match within segment), '**' (match across segments), '{}' (comma-delimited options), '!' (negate/exclude). Arrays can contain strings or nested arrays (useful with YAML aliases)."
        },
        "background-processes": {
          "type": "array",
          "description": "Define background services that run alongside the main task command. Supports ready checks to ensure services are available before the main command executes, and dependency sequencing between background processes. Processes start in parallel unless 'after' is specified. Default ready-check timeout: 60 seconds. Use service-specific tools for ready checks when possible.",
          "items": { "$ref": "#/$defs/BackgroundProcess" }
        },
        "outputs": {
          "$ref": "#/$defs/OutputConfiguration",
          "description": "Configure different types of task outputs including file artifacts, test result parsing, output values for other tasks, and problem detection from logs or files. Artifacts are preserved as downloadable files, test results integrate with UI display, output values enable task communication via $MINT_VALUES directory, and problems support built-in matchers (eslint, rubocop, etc.) or custom formats."
        },
        "timeout": {
          "type": "string",
          "minimum": 1,
          "description": "Maximum execution time for the task (default: 10 minutes), with a unit like 'm' or 'h' on the end (e.g. `timeout: 30m`). If the task runs longer than this timeout, it will be terminated with a SIGKILL signal (or SIGTERM if terminate-grace-period-seconds is set). The timeout applies to the entire task execution, including any background processes and their ready checks. Helps prevent runaway tasks from consuming resources indefinitely."
        },
        "timeout-minutes": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum execution time for the task in minutes (default: 10 minutes). If the task runs longer than this timeout, it will be terminated with a SIGKILL signal (or SIGTERM if terminate-grace-period-seconds is set). The timeout applies to the entire task execution, including any background processes and their ready checks. Helps prevent runaway tasks from consuming resources indefinitely."
        },
        "terminate-grace-period-seconds": {
          "type": "integer",
          "minimum": 0,
          "description": "Grace period in seconds to allow for clean shutdown when the task is terminated due to timeout or cancellation (default: 0 for immediate SIGKILL). During this period, the task process receives a SIGTERM signal and can perform cleanup operations (releasing locks, closing connections, saving state) before being forcefully terminated with SIGKILL. Essential for tasks that manage external resources like Terraform locks."
        },
        "retry": {
          "$ref": "#/$defs/RetryConfiguration",
          "description": "Retry configuration that specifies how many times to retry the task if it fails and what action to take on retry. Retries help handle transient failures like network issues, resource contention, or flaky tests. Each retry attempt gets a fresh execution environment. Advanced retry actions can be configured to customize retry behavior, set debug flags, or provide retry-specific data via $MINT_RETRY_ACTIONS directory."
        },
        "health-timeout": {
          "type": "string",
          "description": "Maximum time for the agent to report its healthiness (e.g., '15m' or '1h'). If an agent has not reported that it is healthy within this time frame, the task will fail. The default value is 1 minute per 1 hour of configured timeout. This helps detect and handle unresponsive or stuck agents during task execution."
        }
      },
      "required": ["key", "run"],
      "unevaluatedProperties": false
    },

    "PackageTask": {
      "type": "object",
      "description": "A task that calls a reusable package. Package tasks allow you to invoke pre-built, versioned components that encapsulate common functionality. Packages provide reusable workflow building blocks with defined parameter schemas, similar to GitHub Actions but optimized for Mint's execution model.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "An identifier for the task. Keys are used for referencing the task within other tasks through dependencies and artifact references. They also serve as the display name of the task within the UI and logs. Must be unique within the run definition."
        },
        "call": {
          "oneOf": [
            {
              "type": "string",
              "pattern": "^[a-z0-9-]+/[a-z0-9-]+\\s+[0-9]+\\.[0-9]+\\.[0-9]+$"
            },
            { "type": "string", "pattern": "^[a-f0-9]{64}$" }
          ],
          "description": "The package identifier specifying which package to call. Use name/version format (e.g., 'namespace/package-name 1.2.0') for semantic versioning or SHA-256 digest for exact version pinning. Packages must be published and available in your organization's package registry. Version format follows semantic versioning (major.minor.patch)."
        },
        "with": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
          "description": "Parameters to pass to the package. Each package defines its own parameter schema that specifies required and optional parameters with their types and defaults. Parameters can use template expressions to pass dynamic values like outputs from other tasks, initialization parameters, or event context. All values are converted to strings by the system."
        },
        "use": { "$ref": "#/$defs/Dependencies" },
        "after": { "$ref": "#/$defs/Dependencies" },
        "if": {
          "type": "string",
          "description": "An expression that determines whether the task should execute. If the expression evaluates to 'false', the task will be skipped."
        },
        "env": { "$ref": "#/$defs/EnvironmentVariables" },
        "env-config": { "$ref": "#/$defs/EnvironmentConfiguration" },
        "cache": { "$ref": "#/$defs/CacheConfiguration" },
        "parallel": { "$ref": "#/$defs/ParallelConfiguration" },
        "filter": {
          "oneOf": [
            { "type": "string" },
            { 
              "type": "array", 
              "items": { 
                "oneOf": [
                  { "type": "string" },
                  { "type": "array", "items": { "type": "string" } }
                ]
              }
            },
            { "$ref": "#/$defs/FilterSet" }
          ],
          "description": "Input filtering for package tasks specifying which workspace files should be available to the package. Uses glob patterns to include or exclude files from the package execution environment. Package tasks only support workspace filtering (not system file filtering) and cannot filter artifacts from other tasks. Helps optimize performance and cache behavior. Arrays can contain strings or nested arrays (useful with YAML aliases)."
        }
      },
      "required": ["key", "call"],
      "unevaluatedProperties": false
    },

    "EmbeddedRunTask": {
      "type": "object",
      "description": "A task that executes another run definition as a sub-run. Embedded run tasks allow you to compose complex workflows by including other run definitions from the same repository or external sources. This enables modularity and reuse of common workflow patterns like CI pipelines, deployment processes, or test suites. Different embedded runs can specify different base layers than their parent run.",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "An identifier for the task. Keys are used for referencing the task within other tasks through dependencies and artifact references. They also serve as the display name of the task within the UI and logs. Must be unique within the run definition."
        },
        "call": {
          "type": "string",
          "not": {
            "oneOf": [
              {
                "pattern": "^[a-z0-9-]+/[a-z0-9-]+\\s+[0-9]+\\.[0-9]+\\.[0-9]+$"
              },
              {
                "pattern": "^[a-f0-9]{64}$"
              }
            ]
          },
          "description": "The source of the embedded run definition. Can be a file path relative to the current run definition, an absolute path, or a template expression that resolves to a run definition location. The referenced file must be a valid Mint YAML run definition. Must not match the package name/version format used by package tasks. Common patterns use ${{ run.mint-dir }} for consistent path resolution."
        },
        "init": {
          "type": "object",
          "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
          "description": "Initialization parameters to pass to the embedded run definition. These parameters are available as template variables in the embedded run using the 'init' namespace (e.g., ${{ init.environment }}). Allows customizing the behavior of reusable run definitions based on the calling context, enabling parameterized workflows that can adapt to different environments, configurations, or input data."
        },
        "target": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Specific tasks within the embedded run to execute. If not specified, all tasks in the embedded run will be executed according to their dependencies. Allows selective execution of portions of larger run definitions, enabling modular workflow composition. Can be a single task key or an array of task keys. Dependencies of targeted tasks are automatically included."
        },
        "after": { "$ref": "#/$defs/Dependencies" },
        "if": {
          "type": "string",
          "description": "An expression that determines whether the task should execute. If the expression evaluates to 'false', the task will be skipped."
        },
        "cache": { "$ref": "#/$defs/CacheConfiguration" },
        "parallel": { "$ref": "#/$defs/ParallelConfiguration" }
      },
      "required": ["key", "call"],
      "unevaluatedProperties": false
    },

    "Dependencies": {
      "oneOf": [
        { "type": "string" },
        { "type": "array", "items": { "type": "string" } }
      ],
      "description": "Task keys that must complete successfully before this task can start. Can be a single task key string or an array of task keys. Dependencies ensure proper execution order and that required outputs, artifacts, or side effects are available."
    },

    "AgentSpecification": {
      "type": "object",
      "description": "Compute resource requirements for the task execution agent. The platform will allocate an agent that meets these specifications before running the task. Default allocation is 2 CPUs, 8GB memory, and 50GB disk. Supports General Purpose (2-64 CPUs, 8gb-256gb memory), Compute Optimized (2-32 CPUs, 4gb-64gb memory), and Memory Optimized (2-64 CPUs, 16gb-512gb memory) configurations.",
      "properties": {
        "memory": {
          "type": "string",
          "description": "The memory allocation for the task execution environment, specified as a string followed by 'gb' (e.g. 16gb). Higher memory allocations allow for more memory-intensive tasks like large builds or data processing. RWX reserves 2GB RAM for internal use."
        },
        "cpus": {
          "oneOf": [{ "type": "integer", "minimum": 1 }, { "type": "string" }],
          "description": "The number of CPU cores to allocate for the task. Can be specified as an integer or as a template expression. More CPUs enable parallel processing and faster execution for CPU-intensive tasks."
        },
        "disk": {
          "oneOf": [
            { "type": "string" },
            {
              "type": "object",
              "properties": {
                "size": {
                  "type": "string",
                  "description": "Disk space allocation followed by 'gb'"
                }
              }
            }
          ],
          "description": "The disk space allocation for the task execution environment, which can be specified as a simple string or as an object with a size property. Available in 50GB increments starting from 50GB (default). Larger disk allocations support tasks that generate large artifacts or work with large datasets."
        },
        "static-ips": {
          "type": "string",
          "description": "A vault expression resolving to the static IPs to use for the task. Useful for tasks that need to be whitelisted by external services or require consistent network identity."
        },
        "tmpfs": {
          "type": "boolean",
          "description": "Whether to use tmpfs (in-memory filesystem) for improved I/O performance. Tmpfs is useful for tasks with heavy disk I/O that can benefit from memory-backed storage (e.g. task that install node modules), but requires sufficient memory allocation. Any tasks with significant filesystem I/O that fits in ~70% of available memory will benefit from tmpfs. "
        },
        "spot": {
          "type": "boolean",
          "description": "Whether to use spot instances for task execution. When true, ephemeral instances are used that may be preempted at any time but offer cost savings. When false or omitted, standard on-demand instances are used with guaranteed availability and stable performance. Choose spot instances for fault-tolerant workloads that can handle interruptions. Tasks with spot agents that are interrupted are automatically retried by RWX."
        }
      },
      "unevaluatedProperties": false
    },

    "ParallelConfiguration": {
      "oneOf": [
        { "type": "integer", "minimum": 1, "maximum": 256 },
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "A custom naming pattern for generated parallel tasks. Supports template expressions using parallel variables (e.g., 'build-${{ parallel.os }}-${{ parallel.arch }}'). If not specified, tasks are named based on the parallel field and given numeric suffixes."
            },
            "tasks-limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 256,
              "description": "The maximum number of parallel tasks to run concurrently (default: 16, max: 256). This field is designed to prevent accidentally running hundreds of tasks with an incorrect parallel configuration and can be safely increased to the level of parallelism you expect to run."
            },
            "total": {
              "$ref": "#/$defs/PrimitiveValue",
              "description": "The total number of parallel executions to create (0 to n-1). Each execution gets its own parallel.index and parallel.total variables accessible via ${{ parallel.index }} and environment variables $RWX_PARALLEL_INDEX, $RWX_PARALLEL_TOTAL."
            },
            "matrix": {
              "type": "object",
              "additionalProperties": {
                "oneOf": [
                  { "$ref": "#/$defs/PrimitiveValue" },
                  {
                    "type": "array",
                    "items": { "$ref": "#/$defs/PrimitiveValue" }
                  }
                ]
              },
              "description": "Matrix parallelism creates all combinations of specified variable arrays. Each combination becomes a separate parallel execution with access to the matrix variables via ${{ parallel.variable-name }}. The cartesian product of all specified array will be generated."
            },
            "values": {
              "oneOf": [
                { "type": "string" },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" }
                  }
                }
              ],
              "description": "An explicit list of parameter objects for parallel execution. Each object becomes a separate parallel execution with access to the specified variables via ${{ parallel.variable-name }}. All objects must have the same keys. This is useful when you need specific combinations rather than the cartesian product."
            }
          },
          "unevaluatedProperties": false
        }
      ],
      "description": "Parallelism configuration for generating multiple task instances with different parameters. Types: 'total' (numeric value creating indexed parallel tasks 0 to n-1), 'matrix' (all combinations of specified variable arrays), 'values' (explicit array of parameter objects with same keys). Generated tasks receive context variables: parallel.index/parallel.total for numeric, parallel.<variable-name> for matrix/values. Environment variables: $MINT_PARALLEL_INDEX, $MINT_PARALLEL_TOTAL. Limits: 1-256 tasks (default 16, configurable with tasks-limit)."
    },

    "EnvironmentVariables": {
      "type": "object",
      "additionalProperties": {
        "oneOf": [
          { "type": "string" },
          { "type": "number" },
          { "type": "boolean" },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string",
                "description": "The environment variable value. Supports template expressions for dynamic values from other tasks, initialization parameters, or event context."
              },
              "cache-key": {
                "type": "string",
                "enum": ["included", "excluded"],
                "description": "Whether this environment variable should be included in cache key generation. 'included' (default): variable value affects cache key. 'excluded': variable ignored for caching, enabling cache hits with ephemeral values like credentials."
              }
            },
            "unevaluatedProperties": false
          }
        ]
      },
      "description": "Environment variable configuration for task execution context. Formats: simple key-value pairs (VAR_NAME: value) or advanced objects with 'value' and 'cache-key' properties. Cache behavior: 'included' (default, affects cache key), 'excluded' (ignored for caching, for ephemeral credentials). Tasks can export variables to $MINT_ENV/ for use in dependent tasks. Variables from 'use' dependencies are automatically inherited. All values are converted to strings."
    },

    "EnvironmentConfiguration": {
      "type": "object",
      "description": "Configuration for how environment variables from dependency tasks are merged. Default behavior: later tasks in 'use' array overwrite earlier values. Special case: PATH is automatically joined with ':' separator. Merge configuration allows customizing this behavior for specific variables.",
      "properties": {
        "inherit": {
          "oneOf": [
            { "type": "string", "enum": ["all-used-tasks"] },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Inherit environment variables from dependency tasks. 'all-used-tasks' inherits from all tasks listed in 'use', or specify an array of specific task keys. Note: inheritance is automatic for 'use' dependencies; this setting provides explicit control."
        },
        "merge": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "strategy": { "type": "string", "enum": ["join", "override"] },
              "by": {
                "type": "string",
                "description": "Separator string for join strategy. Common values: ':' for PATH-like variables, ',' for comma-separated lists, ' ' for space-separated values."
              }
            }
          },
          "description": "Merge strategies for environment variables with the same name from multiple sources."
        }
      },
      "unevaluatedProperties": false
    },

    "CacheConfiguration": {
      "oneOf": [
        { "type": "boolean" },
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "enabled": {
              "oneOf": [{ "type": "boolean" }, { "type": "string" }],
              "description": "Whether caching is enabled for this task"
            },
            "ttl": {
              "type": "string",
              "description": "Time-to-live for cache entries. Supported formats: '1 min', '1 minute', '2 mins', '2 minutes', '1 hr', '1 hour', '2 hrs', '2 hours', '1 day', '2 days'. Cache entries automatically expire after the specified duration."
            }
          }
        }
      ],
      "description": "Configure content-based caching behavior for the task. Mint automatically caches tasks based on their inputs, but you can control caching with boolean values or TTL (time-to-live) settings. When disabled, tasks will always execute. TTL formats: '1 min/minute', '1 hr/hour', '1 day' for automatic cache expiration."
    },

    "BackgroundProcess": {
      "type": "object",
      "description": "A background process that runs concurrently with the main task command. Useful for services, databases, or other long-running processes that the task needs to interact with. Processes start in parallel unless 'after' is specified. Support ready checks with default 60-second timeout and graceful termination with configurable grace periods (default: 10 seconds).",
      "properties": {
        "key": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_][a-zA-Z0-9_\\-\\.]*$",
          "description": "Unique identifier for the background process within the task. Used for process ordering with 'after' dependencies and in logs/UI for identification."
        },
        "run": {
          "type": "string",
          "description": "Command to execute for the background process. Runs in the same containerized environment as the main task with access to the same filesystem and environment variables."
        },
        "ready-check": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } },
            {
              "type": "object",
              "properties": {
                "run": {
                  "oneOf": [
                    { "type": "string" },
                    { "type": "array", "items": { "type": "string" } }
                  ],
                  "description": "Command or commands to run to check if the background process is ready. Should be lightweight and idempotent. Use service-specific tools when possible (e.g., pg_isready for PostgreSQL, redis-cli ping for Redis)."
                },
                "timeout-seconds": {
                  "type": "integer",
                  "minimum": 1,
                  "description": "Maximum time to wait for the ready check to succeed (default: 60 seconds). Ready checks are retried until timeout is reached."
                }
              },
              "required": ["run"],
              "unevaluatedProperties": false
            }
          ],
          "description": "Configuration for checking when the background process is ready to receive requests. Can be a simple command string, array of commands, or detailed object with timeout configuration. Ready checks run repeatedly until they succeed or timeout. Use service-specific ready check commands when possible rather than generic port checks."
        },
        "after": {
          "oneOf": [
            { "type": "string" },
            { "type": "array", "items": { "type": "string" } }
          ],
          "description": "Other background processes that must be ready before starting this process. Can be a single process key or an array of process keys. Creates startup sequencing to handle service dependencies (e.g., database before web server)."
        },
        "terminate-grace-period-seconds": {
          "type": "integer",
          "minimum": 0,
          "description": "Grace period for clean shutdown when terminating the background process (default: 10 seconds). Process receives SIGTERM, then SIGKILL after grace period. Allows time for cleanup operations like flushing data or closing connections."
        }
      },
      "required": ["key", "run"],
      "unevaluatedProperties": false
    },

    "OutputConfiguration": {
      "type": "object",
      "description": "Configure different types of task outputs including file artifacts, test result parsing, output values for other tasks, and problem detection from logs or files. Artifacts are preserved as downloadable files, test results integrate with UI display, output values enable task communication via $MINT_VALUES directory, and problems support built-in matchers (eslint, rubocop, shellcheck, tsc) or custom formats.",
      "properties": {
        "execution-status": {
          "type": "object",
          "description": "Configuration for custom success/failure determination",
          "properties": {
            "success-exit-codes": {
              "type": "array",
              "items": { "type": "integer" },
              "description": "Exit codes that should be considered successful completion"
            }
          }
        },
        "test-results": {
          "type": "array",
          "description": "Test result files to process and display in the UI",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "Path to test result file"
              },
              "options": {
                "type": "object",
                "properties": {
                  "framework": {
                    "type": "string",
                    "description": "Test framework name"
                  },
                  "language": {
                    "type": "string",
                    "description": "Programming language"
                  }
                },
                "required": ["framework", "language"]
              }
            },
            "required": ["path"]
          }
        },
        "values": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Names of output values that other tasks can reference"
        },
        "problems": {
          "type": "array",
          "description": "Problem detection configuration for parsing errors, warnings, and issues from task output",
          "items": {
            "type": "object",
            "oneOf": [
              {
                "properties": {
                  "matcher": {
                    "type": "string",
                    "description": "Problem matcher name or URL"
                  }
                },
                "required": ["matcher"]
              },
              {
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "Path to problem file"
                  },
                  "format": {
                    "type": "string",
                    "enum": [
                      "auto",
                      "problem-json",
                      "github-annotation-json",
                      "github-annotations-action-json"
                    ],
                    "description": "Format of the problem file"
                  }
                },
                "required": ["path"]
              }
            ]
          }
        },
        "artifacts": {
          "type": "array",
          "description": "Files or directories to collect as artifacts after task completion",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string",
                "description": "Unique identifier for the artifact"
              },
              "path": {
                "type": "string",
                "description": "File or directory path to collect"
              }
            },
            "required": ["key", "path"]
          }
        },
        "filesystem": {
          "oneOf": [
            { "type": "boolean" },
            {
              "type": "object",
              "description": "Filesystem filtering for preserving files after task completion",
              "properties": {
                "filter": {
                  "oneOf": [
                    { "type": "array", "items": { "type": "string" } },
                    {
                      "type": "object",
                      "properties": {
                        "workspace": {
                          "type": "array",
                          "items": { "type": "string" }
                        },
                        "system": {
                          "type": "array",
                          "items": { "type": "string" }
                        }
                      }
                    }
                  ]
                }
              }
            }
          ],
          "description": "Filesystem output configuration. Set to false to disable outputting a filesystem layer from this task, or configure filtering for preserving specific files after task completion."
        }
      },
      "unevaluatedProperties": false
    },

    "RetryConfiguration": {
      "oneOf": [
        { "type": "string" },
        {
          "type": "object",
          "properties": {
            "count": {
              "$ref": "#/$defs/PrimitiveValue",
              "description": "Number of retry attempts"
            },
            "action": {
              "type": "string",
              "description": "Action to take on retry"
            }
          },
          "required": ["count"]
        }
      ],
      "description": "Configuration for automatic task retries on failure"
    },

    "InputFilesystemFilter": {
      "type": "object",
      "description": "Filtering configuration for input files from workspace and dependencies",
      "properties": {
        "workspace": { "type": "array", "items": { "type": "string" } },
        "system": { "type": "array", "items": { "type": "string" } }
      },
      "unevaluatedProperties": false
    },

    "FilterSet": {
      "type": "object",
      "description": "File filtering configuration",
      "properties": {
        "workspace": { "type": "array", "items": { "type": "string" } }
      },
      "unevaluatedProperties": false
    },

    "Triggers": {
      "type": "object",
      "description": "Trigger configuration defining when the run should execute",
      "properties": {
        "github": { "$ref": "#/$defs/GitHubTriggers" },
        "gitlab": { "$ref": "#/$defs/GitLabTriggers" },
        "cron": { "$ref": "#/$defs/CronTriggers" },
        "cli": { "$ref": "#/$defs/CLITrigger" },
        "dispatch": { "$ref": "#/$defs/DispatchTriggers" },
        "cache-rebuild": { "$ref": "#/$defs/CacheRebuildTriggers" },
        "webhook": { "$ref": "#/$defs/WebhookTriggers" }
      },
      "unevaluatedProperties": false
    },

    "GitHubTriggers": {
      "type": "object",
      "description": "GitHub event triggers for automated run execution. Supports push events (on branch updates), pull_request events (on PR lifecycle), and merge_group events. Each trigger provides rich event context accessible via template expressions like ${{ event.git.branch }}, ${{ event.github.push.head_commit.message }}. Triggers can specify conditions (if), initialization parameters (init), target tasks (target), and custom run titles (title).",
      "properties": {
        "push": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubPushTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubPushTrigger" }
            }
          ],
          "description": "Triggers for GitHub push events (branch updates, tag pushes). Can be a single trigger object or an array of trigger objects for different configurations. Provides event context: event.git.branch, event.git.sha, event.git.ref, event.git.tag, event.github.push.head_commit.message, event.github.push.repository.clone_url, event.github.push.sender.login."
        },
        "pull_request": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubPullRequestTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubPullRequestTrigger" }
            }
          ],
          "description": "Triggers for GitHub pull request events (opened, reopened, synchronize, closed). Can be a single trigger object or an array of trigger objects. Default actions: [opened, reopened, synchronize]. Provides event context: event.git.branch, event.git.sha, event.git.ref, event.github.pull_request.number, event.github.pull_request.pull_request.title."
        },
        "merge_group": {
          "oneOf": [
            { "$ref": "#/$defs/GitHubMergeGroupTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitHubMergeGroupTrigger" }
            }
          ],
          "description": "Triggers for GitHub merge group events. Can be a single trigger object or an array of trigger objects."
        }
      },
      "unevaluatedProperties": false
    },

    "GitHubPushTrigger": {
      "type": "object",
      "description": "Configuration for GitHub push event triggers. Triggered on branch updates, tag pushes, and repository pushes. Supports conditional execution, initialization parameter mapping, selective task targeting, custom run titles, and GitHub status check reporting.",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitHubPullRequestTrigger": {
      "type": "object",
      "description": "Configuration for GitHub pull request event triggers. Triggered on PR lifecycle events (opened, reopened, synchronize, closed). Default actions: [opened, reopened, synchronize]. Supports conditional execution, initialization parameter mapping, selective task targeting, custom run titles, and GitHub status check reporting.",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "actions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "PR actions that trigger the run. Available actions: 'opened' (PR is opened), 'reopened' (previously closed PR is reopened), 'synchronize' (PR branch is updated), 'closed' (PR is closed). Default: [opened, reopened, synchronize] if not specified."
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitHubMergeGroupTrigger": {
      "type": "object",
      "description": "Configuration for GitHub merge group event triggers",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": {
          "type": "string",
          "description": "Condition for trigger activation"
        },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": {
          "type": "string",
          "description": "Custom title for the run"
        },
        "actions": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Merge group actions that trigger the run"
        },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "GitLabTriggers": {
      "type": "object",
      "description": "GitLab event triggers for automated run execution. Supports push events (branch updates), tag-push events (tag creation), and merge-request events (MR lifecycle). Each trigger provides GitLab-specific event context and supports conditional execution, initialization parameters, target tasks, and custom run titles.",
      "properties": {
        "push": {
          "oneOf": [
            { "$ref": "#/$defs/BaseTrigger" },
            { "type": "array", "items": { "$ref": "#/$defs/BaseTrigger" } }
          ]
        },
        "tag-push": {
          "oneOf": [
            { "$ref": "#/$defs/BaseTrigger" },
            { "type": "array", "items": { "$ref": "#/$defs/BaseTrigger" } }
          ]
        },
        "merge-request": {
          "oneOf": [
            { "$ref": "#/$defs/GitLabMergeRequestTrigger" },
            {
              "type": "array",
              "items": { "$ref": "#/$defs/GitLabMergeRequestTrigger" }
            }
          ]
        }
      },
      "unevaluatedProperties": false
    },

    "GitLabMergeRequestTrigger": {
      "type": "object",
      "description": "Configuration for GitLab merge request event triggers",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": { "type": "string" },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": { "type": "string" },
        "actions": { "type": "array", "items": { "type": "string" } },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "CronTriggers": {
      "type": "array",
      "description": "Scheduled cron triggers for automated run execution using cron expressions with optional timezone specification. Each trigger requires a unique key and schedule. Provides rich event context including time fields in both schedule timezone and UTC. Useful for recurring workflows like nightly builds, cache warming, or scheduled deployments.",
      "items": {
        "type": "object",
        "properties": {
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": {
            "type": "string",
            "description": "Condition for trigger activation"
          },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": {
            "type": "string",
            "description": "Custom title for the run"
          },
          "key": {
            "type": "string",
            "description": "Unique identifier for the cron trigger. Must be unique within the organization. Used for identification in logs, UI, and manual trigger execution via CLI."
          },
          "schedule": {
            "type": "string",
            "description": "Cron expression for scheduling with optional timezone. Standard format: 'minute hour day-of-month month day-of-week'. With timezone: '30 9 * * * America/New_York'. Default timezone: UTC. Provides event context: event.cron.year, event.cron.hour, event.cron.utc.hour, etc."
          },
          "branch": {
            "type": "string",
            "description": "Git branch to use for the run"
          },
          "reset-tool-cache": {
            "type": "boolean",
            "description": "Whether to reset tool cache"
          }
        },
        "required": ["key", "schedule"],
        "unevaluatedProperties": false
      }
    },

    "CLITrigger": {
      "type": "object",
      "description": "Configuration for manual CLI-triggered runs",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "title": {
          "type": "string",
          "description": "Custom title for CLI runs"
        }
      },
      "unevaluatedProperties": false
    },

    "DispatchTriggers": {
      "type": "array",
      "description": "API dispatch triggers for programmatic run execution. Allows on-demand execution via CLI (`rwx dispatch`), API calls, or Cloud UI. Each trigger requires a unique key within your organization and can define parameters for user input. Parameters are accessible via event.dispatch.params context and must be explicitly mapped to initialization parameters. Provides flexible workflow orchestration for deployment pipelines, manual testing, or external integrations.",
      "items": {
        "type": "object",
        "properties": {
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": { "type": "string" },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": { "type": "string" },
          "key": {
            "type": "string",
            "description": "Unique key for the dispatch trigger within your organization. Used for CLI dispatch commands (`rwx dispatch <key>`), API calls, and UI identification. Should be descriptive of the dispatch purpose (e.g., 'deploy-application', 'run-integration-tests')."
          },
          "params": {
            "type": "array",
            "description": "Parameters that can be provided when dispatching. Each parameter defines input fields for users to specify when triggering the dispatch. Parameters are accessible via ${{ event.dispatch.params.parameter-key }} and must be mapped to initialization parameters in the 'init' section. Supports default values and required validation.",
            "items": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "Parameter key for referencing via ${{ event.dispatch.params.key-name }}. Should be descriptive and follow naming conventions."
                },
                "name": {
                  "type": "string",
                  "description": "Human-readable display name shown in UI and CLI prompts. Should be clear and descriptive for users."
                },
                "description": {
                  "type": "string",
                  "description": "Parameter description"
                },
                "default": {
                  "$ref": "#/$defs/PrimitiveValue",
                  "description": "Default value"
                },
                "required": {
                  "type": "boolean",
                  "description": "Whether parameter is required"
                }
              },
              "required": ["key"],
              "unevaluatedProperties": false
            }
          }
        },
        "required": ["key"],
        "unevaluatedProperties": false
      }
    },

    "CacheRebuildTriggers": {
      "type": "array",
      "description": "Cache rebuild triggers provide instructions to RWX about how to rebuild your content-based cache. These triggers are used to make the RWX cache even faster and more effective than it already is. Each trigger can specify initialization parameters, conditions, target tasks, custom titles, and a git reference to run the cache rebuild on.",
      "items": {
        "type": "object",
        "properties": {
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": {
            "type": "string",
            "description": "Condition for trigger activation"
          },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": {
            "type": "string",
            "description": "Custom title for the cache rebuild run"
          },
          "ref": {
            "type": "string",
            "description": "Git reference (branch, tag, or commit) to run the cache rebuild on"
          }
        },
        "unevaluatedProperties": false
      }
    },

    "WebhookTriggers": {
      "type": "array",
      "description": "Webhook triggers allow external systems to trigger runs via HTTP POST requests. Each webhook trigger requires a unique key within your organization that is used to generate the webhook URL. Webhooks can specify initialization parameters, conditions, target tasks, and custom run titles. Useful for integrating with external services, deployment systems, or custom automation tools.",
      "items": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Unique key for the webhook trigger within your organization. Used for webhook URL generation."
          },
          "init": { "$ref": "#/$defs/InitParameters" },
          "if": {
            "type": "string",
            "description": "Condition for trigger activation"
          },
          "target": { "$ref": "#/$defs/TargetTasks" },
          "title": {
            "type": "string",
            "description": "Custom title for the webhook run"
          }
        },
        "required": ["key"],
        "unevaluatedProperties": false
      }
    },

    "BaseTrigger": {
      "type": "object",
      "description": "Base trigger configuration with common properties",
      "properties": {
        "init": { "$ref": "#/$defs/InitParameters" },
        "if": { "type": "string" },
        "target": { "$ref": "#/$defs/TargetTasks" },
        "title": { "type": "string" },
        "status-checks": { "$ref": "#/$defs/StatusChecks" }
      },
      "unevaluatedProperties": false
    },

    "InitParameters": {
      "type": "object",
      "additionalProperties": { "$ref": "#/$defs/PrimitiveValue" },
      "description": "Initialization parameters passed to the run or embedded run"
    },

    "TargetTasks": {
      "oneOf": [
        { "type": "string" },
        { "type": "array", "items": { "type": "string" } }
      ],
      "description": "Specific tasks to execute when triggered"
    },

    "StatusChecks": {
      "oneOf": [
        { "type": "boolean" },
        { "type": "string" },
        {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "tasks": { "$ref": "#/$defs/TargetTasks" },
              "name": {
                "type": "string",
                "description": "Custom name for the status check"
              }
            },
            "required": ["tasks"]
          }
        },
        {
          "type": "object",
          "properties": {
            "enabled": {
              "oneOf": [{ "type": "boolean" }, { "type": "string" }],
              "description": "Whether status checks are enabled. Can be a boolean or a template expression."
            },
            "name": {
              "type": "string",
              "description": "Default name for status checks. Supports template expressions."
            },
            "default": {
              "oneOf": [
                { "type": "boolean" },
                { "type": "string" },
                {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "oneOf": [{ "type": "boolean" }, { "type": "string" }],
                      "description": "Whether the default status check is enabled"
                    },
                    "name": {
                      "type": "string",
                      "description": "Name for the default status check"
                    }
                  }
                }
              ],
              "description": "Configuration for the default status check that reports overall run status"
            },
            "custom": {
              "type": "array",
              "description": "Custom status checks for specific tasks or task groups",
              "items": {
                "type": "object",
                "properties": {
                  "tasks": { "$ref": "#/$defs/TargetTasks" },
                  "name": {
                    "type": "string",
                    "description": "Custom name for the status check"
                  }
                },
                "required": ["tasks"]
              }
            }
          }
        }
      ],
      "description": "GitHub/GitLab status check configuration. Can be a boolean to enable/disable all checks, a string expression, an array of custom checks, or an object with default and custom check configurations. Status checks report task execution status back to the version control system."
    },

    "ConcurrencyPool": {
      "type": "object",
      "description": "Configuration for limiting concurrent task execution across the run",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the concurrency pool"
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum number of concurrent tasks in this pool"
        },
        "on-overflow": {
          "type": "string",
          "enum": ["queue", "cancel-waiting", "cancel-running"],
          "description": "Action to take when pool capacity is exceeded"
        },
        "if": {
          "type": "string",
          "description": "Condition for pool activation"
        }
      },
      "required": ["id", "capacity", "on-overflow"],
      "unevaluatedProperties": false
    },

    "ToolCache": {
      "type": "object",
      "description": "Global tool cache configuration",
      "properties": {
        "vault": {
          "type": "string",
          "description": "Vault to use for tool cache"
        }
      },
      "unevaluatedProperties": false
    },

    "BaseLayer": {
      "type": "object",
      "description": "Base container layer configuration that defines the operating system, version, and Mint configuration tag for task execution. Currently supports Ubuntu 22.04 (tag 1.0 with Docker 26.0.1) and Ubuntu 24.04 (tag 1.1 with Docker 28.0.4). The base layer determines available system packages, pre-installed Docker version, and tool cache compatibility. Different embedded runs can specify different base layers than their parent run.",
      "properties": {
        "os": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "Operating system for the base container layer. Currently supported values are 'ubuntu 24.04' and 'ubuntu 22.04'. The OS version determines available system packages and affects tool cache compatibility. Different embedded runs can specify different operating systems than their parent run."
        },
        "tag": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "Mint configuration version tag that specifies the pre-configured software environment. Tag '1.1' includes Docker 28.0.4 (for Ubuntu 24.04), while tag '1.0' includes Docker 26.0.1 (for Ubuntu 22.04). Each tag represents a specific, tested configuration of system tools and dependencies."
        },
        "arch": {
          "$ref": "#/$defs/PrimitiveValue",
          "description": "CPU architecture for task execution. Common values include 'x86', 'arm64', and 'x86_64'. Architecture selection affects agent allocation and compatibility with certain packages or Docker images. Can be used with template expressions for dynamic architecture selection in parallel builds."
        }
      },
      "unevaluatedProperties": false
    }
  }
}
